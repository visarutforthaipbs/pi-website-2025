import {
  intervalToDuration,
  isPast
} from "./chunk-RR2OGC23.js";
import {
  BackButton,
  DescriptionComponentRenderer,
  Table,
  ValidationError,
  create2 as create,
  create3 as create2,
  create4 as create3,
  create5 as create4,
  create6 as create5,
  create7 as create6,
  create8 as create7,
  errorsTrads,
  generateNKeysBetween,
  getYupValidationErrors,
  require_mapValues,
  useForm,
  useTable
} from "./chunk-RWGGLXMY.js";
import {
  Page,
  createContext,
  useAPIErrorHandler,
  useAuth,
  useGuidedTour,
  useNotification,
  useQueryParams,
  useRBAC,
  useStrapiApp,
  useTracking
} from "./chunk-SNGAK6QT.js";
import {
  Box,
  Button,
  Dialog,
  Flex,
  IconButton,
  LinkButton,
  Loader,
  Menu,
  Modal,
  Radio,
  RawTable,
  SingleSelect,
  SingleSelectOption,
  Status,
  Tbody,
  Td,
  TooltipImpl,
  Tr,
  Typography,
  VisuallyHidden,
  adminApi,
  combineReducers,
  createSlice,
  require_convert,
  require_lib,
  require_pipe,
  require_placeholder,
  useIntl
} from "./chunk-Y2P3SHYJ.js";
import {
  Link,
  NavLink,
  Navigate,
  useLocation,
  useMatch,
  useNavigate,
  useParams
} from "./chunk-NZJNG4T4.js";
import {
  ForwardRef$1R,
  ForwardRef$1r,
  ForwardRef$2h,
  ForwardRef$3,
  ForwardRef$3$,
  ForwardRef$3L,
  ForwardRef$3Z,
  ForwardRef$3r,
  ForwardRef$4j,
  ForwardRef$4p,
  ForwardRef$4x,
  ForwardRef$4z,
  ForwardRef$51,
  ForwardRef$j
} from "./chunk-TKMBRDQV.js";
import {
  require_jsx_runtime
} from "./chunk-GOQBQZHW.js";
import {
  dt
} from "./chunk-GO6TWMX3.js";
import {
  require_react
} from "./chunk-MTZNWPB2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-GFT2G5UO.js";

// node_modules/lodash/fp/mapValues.js
var require_mapValues2 = __commonJS({
  "node_modules/lodash/fp/mapValues.js"(exports, module) {
    var convert = require_convert();
    var func = convert("mapValues", require_mapValues());
    func.placeholder = require_placeholder();
    module.exports = func;
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism = function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v, i) {
                  clone[i] = deepClone(v, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if (document.currentScript && document.currentScript.tagName === "SCRIPT" && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element; element = env.elements[i++]; ) {
            _.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _.util.getLanguage(element);
          var grammar = _.languages[language];
          _.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks = _.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify2(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify2(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify2(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang2 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism;
    }
    Prism.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
    Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
    Prism.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism.languages[lang]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;
    Prism.languages.xml = Prism.languages.extend("markup", {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;
    (function(Prism2) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism2.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
      var markup = Prism2.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism);
    Prism.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism.languages.javascript = Prism.languages.extend("clike", {
      "class-name": [
        Prism.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism.languages.markup) {
      Prism.languages.markup.tag.addInlined("script", "javascript");
      Prism.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism.languages.js = Prism.languages.javascript;
    (function() {
      if (typeof Prism === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading…";
      var FAILURE_MESSAGE = function(status, message) {
        return "✖ Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
          var start = Number(m[1]);
          var comma = m[2];
          var end = m[3];
          if (!comma) {
            return [start, start];
          }
          if (!end) {
            return [start, void 0];
          }
          return [start, Number(end)];
        }
        return void 0;
      }
      Prism.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism.util.setLanguage(code, language);
          Prism.util.setLanguage(pre, language);
          var autoloader = Prism.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start = range[0];
                var end = range[1] == null ? lines.length : range[1];
                if (start < 0) {
                  start += lines.length;
                }
                start = Math.max(0, Math.min(start - 1, lines.length));
                if (end < 0) {
                  end += lines.length;
                }
                end = Math.max(0, Math.min(end, lines.length));
                text = lines.slice(start, end).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start + 1));
                }
              }
              code.textContent = text;
              Prism.highlightElement(code);
            },
            function(error) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error;
            }
          );
        }
      });
      Prism.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element; element = elements[i++]; ) {
            Prism.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/@strapi/content-manager/dist/admin/chunks/index-Cs6qwFQu.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_mapValues = __toESM(require_mapValues2(), 1);
var import_pipe = __toESM(require_pipe(), 1);
var import_qs = __toESM(require_lib(), 1);
var import_prismjs = __toESM(require_prism(), 1);
var PLUGIN_ID = "content-manager";
var PERMISSIONS = [
  "plugin::content-manager.explorer.create",
  "plugin::content-manager.explorer.read",
  "plugin::content-manager.explorer.update",
  "plugin::content-manager.explorer.delete",
  "plugin::content-manager.explorer.publish"
];
var INJECTION_ZONES = {
  editView: {
    informations: [],
    "right-links": []
  },
  listView: {
    actions: [],
    deleteModalAdditionalInfos: [],
    publishModalAdditionalInfos: [],
    unpublishModalAdditionalInfos: []
  }
};
var InjectionZone = ({ area, ...props }) => {
  const components = useInjectionZone(area);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: components.map((component) => (0, import_jsx_runtime.jsx)(component.Component, {
      ...props
    }, component.name))
  });
};
var useInjectionZone = (area) => {
  const getPlugin = useStrapiApp("useInjectionZone", (state) => state.getPlugin);
  const contentManagerPlugin = getPlugin(PLUGIN_ID);
  const [page, position] = area.split(".");
  return contentManagerPlugin.getInjectedComponents(page, position);
};
var ID = "id";
var CREATED_BY_ATTRIBUTE_NAME = "createdBy";
var UPDATED_BY_ATTRIBUTE_NAME = "updatedBy";
var CREATOR_FIELDS = [
  CREATED_BY_ATTRIBUTE_NAME,
  UPDATED_BY_ATTRIBUTE_NAME
];
var PUBLISHED_BY_ATTRIBUTE_NAME = "publishedBy";
var CREATED_AT_ATTRIBUTE_NAME = "createdAt";
var UPDATED_AT_ATTRIBUTE_NAME = "updatedAt";
var PUBLISHED_AT_ATTRIBUTE_NAME = "publishedAt";
var DOCUMENT_META_FIELDS = [
  ID,
  ...CREATOR_FIELDS,
  PUBLISHED_BY_ATTRIBUTE_NAME,
  CREATED_AT_ATTRIBUTE_NAME,
  UPDATED_AT_ATTRIBUTE_NAME,
  PUBLISHED_AT_ATTRIBUTE_NAME
];
var ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD = [
  "dynamiczone",
  "json",
  "text",
  "relation",
  "component",
  "boolean",
  "media",
  "password",
  "richtext",
  "timestamp",
  "blocks"
];
var SINGLE_TYPES = "single-types";
var COLLECTION_TYPES = "collection-types";
var [DocumentRBACProvider, useDocumentRBAC] = createContext("DocumentRBAC", {
  canCreate: false,
  canCreateFields: [],
  canDelete: false,
  canPublish: false,
  canRead: false,
  canReadFields: [],
  canUpdate: false,
  canUpdateFields: [],
  canUserAction: () => false,
  isLoading: false
});
var DocumentRBAC = ({ children, permissions }) => {
  const { slug } = useParams();
  if (!slug) {
    throw new Error("Cannot find the slug param in the URL");
  }
  const [{ rawQuery }] = useQueryParams();
  const userPermissions = useAuth("DocumentRBAC", (state) => state.permissions);
  const contentTypePermissions = React.useMemo(() => {
    const contentTypePermissions2 = userPermissions.filter((permission) => permission.subject === slug);
    return contentTypePermissions2.reduce((acc, permission) => {
      const [action] = permission.action.split(".").slice(-1);
      return {
        ...acc,
        [action]: [
          permission
        ]
      };
    }, {});
  }, [
    slug,
    userPermissions
  ]);
  const { isLoading, allowedActions } = useRBAC(
    contentTypePermissions,
    permissions ?? void 0,
    // TODO: useRBAC context should be typed and built differently
    // We are passing raw query as context to the hook so that it can
    // rely on the locale provided from DocumentRBAC for its permission calculations.
    rawQuery
  );
  const canCreateFields = !isLoading && allowedActions.canCreate ? extractAndDedupeFields(contentTypePermissions.create) : [];
  const canReadFields = !isLoading && allowedActions.canRead ? extractAndDedupeFields(contentTypePermissions.read) : [];
  const canUpdateFields = !isLoading && allowedActions.canUpdate ? extractAndDedupeFields(contentTypePermissions.update) : [];
  const canUserAction = React.useCallback((fieldName, fieldsUserCanAction, fieldType) => {
    const name = removeNumericalStrings(fieldName.split("."));
    const componentFieldNames = fieldsUserCanAction.filter((field) => field.split(".").length > 1);
    if (fieldType === "component") {
      return componentFieldNames.some((field) => {
        return field.includes(name.join("."));
      });
    }
    if (name.length > 1) {
      return componentFieldNames.includes(name.join("."));
    }
    return fieldsUserCanAction.includes(fieldName);
  }, []);
  if (isLoading) {
    return (0, import_jsx_runtime.jsx)(Page.Loading, {});
  }
  return (0, import_jsx_runtime.jsx)(DocumentRBACProvider, {
    isLoading,
    canCreateFields,
    canReadFields,
    canUpdateFields,
    canUserAction,
    ...allowedActions,
    children
  });
};
var extractAndDedupeFields = (permissions = []) => permissions.flatMap((permission) => {
  var _a;
  return (_a = permission.properties) == null ? void 0 : _a.fields;
}).filter((field, index2, arr) => arr.indexOf(field) === index2 && typeof field === "string");
var removeNumericalStrings = (arr) => arr.filter((item) => isNaN(Number(item)));
var BLOCK_LIST_ATTRIBUTE_KEYS = [
  "__component",
  "__temp_key__"
];
var traverseData = (predicate, transform) => (schema, components = {}) => (data = {}) => {
  const traverse = (datum, attributes) => {
    return Object.entries(datum).reduce((acc, [key, value]) => {
      var _a;
      const attribute = attributes[key];
      if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === void 0) {
        acc[key] = value;
        return acc;
      }
      if (attribute.type === "component") {
        if (attribute.repeatable) {
          const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
          acc[key] = componentValue.map((componentData) => {
            var _a2;
            return traverse(componentData, ((_a2 = components[attribute.component]) == null ? void 0 : _a2.attributes) ?? {});
          });
        } else {
          const componentValue = predicate(attribute, value) ? transform(value, attribute) : value;
          acc[key] = traverse(componentValue, ((_a = components[attribute.component]) == null ? void 0 : _a.attributes) ?? {});
        }
      } else if (attribute.type === "dynamiczone") {
        const dynamicZoneValue = predicate(attribute, value) ? transform(value, attribute) : value;
        acc[key] = dynamicZoneValue.map((componentData) => {
          var _a2;
          return traverse(componentData, ((_a2 = components[componentData.__component]) == null ? void 0 : _a2.attributes) ?? {});
        });
      } else if (predicate(attribute, value)) {
        acc[key] = transform(value, attribute);
      } else {
        acc[key] = value;
      }
      return acc;
    }, {});
  };
  return traverse(data, schema.attributes);
};
var removeProhibitedFields = (prohibitedFields) => traverseData((attribute) => prohibitedFields.includes(attribute.type), () => "");
var prepareRelations = traverseData((attribute) => attribute.type === "relation", () => ({
  connect: [],
  disconnect: []
}));
var prepareTempKeys = traverseData((attribute) => attribute.type === "component" && attribute.repeatable || attribute.type === "dynamiczone", (data) => {
  if (Array.isArray(data) && data.length > 0) {
    const keys = generateNKeysBetween(void 0, void 0, data.length);
    return data.map((datum, index2) => ({
      ...datum,
      __temp_key__: keys[index2]
    }));
  }
  return data;
});
var removeFieldsThatDontExistOnSchema = (schema) => (data) => {
  const schemaKeys = Object.keys(schema.attributes);
  const dataKeys = Object.keys(data);
  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));
  const revisedData = [
    ...keysToRemove,
    ...DOCUMENT_META_FIELDS
  ].reduce((acc, key) => {
    delete acc[key];
    return acc;
  }, structuredClone(data));
  return revisedData;
};
var removeNullValues = (data) => {
  return Object.entries(data).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
};
var transformDocument = (schema, components = {}) => (document2) => {
  const transformations = (0, import_pipe.default)(removeFieldsThatDontExistOnSchema(schema), removeProhibitedFields([
    "password"
  ])(schema, components), removeNullValues, prepareRelations(schema, components), prepareTempKeys(schema, components));
  return transformations(document2);
};
var createDefaultForm = (contentType, components = {}) => {
  const traverseSchema = (attributes) => {
    return Object.entries(attributes).reduce((acc, [key, attribute]) => {
      if ("default" in attribute) {
        acc[key] = attribute.default;
      } else if (attribute.type === "component" && attribute.required) {
        const defaultComponentForm = traverseSchema(components[attribute.component].attributes);
        if (attribute.repeatable) {
          acc[key] = attribute.min ? [
            ...Array(attribute.min).fill(defaultComponentForm)
          ] : [];
        } else {
          acc[key] = defaultComponentForm;
        }
      } else if (attribute.type === "dynamiczone" && attribute.required) {
        acc[key] = [];
      }
      return acc;
    }, {});
  };
  return traverseSchema(contentType.attributes);
};
var contentManagerApi = adminApi.enhanceEndpoints({
  addTagTypes: [
    "ComponentConfiguration",
    "ContentTypesConfiguration",
    "ContentTypeSettings",
    "Document",
    "InitialData",
    "HistoryVersion",
    "Relations",
    "UidAvailability",
    "RecentDocumentList"
  ]
});
var documentApi = contentManagerApi.injectEndpoints({
  overrideExisting: true,
  endpoints: (builder) => ({
    autoCloneDocument: builder.mutation({
      query: ({ model, sourceId, query }) => ({
        url: `/content-manager/collection-types/${model}/auto-clone/${sourceId}`,
        method: "POST",
        config: {
          params: query
        }
      }),
      invalidatesTags: (_result, error, { model }) => {
        if (error) {
          return [];
        }
        return [
          {
            type: "Document",
            id: `${model}_LIST`
          },
          "RecentDocumentList"
        ];
      }
    }),
    cloneDocument: builder.mutation({
      query: ({ model, sourceId, data, params }) => ({
        url: `/content-manager/collection-types/${model}/clone/${sourceId}`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { model }) => [
        {
          type: "Document",
          id: `${model}_LIST`
        },
        {
          type: "UidAvailability",
          id: model
        },
        "RecentDocumentList"
      ]
    }),
    /**
    * Creates a new collection-type document. This should ONLY be used for collection-types.
    * single-types should always be using `updateDocument` since they always exist.
    */
    createDocument: builder.mutation({
      query: ({ model, data, params }) => ({
        url: `/content-manager/collection-types/${model}`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (result, _error, { model }) => [
        {
          type: "Document",
          id: `${model}_LIST`
        },
        "Relations",
        {
          type: "UidAvailability",
          id: model
        },
        "RecentDocumentList"
      ],
      transformResponse: (response, meta, arg) => {
        if (!("data" in response) && arg.model === "plugin::users-permissions.user") {
          return {
            data: response,
            meta: {
              availableStatus: [],
              availableLocales: []
            }
          };
        }
        return response;
      }
    }),
    deleteDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params }) => ({
        url: `/content-manager/${collectionType}/${model}${collectionType !== SINGLE_TYPES && documentId ? `/${documentId}` : ""}`,
        method: "DELETE",
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model }) => [
        {
          type: "Document",
          id: collectionType !== SINGLE_TYPES ? `${model}_LIST` : model
        },
        "RecentDocumentList"
      ]
    }),
    deleteManyDocuments: builder.mutation({
      query: ({ model, params, ...body }) => ({
        url: `/content-manager/collection-types/${model}/actions/bulkDelete`,
        method: "POST",
        data: body,
        config: {
          params
        }
      }),
      invalidatesTags: (_res, _error, { model }) => [
        {
          type: "Document",
          id: `${model}_LIST`
        },
        "RecentDocumentList"
      ]
    }),
    discardDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/discard` : `/content-manager/${collectionType}/${model}/actions/discard`,
        method: "POST",
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          {
            type: "Document",
            id: `${model}_LIST`
          },
          "Relations",
          {
            type: "UidAvailability",
            id: model
          },
          "RecentDocumentList"
        ];
      }
    }),
    /**
    * Gets all documents of a collection type or single type.
    * By passing different params you can get different results e.g. only published documents or 'es' documents.
    */
    getAllDocuments: builder.query({
      query: ({ model, params }) => ({
        url: `/content-manager/collection-types/${model}`,
        method: "GET",
        config: {
          params: (0, import_qs.stringify)(params, {
            encode: true
          })
        }
      }),
      providesTags: (result, _error, arg) => {
        return [
          {
            type: "Document",
            id: `ALL_LIST`
          },
          {
            type: "Document",
            id: `${arg.model}_LIST`
          },
          ...(result == null ? void 0 : result.results.map(({ documentId }) => ({
            type: "Document",
            id: `${arg.model}_${documentId}`
          }))) ?? []
        ];
      }
    }),
    getDraftRelationCount: builder.query({
      query: ({ collectionType, model, documentId, params }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/countDraftRelations` : `/content-manager/${collectionType}/${model}/actions/countDraftRelations`,
        method: "GET",
        config: {
          params
        }
      })
    }),
    getDocument: builder.query({
      // @ts-expect-error – TODO: fix ts error where data unknown doesn't work with response via an assertion?
      queryFn: async ({ collectionType, model, documentId, params }, _api, _extraOpts, baseQuery) => {
        const res = await baseQuery({
          url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ""}`,
          method: "GET",
          config: {
            params
          }
        });
        if (res.error && res.error.name === "NotFoundError" && collectionType === SINGLE_TYPES) {
          return {
            data: {
              document: void 0
            },
            error: void 0
          };
        }
        return res;
      },
      providesTags: (result, _error, { collectionType, model, documentId }) => {
        return [
          // we prefer the result's id because we don't fetch single-types with an ID.
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${result && "documentId" in result ? result.documentId : documentId}` : model
          },
          // Make it easy to invalidate all individual documents queries for a model
          {
            type: "Document",
            id: `${model}_ALL_ITEMS`
          }
        ];
      }
    }),
    getManyDraftRelationCount: builder.query({
      query: ({ model, ...params }) => ({
        url: `/content-manager/collection-types/${model}/actions/countManyEntriesDraftRelations`,
        method: "GET",
        config: {
          params
        }
      }),
      transformResponse: (response) => response.data
    }),
    /**
    * This endpoint will either create or update documents at the same time as publishing.
    */
    publishDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params, data }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/publish` : `/content-manager/${collectionType}/${model}/actions/publish`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          {
            type: "Document",
            id: `${model}_LIST`
          },
          "Relations",
          "RecentDocumentList"
        ];
      }
    }),
    publishManyDocuments: builder.mutation({
      query: ({ model, params, ...body }) => ({
        url: `/content-manager/collection-types/${model}/actions/bulkPublish`,
        method: "POST",
        data: body,
        config: {
          params
        }
      }),
      invalidatesTags: (_res, _error, { model, documentIds }) => documentIds.map((id) => ({
        type: "Document",
        id: `${model}_${id}`
      }))
    }),
    updateDocument: builder.mutation({
      query: ({ collectionType, model, documentId, data, params }) => ({
        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ""}`,
        method: "PUT",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          "Relations",
          {
            type: "UidAvailability",
            id: model
          },
          "RecentDocumentList",
          "RecentDocumentList"
        ];
      },
      async onQueryStarted({ data, ...patch }, { dispatch, queryFulfilled }) {
        const patchResult = dispatch(documentApi.util.updateQueryData("getDocument", patch, (draft) => {
          Object.assign(draft.data, data);
        }));
        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      }
    }),
    unpublishDocument: builder.mutation({
      query: ({ collectionType, model, documentId, params, data }) => ({
        url: documentId ? `/content-manager/${collectionType}/${model}/${documentId}/actions/unpublish` : `/content-manager/${collectionType}/${model}/actions/unpublish`,
        method: "POST",
        data,
        config: {
          params
        }
      }),
      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {
        return [
          {
            type: "Document",
            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model
          },
          "RecentDocumentList"
        ];
      }
    }),
    unpublishManyDocuments: builder.mutation({
      query: ({ model, params, ...body }) => ({
        url: `/content-manager/collection-types/${model}/actions/bulkUnpublish`,
        method: "POST",
        data: body,
        config: {
          params
        }
      }),
      invalidatesTags: (_res, _error, { model, documentIds }) => [
        ...documentIds.map((id) => ({
          type: "Document",
          id: `${model}_${id}`
        })),
        "RecentDocumentList"
      ]
    })
  })
});
var { useAutoCloneDocumentMutation, useCloneDocumentMutation, useCreateDocumentMutation, useDeleteDocumentMutation, useDeleteManyDocumentsMutation, useDiscardDocumentMutation, useGetAllDocumentsQuery, useLazyGetDocumentQuery, useGetDocumentQuery, useLazyGetDraftRelationCountQuery, useGetManyDraftRelationCountQuery, usePublishDocumentMutation, usePublishManyDocumentsMutation, useUpdateDocumentMutation, useUnpublishDocumentMutation, useUnpublishManyDocumentsMutation } = documentApi;
var buildValidParams = (query) => {
  if (!query)
    return query;
  const { plugins: _, ...validQueryParams } = {
    ...query,
    ...Object.values((query == null ? void 0 : query.plugins) ?? {}).reduce((acc, current) => Object.assign(acc, current), {})
  };
  return validQueryParams;
};
var isBaseQueryError = (error) => {
  return error.name !== void 0;
};
var arrayValidator = (attribute, options) => ({
  message: errorsTrads.required,
  test(value) {
    if (options.status === "draft") {
      return true;
    }
    if (!attribute.required) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (Array.isArray(value) && value.length === 0) {
      return false;
    }
    return true;
  }
});
var createYupSchema = (attributes = {}, components = {}, options = {
  status: null
}) => {
  const createModelSchema = (attributes2) => create5().shape(Object.entries(attributes2).reduce((acc, [name, attribute]) => {
    if (DOCUMENT_META_FIELDS.includes(name)) {
      return acc;
    }
    const validations = [
      addNullableValidation,
      addRequiredValidation,
      addMinLengthValidation,
      addMaxLengthValidation,
      addMinValidation,
      addMaxValidation,
      addRegexValidation
    ].map((fn) => fn(attribute, options));
    const transformSchema = (0, import_pipe.default)(...validations);
    switch (attribute.type) {
      case "component": {
        const { attributes: attributes3 } = components[attribute.component];
        if (attribute.repeatable) {
          return {
            ...acc,
            [name]: transformSchema(create6().of(createModelSchema(attributes3).nullable(false))).test(arrayValidator(attribute, options))
          };
        } else {
          return {
            ...acc,
            [name]: transformSchema(createModelSchema(attributes3).nullable())
          };
        }
      }
      case "dynamiczone":
        return {
          ...acc,
          [name]: transformSchema(create6().of(create7((data) => {
            var _a;
            const attributes3 = (_a = components == null ? void 0 : components[data == null ? void 0 : data.__component]) == null ? void 0 : _a.attributes;
            const validation = create5().shape({
              __component: create3().required().oneOf(Object.keys(components))
            }).nullable(false);
            if (!attributes3) {
              return validation;
            }
            return validation.concat(createModelSchema(attributes3));
          }))).test(arrayValidator(attribute, options))
        };
      case "relation":
        return {
          ...acc,
          [name]: transformSchema(create7((value) => {
            if (!value) {
              return create().nullable(true);
            } else if (Array.isArray(value)) {
              return create6().of(create5().shape({
                id: create4().required()
              }));
            } else if (typeof value === "object") {
              return create5();
            } else {
              return create().test("type-error", "Relation values must be either null, an array of objects with {id} or an object.", () => false);
            }
          }))
        };
      default:
        return {
          ...acc,
          [name]: transformSchema(createAttributeSchema(attribute))
        };
    }
  }, {})).default(null);
  return createModelSchema(attributes);
};
var createAttributeSchema = (attribute) => {
  switch (attribute.type) {
    case "biginteger":
      return create3().matches(/^-?\d*$/);
    case "boolean":
      return create2();
    case "blocks":
      return create().test("isBlocks", errorsTrads.json, (value) => {
        if (!value || Array.isArray(value)) {
          return true;
        } else {
          return false;
        }
      });
    case "decimal":
    case "float":
    case "integer":
      return create4();
    case "email":
      return create3().email(errorsTrads.email);
    case "enumeration":
      return create3().oneOf([
        ...attribute.enum,
        null
      ]);
    case "json":
      return create().test("isJSON", errorsTrads.json, (value) => {
        if (!value || typeof value === "string" && value.length === 0) {
          return true;
        }
        if (typeof value === "object") {
          try {
            JSON.stringify(value);
            return true;
          } catch (err) {
            return false;
          }
        }
        try {
          JSON.parse(value);
          return true;
        } catch (err) {
          return false;
        }
      });
    case "password":
    case "richtext":
    case "string":
    case "text":
      return create3();
    case "uid":
      return create3().matches(/^[A-Za-z0-9-_.~]*$/);
    default:
      return create();
  }
};
var nullableSchema = (schema) => {
  return (schema == null ? void 0 : schema.nullable) ? schema.nullable() : (
    // e.g. when the schema has been built using yup.lazy (e.g. for relations).
    // In these cases we should just return the schema as it is.
    schema
  );
};
var addNullableValidation = () => (schema) => {
  return nullableSchema(schema);
};
var addRequiredValidation = (attribute, options) => (schema) => {
  if (options.status === "draft" || !attribute.required) {
    return schema;
  }
  if (attribute.required && "required" in schema) {
    return schema.required(errorsTrads.required);
  }
  return schema;
};
var addMinLengthValidation = (attribute, options) => (schema) => {
  if (options.status === "draft") {
    return schema;
  }
  if ("minLength" in attribute && attribute.minLength && Number.isInteger(attribute.minLength) && "min" in schema) {
    return schema.min(attribute.minLength, {
      ...errorsTrads.minLength,
      values: {
        min: attribute.minLength
      }
    });
  }
  return schema;
};
var addMaxLengthValidation = (attribute) => (schema) => {
  if ("maxLength" in attribute && attribute.maxLength && Number.isInteger(attribute.maxLength) && "max" in schema) {
    return schema.max(attribute.maxLength, {
      ...errorsTrads.maxLength,
      values: {
        max: attribute.maxLength
      }
    });
  }
  return schema;
};
var addMinValidation = (attribute, options) => (schema) => {
  if (options.status === "draft") {
    return schema;
  }
  if ("min" in attribute && "min" in schema) {
    const min = toInteger(attribute.min);
    if (min) {
      return schema.min(min, {
        ...errorsTrads.min,
        values: {
          min
        }
      });
    }
  }
  return schema;
};
var addMaxValidation = (attribute) => (schema) => {
  if ("max" in attribute) {
    const max = toInteger(attribute.max);
    if ("max" in schema && max) {
      return schema.max(max, {
        ...errorsTrads.max,
        values: {
          max
        }
      });
    }
  }
  return schema;
};
var toInteger = (val) => {
  if (typeof val === "number" || val === void 0) {
    return val;
  } else {
    const num = Number(val);
    return isNaN(num) ? void 0 : num;
  }
};
var addRegexValidation = (attribute) => (schema) => {
  if ("regex" in attribute && attribute.regex && "matches" in schema) {
    return schema.matches(new RegExp(attribute.regex), {
      message: {
        id: errorsTrads.regex.id,
        defaultMessage: "The value does not match the defined pattern."
      },
      excludeEmptyString: !attribute.required
    });
  }
  return schema;
};
var initApi = contentManagerApi.injectEndpoints({
  endpoints: (builder) => ({
    getInitialData: builder.query({
      query: () => "/content-manager/init",
      transformResponse: (response) => response.data,
      providesTags: [
        "InitialData"
      ]
    })
  })
});
var { useGetInitialDataQuery } = initApi;
var useContentTypeSchema = (model) => {
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const { data, error, isLoading, isFetching } = useGetInitialDataQuery(void 0);
  const { components, contentType, contentTypes } = React.useMemo(() => {
    const contentType2 = data == null ? void 0 : data.contentTypes.find((ct) => ct.uid === model);
    const componentsByKey = data == null ? void 0 : data.components.reduce((acc, component) => {
      acc[component.uid] = component;
      return acc;
    }, {});
    const components2 = extractContentTypeComponents(contentType2 == null ? void 0 : contentType2.attributes, componentsByKey);
    return {
      components: Object.keys(components2).length === 0 ? void 0 : components2,
      contentType: contentType2,
      contentTypes: (data == null ? void 0 : data.contentTypes) ?? []
    };
  }, [
    model,
    data
  ]);
  React.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [
    toggleNotification,
    error,
    formatAPIError
  ]);
  return {
    // This must be memoized to avoid inifiinite re-renders where the empty object is different everytime.
    components: React.useMemo(() => components ?? {}, [
      components
    ]),
    schema: contentType,
    schemas: contentTypes,
    isLoading: isLoading || isFetching
  };
};
var extractContentTypeComponents = (attributes = {}, allComponents = {}) => {
  const getComponents = (attributes2) => {
    return attributes2.reduce((acc, attribute) => {
      var _a;
      if (attribute.type === "component") {
        const componentAttributes = Object.values(((_a = allComponents[attribute.component]) == null ? void 0 : _a.attributes) ?? {});
        acc.push(attribute.component, ...getComponents(componentAttributes));
      } else if (attribute.type === "dynamiczone") {
        acc.push(
          ...attribute.components,
          ...attribute.components.flatMap((componentUid) => {
            var _a2;
            const componentAttributes = Object.values(((_a2 = allComponents[componentUid]) == null ? void 0 : _a2.attributes) ?? {});
            return getComponents(componentAttributes);
          })
        );
      }
      return acc;
    }, []);
  };
  const componentUids = getComponents(Object.values(attributes));
  const uniqueComponentUids = [
    ...new Set(componentUids)
  ];
  const componentsByKey = uniqueComponentUids.reduce((acc, uid) => {
    acc[uid] = allComponents[uid];
    return acc;
  }, {});
  return componentsByKey;
};
var HOOKS = {
  /**
  * Hook that allows to mutate the displayed headers of the list view table
  * @constant
  * @type {string}
  */
  INJECT_COLUMN_IN_TABLE: "Admin/CM/pages/ListView/inject-column-in-table",
  /**
  * Hook that allows to mutate the CM's collection types links pre-set filters
  * @constant
  * @type {string}
  */
  MUTATE_COLLECTION_TYPES_LINKS: "Admin/CM/pages/App/mutate-collection-types-links",
  /**
  * Hook that allows to mutate the CM's edit view layout
  * @constant
  * @type {string}
  */
  MUTATE_EDIT_VIEW_LAYOUT: "Admin/CM/pages/EditView/mutate-edit-view-layout",
  /**
  * Hook that allows to mutate the CM's single types links pre-set filters
  * @constant
  * @type {string}
  */
  MUTATE_SINGLE_TYPES_LINKS: "Admin/CM/pages/App/mutate-single-types-links"
};
var contentTypesApi = contentManagerApi.injectEndpoints({
  endpoints: (builder) => ({
    getContentTypeConfiguration: builder.query({
      query: (uid) => ({
        url: `/content-manager/content-types/${uid}/configuration`,
        method: "GET"
      }),
      transformResponse: (response) => response.data,
      providesTags: (_result, _error, uid) => [
        {
          type: "ContentTypesConfiguration",
          id: uid
        },
        {
          type: "ContentTypeSettings",
          id: "LIST"
        }
      ]
    }),
    getAllContentTypeSettings: builder.query({
      query: () => "/content-manager/content-types-settings",
      transformResponse: (response) => response.data,
      providesTags: [
        {
          type: "ContentTypeSettings",
          id: "LIST"
        }
      ]
    }),
    updateContentTypeConfiguration: builder.mutation({
      query: ({ uid, ...body }) => ({
        url: `/content-manager/content-types/${uid}/configuration`,
        method: "PUT",
        data: body
      }),
      transformResponse: (response) => response.data,
      invalidatesTags: (_result, _error, { uid }) => [
        {
          type: "ContentTypesConfiguration",
          id: uid
        },
        {
          type: "ContentTypeSettings",
          id: "LIST"
        },
        // Is this necessary?
        {
          type: "InitialData"
        }
      ]
    })
  })
});
var { useGetContentTypeConfigurationQuery, useGetAllContentTypeSettingsQuery, useUpdateContentTypeConfigurationMutation } = contentTypesApi;
var checkIfAttributeIsDisplayable = (attribute) => {
  const { type } = attribute;
  if (type === "relation") {
    return !attribute.relation.toLowerCase().includes("morph");
  }
  return ![
    "json",
    "dynamiczone",
    "richtext",
    "password",
    "blocks"
  ].includes(type) && !!type;
};
var getMainField = (attribute, mainFieldName, { schemas, components }) => {
  var _a;
  if (!mainFieldName) {
    return void 0;
  }
  const mainFieldType = attribute.type === "component" ? components[attribute.component].attributes[mainFieldName].type : (_a = schemas.find((schema) => schema.uid === attribute.targetModel)) == null ? void 0 : _a.attributes[mainFieldName].type;
  return {
    name: mainFieldName,
    type: mainFieldType ?? "string"
  };
};
var DEFAULT_SETTINGS = {
  bulkable: false,
  filterable: false,
  searchable: false,
  pagination: false,
  defaultSortBy: "",
  defaultSortOrder: "asc",
  mainField: "id",
  pageSize: 10
};
var useDocumentLayout = (model) => {
  const { schema, components } = useDocument({
    model,
    collectionType: ""
  }, {
    skip: true
  });
  const [{ query }] = useQueryParams();
  const runHookWaterfall = useStrapiApp("useDocumentLayout", (state) => state.runHookWaterfall);
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const { isLoading: isLoadingSchemas, schemas } = useContentTypeSchema();
  const { data, isLoading: isLoadingConfigs, error, isFetching: isFetchingConfigs } = useGetContentTypeConfigurationQuery(model);
  const isLoading = isLoadingSchemas || isFetchingConfigs || isLoadingConfigs;
  React.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [
    error,
    formatAPIError,
    toggleNotification
  ]);
  const editLayout = React.useMemo(() => data && !isLoading ? formatEditLayout(data, {
    schemas,
    schema,
    components
  }) : {
    layout: [],
    components: {},
    metadatas: {},
    options: {},
    settings: DEFAULT_SETTINGS
  }, [
    data,
    isLoading,
    schemas,
    schema,
    components
  ]);
  const listLayout = React.useMemo(() => {
    return data && !isLoading ? formatListLayout(data, {
      schemas,
      schema,
      components
    }) : {
      layout: [],
      metadatas: {},
      options: {},
      settings: DEFAULT_SETTINGS
    };
  }, [
    data,
    isLoading,
    schemas,
    schema,
    components
  ]);
  const { layout: edit } = React.useMemo(() => runHookWaterfall(HOOKS.MUTATE_EDIT_VIEW_LAYOUT, {
    layout: editLayout,
    query
  }), [
    editLayout,
    query,
    runHookWaterfall
  ]);
  return {
    error,
    isLoading,
    edit,
    list: listLayout
  };
};
var useDocLayout = () => {
  const { model } = useDoc();
  return useDocumentLayout(model);
};
var formatEditLayout = (data, { schemas, schema, components }) => {
  let currentPanelIndex = 0;
  const panelledEditAttributes = convertEditLayoutToFieldLayouts(data.contentType.layouts.edit, schema == null ? void 0 : schema.attributes, data.contentType.metadatas, {
    configurations: data.components,
    schemas: components
  }, schemas).reduce((panels, row) => {
    if (row.some((field) => field.type === "dynamiczone")) {
      panels.push([
        row
      ]);
      currentPanelIndex += 2;
    } else {
      if (!panels[currentPanelIndex]) {
        panels.push([
          row
        ]);
      } else {
        panels[currentPanelIndex].push(row);
      }
    }
    return panels;
  }, []);
  const componentEditAttributes = Object.entries(data.components).reduce((acc, [uid, configuration]) => {
    acc[uid] = {
      layout: convertEditLayoutToFieldLayouts(configuration.layouts.edit, components[uid].attributes, configuration.metadatas, {
        configurations: data.components,
        schemas: components
      }),
      settings: {
        ...configuration.settings,
        icon: components[uid].info.icon,
        displayName: components[uid].info.displayName
      }
    };
    return acc;
  }, {});
  const editMetadatas = Object.entries(data.contentType.metadatas).reduce((acc, [attribute, metadata]) => {
    return {
      ...acc,
      [attribute]: metadata.edit
    };
  }, {});
  return {
    layout: panelledEditAttributes,
    components: componentEditAttributes,
    metadatas: editMetadatas,
    settings: {
      ...data.contentType.settings,
      displayName: schema == null ? void 0 : schema.info.displayName
    },
    options: {
      ...schema == null ? void 0 : schema.options,
      ...schema == null ? void 0 : schema.pluginOptions,
      ...data.contentType.options
    }
  };
};
var convertEditLayoutToFieldLayouts = (rows, attributes = {}, metadatas, components, schemas = []) => {
  return rows.map((row) => row.map((field) => {
    const attribute = attributes[field.name];
    if (!attribute) {
      return null;
    }
    const { edit: metadata } = metadatas[field.name];
    const settings = attribute.type === "component" && components ? components.configurations[attribute.component].settings : {};
    return {
      attribute,
      disabled: !metadata.editable,
      hint: metadata.description,
      label: metadata.label ?? "",
      name: field.name,
      // @ts-expect-error – mainField does exist on the metadata for a relation.
      mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
        schemas,
        components: (components == null ? void 0 : components.schemas) ?? {}
      }),
      placeholder: metadata.placeholder ?? "",
      required: attribute.required ?? false,
      size: field.size,
      unique: "unique" in attribute ? attribute.unique : false,
      visible: metadata.visible ?? true,
      type: attribute.type
    };
  }).filter((field) => field !== null));
};
var formatListLayout = (data, { schemas, schema, components }) => {
  const listMetadatas = Object.entries(data.contentType.metadatas).reduce((acc, [attribute, metadata]) => {
    return {
      ...acc,
      [attribute]: metadata.list
    };
  }, {});
  const listAttributes = convertListLayoutToFieldLayouts(data.contentType.layouts.list, schema == null ? void 0 : schema.attributes, listMetadatas, {
    configurations: data.components,
    schemas: components
  }, schemas);
  return {
    layout: listAttributes,
    settings: {
      ...data.contentType.settings,
      displayName: schema == null ? void 0 : schema.info.displayName
    },
    metadatas: listMetadatas,
    options: {
      ...schema == null ? void 0 : schema.options,
      ...schema == null ? void 0 : schema.pluginOptions,
      ...data.contentType.options
    }
  };
};
var convertListLayoutToFieldLayouts = (columns, attributes = {}, metadatas, components, schemas = []) => {
  return columns.map((name) => {
    const attribute = attributes[name];
    if (!attribute) {
      return null;
    }
    const metadata = metadatas[name];
    const settings = attribute.type === "component" && components ? components.configurations[attribute.component].settings : {};
    return {
      attribute,
      label: metadata.label ?? "",
      mainField: getMainField(attribute, metadata.mainField || settings.mainField, {
        schemas,
        components: (components == null ? void 0 : components.schemas) ?? {}
      }),
      name,
      searchable: metadata.searchable ?? true,
      sortable: metadata.sortable ?? true
    };
  }).filter((field) => field !== null);
};
var useDocument = (args, opts) => {
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const { formatMessage } = useIntl();
  const { currentData: data, isLoading: isLoadingDocument, isFetching: isFetchingDocument, error } = useGetDocumentQuery(args, {
    ...opts,
    skip: !args.documentId && args.collectionType !== SINGLE_TYPES || (opts == null ? void 0 : opts.skip)
  });
  const document2 = data == null ? void 0 : data.data;
  const meta = data == null ? void 0 : data.meta;
  const { components, schema, schemas, isLoading: isLoadingSchema } = useContentTypeSchema(args.model);
  const isSingleType = (schema == null ? void 0 : schema.kind) === "singleType";
  const getTitle = (mainField) => {
    if (mainField !== "id" && (document2 == null ? void 0 : document2[mainField])) {
      return document2[mainField];
    }
    if (isSingleType && (schema == null ? void 0 : schema.info.displayName)) {
      return schema.info.displayName;
    }
    return formatMessage({
      id: "content-manager.containers.untitled",
      defaultMessage: "Untitled"
    });
  };
  React.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [
    toggleNotification,
    error,
    formatAPIError,
    args.collectionType
  ]);
  const validationSchema = React.useMemo(() => {
    if (!schema) {
      return null;
    }
    return createYupSchema(schema.attributes, components);
  }, [
    schema,
    components
  ]);
  const validate = React.useCallback((document3) => {
    if (!validationSchema) {
      throw new Error("There is no validation schema generated, this is likely due to the schema not being loaded yet.");
    }
    try {
      validationSchema.validateSync(document3, {
        abortEarly: false,
        strict: true
      });
      return null;
    } catch (error2) {
      if (error2 instanceof ValidationError) {
        return getYupValidationErrors(error2);
      }
      throw error2;
    }
  }, [
    validationSchema
  ]);
  const getInitialFormValues = React.useCallback((isCreatingDocument = false) => {
    if (!document2 && !isCreatingDocument && !isSingleType || !schema) {
      return void 0;
    }
    const form = (document2 == null ? void 0 : document2.id) ? document2 : createDefaultForm(schema, components);
    return transformDocument(schema, components)(form);
  }, [
    document2,
    isSingleType,
    schema,
    components
  ]);
  const isLoading = isLoadingDocument || isFetchingDocument || isLoadingSchema;
  const hasError = !!error;
  return {
    components,
    document: document2,
    meta,
    isLoading,
    hasError,
    schema,
    schemas,
    validate,
    getTitle,
    getInitialFormValues
  };
};
var useDoc = () => {
  const { id, slug, collectionType, origin } = useParams();
  const [{ query }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  if (!collectionType) {
    throw new Error("Could not find collectionType in url params");
  }
  if (!slug) {
    throw new Error("Could not find model in url params");
  }
  const document2 = useDocument({
    documentId: origin || id,
    model: slug,
    collectionType,
    params
  }, {
    skip: id === "create" || !origin && !id && collectionType !== SINGLE_TYPES
  });
  const returnId = origin || id === "create" ? void 0 : id;
  return {
    collectionType,
    model: slug,
    id: returnId,
    ...document2
  };
};
var useContentManagerContext = () => {
  var _a;
  const { collectionType, model, id, components, isLoading: isLoadingDoc, schema, schemas } = useDoc();
  const layout = useDocumentLayout(model);
  const form = useForm("useContentManagerContext", (state) => state);
  const isSingleType = collectionType === SINGLE_TYPES;
  const slug = model;
  const isCreatingEntry = id === "create";
  useContentTypeSchema();
  const isLoading = isLoadingDoc || layout.isLoading;
  const error = layout.error;
  return {
    error,
    isLoading,
    // Base metadata
    model,
    collectionType,
    id,
    slug,
    isCreatingEntry,
    isSingleType,
    hasDraftAndPublish: ((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish) ?? false,
    // All schema infos
    components,
    contentType: schema,
    contentTypes: schemas,
    // Form state
    form,
    // layout infos
    layout
  };
};
var prefixPluginTranslations = (trad, pluginId) => {
  return Object.keys(trad).reduce((acc, current) => {
    acc[`${pluginId}.${current}`] = trad[current];
    return acc;
  }, {});
};
var getTranslation = (id) => `content-manager.${id}`;
var DEFAULT_UNEXPECTED_ERROR_MSG = {
  id: "notification.error",
  defaultMessage: "An error occurred, please try again"
};
var useDocumentActions = () => {
  const { toggleNotification } = useNotification();
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const navigate = useNavigate();
  const setCurrentStep = useGuidedTour("useDocumentActions", (state) => state.setCurrentStep);
  const [deleteDocument] = useDeleteDocumentMutation();
  const _delete = React.useCallback(async ({ collectionType, model, documentId, params }, trackerProperty) => {
    try {
      trackUsage("willDeleteEntry", trackerProperty);
      const res = await deleteDocument({
        collectionType,
        model,
        documentId,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.delete"),
          defaultMessage: "Deleted document"
        })
      });
      trackUsage("didDeleteEntry", trackerProperty);
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotDeleteEntry", {
        error: err,
        ...trackerProperty
      });
      throw err;
    }
  }, [
    trackUsage,
    deleteDocument,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [deleteManyDocuments] = useDeleteManyDocumentsMutation();
  const deleteMany = React.useCallback(async ({ model, documentIds, params }) => {
    try {
      trackUsage("willBulkDeleteEntries");
      const res = await deleteManyDocuments({
        model,
        documentIds,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        title: formatMessage({
          id: getTranslation("success.records.delete"),
          defaultMessage: "Successfully deleted."
        }),
        message: ""
      });
      trackUsage("didBulkDeleteEntries");
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotBulkDeleteEntries");
      throw err;
    }
  }, [
    trackUsage,
    deleteManyDocuments,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [discardDocument] = useDiscardDocumentMutation();
  const discard = React.useCallback(async ({ collectionType, model, documentId, params }) => {
    try {
      const res = await discardDocument({
        collectionType,
        model,
        documentId,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: "content-manager.success.record.discard",
          defaultMessage: "Changes discarded"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    discardDocument,
    formatAPIError,
    formatMessage,
    toggleNotification
  ]);
  const [publishDocument] = usePublishDocumentMutation();
  const publish = React.useCallback(async ({ collectionType, model, documentId, params }, data) => {
    try {
      trackUsage("willPublishEntry");
      const res = await publishDocument({
        collectionType,
        model,
        documentId,
        data,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      trackUsage("didPublishEntry");
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.publish"),
          defaultMessage: "Published document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    trackUsage,
    publishDocument,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [publishManyDocuments] = usePublishManyDocumentsMutation();
  const publishMany = React.useCallback(async ({ model, documentIds, params }) => {
    try {
      const res = await publishManyDocuments({
        model,
        documentIds,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.publish"),
          defaultMessage: "Published document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    // trackUsage,
    publishManyDocuments,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [updateDocument] = useUpdateDocumentMutation();
  const update = React.useCallback(async ({ collectionType, model, documentId, params }, data, trackerProperty) => {
    try {
      trackUsage("willEditEntry", trackerProperty);
      const res = await updateDocument({
        collectionType,
        model,
        documentId,
        data,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        trackUsage("didNotEditEntry", {
          error: res.error,
          ...trackerProperty
        });
        return {
          error: res.error
        };
      }
      trackUsage("didEditEntry", trackerProperty);
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.save"),
          defaultMessage: "Saved document"
        })
      });
      return res.data;
    } catch (err) {
      trackUsage("didNotEditEntry", {
        error: err,
        ...trackerProperty
      });
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    trackUsage,
    updateDocument,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [unpublishDocument] = useUnpublishDocumentMutation();
  const unpublish = React.useCallback(async ({ collectionType, model, documentId, params }, discardDraft = false) => {
    try {
      trackUsage("willUnpublishEntry");
      const res = await unpublishDocument({
        collectionType,
        model,
        documentId,
        params,
        data: {
          discardDraft
        }
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      trackUsage("didUnpublishEntry");
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.unpublish"),
          defaultMessage: "Unpublished document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    trackUsage,
    unpublishDocument,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [unpublishManyDocuments] = useUnpublishManyDocumentsMutation();
  const unpublishMany = React.useCallback(async ({ model, documentIds, params }) => {
    try {
      trackUsage("willBulkUnpublishEntries");
      const res = await unpublishManyDocuments({
        model,
        documentIds,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return {
          error: res.error
        };
      }
      trackUsage("didBulkUnpublishEntries");
      toggleNotification({
        type: "success",
        title: formatMessage({
          id: getTranslation("success.records.unpublish"),
          defaultMessage: "Successfully unpublished."
        }),
        message: ""
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotBulkUnpublishEntries");
      throw err;
    }
  }, [
    trackUsage,
    unpublishManyDocuments,
    toggleNotification,
    formatMessage,
    formatAPIError
  ]);
  const [createDocument] = useCreateDocumentMutation();
  const create8 = React.useCallback(async ({ model, params }, data, trackerProperty) => {
    try {
      const res = await createDocument({
        model,
        data,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        trackUsage("didNotCreateEntry", {
          error: res.error,
          ...trackerProperty
        });
        return {
          error: res.error
        };
      }
      trackUsage("didCreateEntry", trackerProperty);
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.save"),
          defaultMessage: "Saved document"
        })
      });
      setCurrentStep("contentManager.success");
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotCreateEntry", {
        error: err,
        ...trackerProperty
      });
      throw err;
    }
  }, [
    createDocument,
    formatAPIError,
    formatMessage,
    toggleNotification,
    trackUsage
  ]);
  const [autoCloneDocument] = useAutoCloneDocumentMutation();
  const autoClone = React.useCallback(async ({ model, sourceId }) => {
    try {
      const res = await autoCloneDocument({
        model,
        sourceId
      });
      if ("error" in res) {
        return {
          error: res.error
        };
      }
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.clone"),
          defaultMessage: "Cloned document"
        })
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      throw err;
    }
  }, [
    autoCloneDocument,
    formatMessage,
    toggleNotification
  ]);
  const [cloneDocument] = useCloneDocumentMutation();
  const clone = React.useCallback(async ({ model, documentId, params }, body, trackerProperty) => {
    try {
      const { id: _id, ...restBody } = body;
      const res = await cloneDocument({
        model,
        sourceId: documentId,
        data: restBody,
        params
      });
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        trackUsage("didNotCreateEntry", {
          error: res.error,
          ...trackerProperty
        });
        return {
          error: res.error
        };
      }
      trackUsage("didCreateEntry", trackerProperty);
      toggleNotification({
        type: "success",
        message: formatMessage({
          id: getTranslation("success.record.clone"),
          defaultMessage: "Cloned document"
        })
      });
      navigate(`../../${res.data.data.documentId}`, {
        relative: "path"
      });
      return res.data;
    } catch (err) {
      toggleNotification({
        type: "danger",
        message: formatMessage(DEFAULT_UNEXPECTED_ERROR_MSG)
      });
      trackUsage("didNotCreateEntry", {
        error: err,
        ...trackerProperty
      });
      throw err;
    }
  }, [
    cloneDocument,
    trackUsage,
    toggleNotification,
    formatMessage,
    formatAPIError,
    navigate
  ]);
  const [getDoc] = useLazyGetDocumentQuery();
  const getDocument = React.useCallback(async (args) => {
    const { data } = await getDoc(args);
    return data;
  }, [
    getDoc
  ]);
  return {
    autoClone,
    clone,
    create: create8,
    delete: _delete,
    deleteMany,
    discard,
    getDocument,
    publish,
    publishMany,
    unpublish,
    unpublishMany,
    update
  };
};
var ProtectedHistoryPage = React.lazy(() => import("./History-C333pgXF-TBKEBRTE.js").then((mod) => ({
  default: mod.ProtectedHistoryPage
})));
var routes$2 = [
  {
    path: ":collectionType/:slug/:id/history",
    Component: ProtectedHistoryPage
  },
  {
    path: ":collectionType/:slug/history",
    Component: ProtectedHistoryPage
  }
];
var ProtectedPreviewPage = React.lazy(() => import("./Preview-BEq0FXda-55OTWXLU.js").then((mod) => ({
  default: mod.ProtectedPreviewPage
})));
var routes$1 = [
  {
    path: ":collectionType/:slug/:id/preview",
    Component: ProtectedPreviewPage
  },
  {
    path: ":collectionType/:slug/preview",
    Component: ProtectedPreviewPage
  }
];
var ProtectedEditViewPage = (0, import_react.lazy)(() => import("./EditViewPage-CYe7wAXF-TTT6MZ3Y.js").then((mod) => ({
  default: mod.ProtectedEditViewPage
})));
var ProtectedListViewPage = (0, import_react.lazy)(() => import("./ListViewPage-BDeT3Dkk-435GRNHF.js").then((mod) => ({
  default: mod.ProtectedListViewPage
})));
var ProtectedListConfiguration = (0, import_react.lazy)(() => import("./ListConfigurationPage-BX2WR7MI-H53WAHNZ.js").then((mod) => ({
  default: mod.ProtectedListConfiguration
})));
var ProtectedEditConfigurationPage = (0, import_react.lazy)(() => import("./EditConfigurationPage-tMgOELQG-3NFRXLEN.js").then((mod) => ({
  default: mod.ProtectedEditConfigurationPage
})));
var ProtectedComponentConfigurationPage = (0, import_react.lazy)(() => import("./ComponentConfigurationPage-BN2kOtDm-LGFWEKLM.js").then((mod) => ({
  default: mod.ProtectedComponentConfigurationPage
})));
var NoPermissions = (0, import_react.lazy)(() => import("./NoPermissionsPage-DTe9I47q-OCKQBMIF.js").then((mod) => ({
  default: mod.NoPermissions
})));
var NoContentType = (0, import_react.lazy)(() => import("./NoContentTypePage-9JHYpYVX-PSMXGV3G.js").then((mod) => ({
  default: mod.NoContentType
})));
var CollectionTypePages = () => {
  const { collectionType } = useParams();
  if (collectionType !== COLLECTION_TYPES && collectionType !== SINGLE_TYPES) {
    return (0, import_jsx_runtime.jsx)(Navigate, {
      to: "/404"
    });
  }
  return collectionType === COLLECTION_TYPES ? (0, import_jsx_runtime.jsx)(ProtectedListViewPage, {}) : (0, import_jsx_runtime.jsx)(ProtectedEditViewPage, {});
};
var CLONE_RELATIVE_PATH = ":collectionType/:slug/clone/:origin";
var CLONE_PATH = `/content-manager/${CLONE_RELATIVE_PATH}`;
var LIST_RELATIVE_PATH = ":collectionType/:slug";
var LIST_PATH = `/content-manager/collection-types/:slug`;
var routes = [
  {
    path: LIST_RELATIVE_PATH,
    element: (0, import_jsx_runtime.jsx)(CollectionTypePages, {})
  },
  {
    path: ":collectionType/:slug/:id",
    Component: ProtectedEditViewPage
  },
  {
    path: CLONE_RELATIVE_PATH,
    Component: ProtectedEditViewPage
  },
  {
    path: ":collectionType/:slug/configurations/list",
    Component: ProtectedListConfiguration
  },
  {
    path: "components/:slug/configurations/edit",
    Component: ProtectedComponentConfigurationPage
  },
  {
    path: ":collectionType/:slug/configurations/edit",
    Component: ProtectedEditConfigurationPage
  },
  {
    path: "403",
    Component: NoPermissions
  },
  {
    path: "no-content-types",
    Component: NoContentType
  },
  ...routes$2,
  ...routes$1
];
var DocumentActions = ({ actions: actions2 }) => {
  const { formatMessage } = useIntl();
  const [primaryAction, secondaryAction, ...restActions] = actions2.filter((action) => {
    if (action.position === void 0) {
      return true;
    }
    const positions = Array.isArray(action.position) ? action.position : [
      action.position
    ];
    return positions.includes("panel");
  });
  if (!primaryAction) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(Flex, {
    direction: "column",
    gap: 2,
    alignItems: "stretch",
    width: "100%",
    children: [
      (0, import_jsx_runtime.jsxs)(Flex, {
        gap: 2,
        children: [
          (0, import_jsx_runtime.jsx)(DocumentActionButton, {
            ...primaryAction,
            variant: primaryAction.variant || "default"
          }),
          restActions.length > 0 ? (0, import_jsx_runtime.jsx)(DocumentActionsMenu, {
            actions: restActions,
            label: formatMessage({
              id: "content-manager.containers.edit.panels.default.more-actions",
              defaultMessage: "More document actions"
            })
          }) : null
        ]
      }),
      secondaryAction ? (0, import_jsx_runtime.jsx)(DocumentActionButton, {
        ...secondaryAction,
        variant: secondaryAction.variant || "secondary"
      }) : null
    ]
  });
};
var DocumentActionButton = (action) => {
  var _a, _b, _c;
  const [dialogId, setDialogId] = React.useState(null);
  const { toggleNotification } = useNotification();
  const handleClick = (action2) => async (e) => {
    const { onClick = () => false, dialog, id } = action2;
    const muteDialog = await onClick(e);
    if (dialog && !muteDialog) {
      switch (dialog.type) {
        case "notification":
          toggleNotification({
            title: dialog.title,
            message: dialog.content,
            type: dialog.status,
            timeout: dialog.timeout,
            onClose: dialog.onClose
          });
          break;
        case "dialog":
        case "modal":
          e.preventDefault();
          setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [
      (0, import_jsx_runtime.jsx)(Button, {
        flex: "auto",
        startIcon: action.icon,
        disabled: action.disabled,
        onClick: handleClick(action),
        justifyContent: "center",
        variant: action.variant || "default",
        paddingTop: "7px",
        paddingBottom: "7px",
        children: action.label
      }),
      ((_a = action.dialog) == null ? void 0 : _a.type) === "dialog" ? (0, import_jsx_runtime.jsx)(DocumentActionConfirmDialog, {
        ...action.dialog,
        variant: ((_b = action.dialog) == null ? void 0 : _b.variant) ?? action.variant,
        isOpen: dialogId === action.id,
        onClose: handleClose
      }) : null,
      ((_c = action.dialog) == null ? void 0 : _c.type) === "modal" ? (0, import_jsx_runtime.jsx)(DocumentActionModal, {
        ...action.dialog,
        onModalClose: handleClose,
        isOpen: dialogId === action.id
      }) : null
    ]
  });
};
var MenuItem = dt(Menu.Item)`
  &:hover {
    background: ${({ theme, isVariantDanger, isDisabled }) => isVariantDanger && !isDisabled ? theme.colors.danger100 : "neutral"};
  }
`;
var DocumentActionsMenu = ({ actions: actions2, children, label, variant = "tertiary" }) => {
  const [isOpen, setIsOpen] = React.useState(false);
  const [dialogId, setDialogId] = React.useState(null);
  const { formatMessage } = useIntl();
  const { toggleNotification } = useNotification();
  const isDisabled = actions2.every((action) => action.disabled) || actions2.length === 0;
  const handleClick = (action) => async (e) => {
    const { onClick = () => false, dialog, id } = action;
    const muteDialog = await onClick(e);
    if (dialog && !muteDialog) {
      switch (dialog.type) {
        case "notification":
          toggleNotification({
            title: dialog.title,
            message: dialog.content,
            type: dialog.status,
            timeout: dialog.timeout,
            onClose: dialog.onClose
          });
          break;
        case "dialog":
        case "modal":
          setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
    setIsOpen(false);
  };
  return (0, import_jsx_runtime.jsxs)(Menu.Root, {
    open: isOpen,
    onOpenChange: setIsOpen,
    children: [
      (0, import_jsx_runtime.jsxs)(Menu.Trigger, {
        disabled: isDisabled,
        size: "S",
        endIcon: null,
        paddingTop: "4px",
        paddingLeft: "7px",
        paddingRight: "7px",
        variant,
        children: [
          (0, import_jsx_runtime.jsx)(ForwardRef$1R, {
            "aria-hidden": true,
            focusable: false
          }),
          (0, import_jsx_runtime.jsx)(VisuallyHidden, {
            tag: "span",
            children: label || formatMessage({
              id: "content-manager.containers.edit.panels.default.more-actions",
              defaultMessage: "More document actions"
            })
          })
        ]
      }),
      (0, import_jsx_runtime.jsxs)(Menu.Content, {
        maxHeight: void 0,
        popoverPlacement: "bottom-end",
        children: [
          actions2.map((action) => {
            return (0, import_jsx_runtime.jsx)(MenuItem, {
              disabled: action.disabled,
              /* @ts-expect-error – TODO: this is an error in the DS where it is most likely a synthetic event, not regular. */
              onSelect: handleClick(action),
              display: "block",
              isVariantDanger: action.variant === "danger",
              isDisabled: action.disabled,
              children: (0, import_jsx_runtime.jsx)(Flex, {
                justifyContent: "space-between",
                gap: 4,
                children: (0, import_jsx_runtime.jsxs)(Flex, {
                  color: !action.disabled ? convertActionVariantToColor(action.variant) : "inherit",
                  gap: 2,
                  tag: "span",
                  children: [
                    (0, import_jsx_runtime.jsx)(Flex, {
                      tag: "span",
                      color: !action.disabled ? convertActionVariantToIconColor(action.variant) : "inherit",
                      children: action.icon
                    }),
                    action.label
                  ]
                })
              })
            }, action.id);
          }),
          children
        ]
      }),
      actions2.map((action) => {
        var _a, _b;
        return (0, import_jsx_runtime.jsxs)(React.Fragment, {
          children: [
            ((_a = action.dialog) == null ? void 0 : _a.type) === "dialog" ? (0, import_jsx_runtime.jsx)(DocumentActionConfirmDialog, {
              ...action.dialog,
              variant: action.variant,
              isOpen: dialogId === action.id,
              onClose: handleClose
            }) : null,
            ((_b = action.dialog) == null ? void 0 : _b.type) === "modal" ? (0, import_jsx_runtime.jsx)(DocumentActionModal, {
              ...action.dialog,
              onModalClose: handleClose,
              isOpen: dialogId === action.id
            }) : null
          ]
        }, action.id);
      })
    ]
  });
};
var convertActionVariantToColor = (variant = "secondary") => {
  switch (variant) {
    case "danger":
      return "danger600";
    case "secondary":
      return void 0;
    case "success":
      return "success600";
    default:
      return "primary600";
  }
};
var convertActionVariantToIconColor = (variant = "secondary") => {
  switch (variant) {
    case "danger":
      return "danger600";
    case "secondary":
      return "neutral500";
    case "success":
      return "success600";
    default:
      return "primary600";
  }
};
var DocumentActionConfirmDialog = ({ onClose, onCancel, onConfirm, title, content, isOpen, variant = "secondary" }) => {
  const { formatMessage } = useIntl();
  const handleClose = async () => {
    if (onCancel) {
      await onCancel();
    }
    onClose();
  };
  const handleConfirm = async () => {
    if (onConfirm) {
      await onConfirm();
    }
    onClose();
  };
  return (0, import_jsx_runtime.jsx)(Dialog.Root, {
    open: isOpen,
    onOpenChange: handleClose,
    children: (0, import_jsx_runtime.jsxs)(Dialog.Content, {
      children: [
        (0, import_jsx_runtime.jsx)(Dialog.Header, {
          children: title
        }),
        (0, import_jsx_runtime.jsx)(Dialog.Body, {
          children: content
        }),
        (0, import_jsx_runtime.jsxs)(Dialog.Footer, {
          children: [
            (0, import_jsx_runtime.jsx)(Dialog.Cancel, {
              children: (0, import_jsx_runtime.jsx)(Button, {
                variant: "tertiary",
                fullWidth: true,
                children: formatMessage({
                  id: "app.components.Button.cancel",
                  defaultMessage: "Cancel"
                })
              })
            }),
            (0, import_jsx_runtime.jsx)(Button, {
              onClick: handleConfirm,
              variant,
              fullWidth: true,
              children: formatMessage({
                id: "app.components.Button.confirm",
                defaultMessage: "Confirm"
              })
            })
          ]
        })
      ]
    })
  });
};
var DocumentActionModal = ({ isOpen, title, onClose, footer: Footer, content: Content, onModalClose }) => {
  const handleClose = () => {
    if (onClose) {
      onClose();
    }
    onModalClose();
  };
  return (0, import_jsx_runtime.jsx)(Modal.Root, {
    open: isOpen,
    onOpenChange: handleClose,
    children: (0, import_jsx_runtime.jsxs)(Modal.Content, {
      children: [
        (0, import_jsx_runtime.jsx)(Modal.Header, {
          children: (0, import_jsx_runtime.jsx)(Modal.Title, {
            children: title
          })
        }),
        typeof Content === "function" ? (0, import_jsx_runtime.jsx)(Content, {
          onClose: handleClose
        }) : (0, import_jsx_runtime.jsx)(Modal.Body, {
          children: Content
        }),
        typeof Footer === "function" ? (0, import_jsx_runtime.jsx)(Footer, {
          onClose: handleClose
        }) : Footer
      ]
    })
  });
};
var transformData = (data) => {
  if (Array.isArray(data)) {
    return data.map(transformData);
  }
  if (typeof data === "object" && data !== null) {
    if ("apiData" in data) {
      return data.apiData;
    }
    return (0, import_mapValues.default)(transformData)(data);
  }
  return data;
};
var PublishAction$1 = ({ activeTab, documentId, model, collectionType, meta, document: document2 }) => {
  var _a;
  const { schema } = useDoc();
  const navigate = useNavigate();
  const { toggleNotification } = useNotification();
  const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
  const isListView = useMatch(LIST_PATH) !== null;
  const isCloning = useMatch(CLONE_PATH) !== null;
  const { id } = useParams();
  const { formatMessage } = useIntl();
  const canPublish = useDocumentRBAC("PublishAction", ({ canPublish: canPublish2 }) => canPublish2);
  const { publish } = useDocumentActions();
  const [countDraftRelations, { isLoading: isLoadingDraftRelations, isError: isErrorDraftRelations }] = useLazyGetDraftRelationCountQuery();
  const [localCountOfDraftRelations, setLocalCountOfDraftRelations] = React.useState(0);
  const [serverCountOfDraftRelations, setServerCountOfDraftRelations] = React.useState(0);
  const [{ query, rawQuery }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  const modified = useForm("PublishAction", ({ modified: modified2 }) => modified2);
  const setSubmitting = useForm("PublishAction", ({ setSubmitting: setSubmitting2 }) => setSubmitting2);
  const isSubmitting = useForm("PublishAction", ({ isSubmitting: isSubmitting2 }) => isSubmitting2);
  const validate = useForm("PublishAction", (state) => state.validate);
  const setErrors = useForm("PublishAction", (state) => state.setErrors);
  const formValues = useForm("PublishAction", ({ values }) => values);
  React.useEffect(() => {
    if (isErrorDraftRelations) {
      toggleNotification({
        type: "danger",
        message: formatMessage({
          id: getTranslation("error.records.fetch-draft-relatons"),
          defaultMessage: "An error occurred while fetching draft relations on this document."
        })
      });
    }
  }, [
    isErrorDraftRelations,
    toggleNotification,
    formatMessage
  ]);
  React.useEffect(() => {
    const localDraftRelations = /* @__PURE__ */ new Set();
    const extractDraftRelations = (data) => {
      const relations = data.connect || [];
      relations.forEach((relation) => {
        if (relation.status === "draft") {
          localDraftRelations.add(relation.id);
        }
      });
    };
    const traverseAndExtract = (data) => {
      Object.entries(data).forEach(([key, value]) => {
        if (key === "connect" && Array.isArray(value)) {
          extractDraftRelations({
            connect: value
          });
        } else if (typeof value === "object" && value !== null) {
          traverseAndExtract(value);
        }
      });
    };
    if (!documentId || modified) {
      traverseAndExtract(formValues);
      setLocalCountOfDraftRelations(localDraftRelations.size);
    }
  }, [
    documentId,
    modified,
    formValues,
    setLocalCountOfDraftRelations
  ]);
  React.useEffect(() => {
    if (!document2 || !document2.documentId || isListView) {
      return;
    }
    const fetchDraftRelationsCount = async () => {
      const { data, error } = await countDraftRelations({
        collectionType,
        model,
        documentId,
        params
      });
      if (error) {
        throw error;
      }
      if (data) {
        setServerCountOfDraftRelations(data.data);
      }
    };
    fetchDraftRelationsCount();
  }, [
    isListView,
    document2,
    documentId,
    countDraftRelations,
    collectionType,
    model,
    params
  ]);
  const isDocumentPublished = ((document2 == null ? void 0 : document2[PUBLISHED_AT_ATTRIBUTE_NAME]) || (meta == null ? void 0 : meta.availableStatus.some((doc) => doc[PUBLISHED_AT_ATTRIBUTE_NAME] !== null))) && (document2 == null ? void 0 : document2.status) !== "modified";
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  const performPublish = async () => {
    setSubmitting(true);
    try {
      const { errors } = await validate(true, {
        status: "published"
      });
      if (errors) {
        toggleNotification({
          type: "danger",
          message: formatMessage({
            id: "content-manager.validation.error",
            defaultMessage: "There are validation errors in your document. Please fix them before saving."
          })
        });
        return;
      }
      const res = await publish({
        collectionType,
        model,
        documentId,
        params
      }, transformData(formValues));
      if ("data" in res && collectionType !== SINGLE_TYPES) {
        if (id === "create") {
          navigate({
            pathname: `../${collectionType}/${model}/${res.data.documentId}`,
            search: rawQuery
          });
        }
      } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
        setErrors(formatValidationErrors(res.error));
      }
    } finally {
      setSubmitting(false);
    }
  };
  const totalDraftRelations = localCountOfDraftRelations + serverCountOfDraftRelations;
  const enableDraftRelationsCount = false;
  const hasDraftRelations = enableDraftRelationsCount;
  return {
    /**
    * Disabled when:
    *  - currently if you're cloning a document we don't support publish & clone at the same time.
    *  - the form is submitting
    *  - the active tab is the published tab
    *  - the document is already published & not modified
    *  - the document is being created & not modified
    *  - the user doesn't have the permission to publish
    */
    disabled: isCloning || isSubmitting || isLoadingDraftRelations || activeTab === "published" || !modified && isDocumentPublished || !modified && !(document2 == null ? void 0 : document2.documentId) || !canPublish,
    label: formatMessage({
      id: "app.utils.publish",
      defaultMessage: "Publish"
    }),
    onClick: async () => {
      await performPublish();
    },
    dialog: hasDraftRelations ? {
      type: "dialog",
      variant: "danger",
      footer: null,
      title: formatMessage({
        id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.title`),
        defaultMessage: "Confirmation"
      }),
      content: formatMessage({
        id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
        defaultMessage: "This entry is related to {count, plural, one {# draft entry} other {# draft entries}}. Publishing it could leave broken links in your app."
      }, {
        count: totalDraftRelations
      }),
      onConfirm: async () => {
        await performPublish();
      }
    } : void 0
  };
};
PublishAction$1.type = "publish";
PublishAction$1.position = "panel";
var UpdateAction = ({ activeTab, documentId, model, collectionType }) => {
  const navigate = useNavigate();
  const { toggleNotification } = useNotification();
  const { _unstableFormatValidationErrors: formatValidationErrors } = useAPIErrorHandler();
  const cloneMatch = useMatch(CLONE_PATH);
  const isCloning = cloneMatch !== null;
  const { formatMessage } = useIntl();
  const { create: create8, update, clone } = useDocumentActions();
  const [{ query, rawQuery }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  const isSubmitting = useForm("UpdateAction", ({ isSubmitting: isSubmitting2 }) => isSubmitting2);
  const modified = useForm("UpdateAction", ({ modified: modified2 }) => modified2);
  const setSubmitting = useForm("UpdateAction", ({ setSubmitting: setSubmitting2 }) => setSubmitting2);
  const document2 = useForm("UpdateAction", ({ values }) => values);
  const validate = useForm("UpdateAction", (state) => state.validate);
  const setErrors = useForm("UpdateAction", (state) => state.setErrors);
  const resetForm = useForm("PublishAction", ({ resetForm: resetForm2 }) => resetForm2);
  const handleUpdate = React.useCallback(async () => {
    setSubmitting(true);
    try {
      if (!modified) {
        return;
      }
      const { errors } = await validate(true, {
        status: "draft"
      });
      if (errors) {
        toggleNotification({
          type: "danger",
          message: formatMessage({
            id: "content-manager.validation.error",
            defaultMessage: "There are validation errors in your document. Please fix them before saving."
          })
        });
        return;
      }
      if (isCloning) {
        const res = await clone({
          model,
          documentId: cloneMatch.params.origin,
          params
        }, transformData(document2));
        if ("data" in res) {
          navigate({
            pathname: `../${res.data.documentId}`,
            search: rawQuery
          }, {
            relative: "path"
          });
        } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        }
      } else if (documentId || collectionType === SINGLE_TYPES) {
        const res = await update({
          collectionType,
          model,
          documentId,
          params
        }, transformData(document2));
        if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        } else {
          resetForm();
        }
      } else {
        const res = await create8({
          model,
          params
        }, transformData(document2));
        if ("data" in res && collectionType !== SINGLE_TYPES) {
          navigate({
            pathname: `../${res.data.documentId}`,
            search: rawQuery
          }, {
            replace: true,
            relative: "path"
          });
        } else if ("error" in res && isBaseQueryError(res.error) && res.error.name === "ValidationError") {
          setErrors(formatValidationErrors(res.error));
        }
      }
    } finally {
      setSubmitting(false);
    }
  }, [
    clone,
    cloneMatch == null ? void 0 : cloneMatch.params.origin,
    collectionType,
    create8,
    document2,
    documentId,
    formatMessage,
    formatValidationErrors,
    isCloning,
    model,
    modified,
    navigate,
    params,
    rawQuery,
    resetForm,
    setErrors,
    setSubmitting,
    toggleNotification,
    update,
    validate
  ]);
  React.useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        handleUpdate();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [
    handleUpdate
  ]);
  return {
    /**
    * Disabled when:
    * - the form is submitting
    * - the document is not modified & we're not cloning (you can save a clone entity straight away)
    * - the active tab is the published tab
    */
    disabled: isSubmitting || !modified && !isCloning || activeTab === "published",
    label: formatMessage({
      id: "global.save",
      defaultMessage: "Save"
    }),
    onClick: handleUpdate
  };
};
UpdateAction.type = "update";
UpdateAction.position = "panel";
var UNPUBLISH_DRAFT_OPTIONS = {
  KEEP: "keep",
  DISCARD: "discard"
};
var UnpublishAction$1 = ({ activeTab, documentId, model, collectionType, document: document2 }) => {
  var _a;
  const { formatMessage } = useIntl();
  const { schema } = useDoc();
  const canPublish = useDocumentRBAC("UnpublishAction", ({ canPublish: canPublish2 }) => canPublish2);
  const { unpublish } = useDocumentActions();
  const [{ query }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  const { toggleNotification } = useNotification();
  const [shouldKeepDraft, setShouldKeepDraft] = React.useState(true);
  const isDocumentModified = (document2 == null ? void 0 : document2.status) === "modified";
  const handleChange = (value) => {
    setShouldKeepDraft(value === UNPUBLISH_DRAFT_OPTIONS.KEEP);
  };
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  return {
    disabled: !canPublish || activeTab === "published" || (document2 == null ? void 0 : document2.status) !== "published" && (document2 == null ? void 0 : document2.status) !== "modified",
    label: formatMessage({
      id: "app.utils.unpublish",
      defaultMessage: "Unpublish"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$3$, {}),
    onClick: async () => {
      if (!documentId && collectionType !== SINGLE_TYPES || isDocumentModified) {
        if (!documentId) {
          console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
          toggleNotification({
            message: formatMessage({
              id: "content-manager.actions.unpublish.error",
              defaultMessage: "An error occurred while trying to unpublish the document."
            }),
            type: "danger"
          });
        }
        return;
      }
      await unpublish({
        collectionType,
        model,
        documentId,
        params
      });
    },
    dialog: isDocumentModified ? {
      type: "dialog",
      title: formatMessage({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, {
        alignItems: "flex-start",
        direction: "column",
        gap: 6,
        children: [
          (0, import_jsx_runtime.jsxs)(Flex, {
            width: "100%",
            direction: "column",
            gap: 2,
            children: [
              (0, import_jsx_runtime.jsx)(ForwardRef$3, {
                width: "24px",
                height: "24px",
                fill: "danger600"
              }),
              (0, import_jsx_runtime.jsx)(Typography, {
                tag: "p",
                variant: "omega",
                textAlign: "center",
                children: formatMessage({
                  id: "content-manager.actions.unpublish.dialog.body",
                  defaultMessage: "Are you sure?"
                })
              })
            ]
          }),
          (0, import_jsx_runtime.jsxs)(Radio.Group, {
            defaultValue: UNPUBLISH_DRAFT_OPTIONS.KEEP,
            name: "discard-options",
            "aria-label": formatMessage({
              id: "content-manager.actions.unpublish.dialog.radio-label",
              defaultMessage: "Choose an option to unpublish the document."
            }),
            onValueChange: handleChange,
            children: [
              (0, import_jsx_runtime.jsx)(Radio.Item, {
                checked: shouldKeepDraft,
                value: UNPUBLISH_DRAFT_OPTIONS.KEEP,
                children: formatMessage({
                  id: "content-manager.actions.unpublish.dialog.option.keep-draft",
                  defaultMessage: "Keep draft"
                })
              }),
              (0, import_jsx_runtime.jsx)(Radio.Item, {
                checked: !shouldKeepDraft,
                value: UNPUBLISH_DRAFT_OPTIONS.DISCARD,
                children: formatMessage({
                  id: "content-manager.actions.unpublish.dialog.option.replace-draft",
                  defaultMessage: "Replace draft"
                })
              })
            ]
          })
        ]
      }),
      onConfirm: async () => {
        if (!documentId && collectionType !== SINGLE_TYPES) {
          console.error("You're trying to unpublish a document without an id, this is likely a bug with Strapi. Please open an issue.");
          toggleNotification({
            message: formatMessage({
              id: "content-manager.actions.unpublish.error",
              defaultMessage: "An error occurred while trying to unpublish the document."
            }),
            type: "danger"
          });
        }
        await unpublish({
          collectionType,
          model,
          documentId,
          params
        }, !shouldKeepDraft);
      }
    } : void 0,
    variant: "danger",
    position: [
      "panel",
      "table-row"
    ]
  };
};
UnpublishAction$1.type = "unpublish";
UnpublishAction$1.position = "panel";
var DiscardAction = ({ activeTab, documentId, model, collectionType, document: document2 }) => {
  var _a;
  const { formatMessage } = useIntl();
  const { schema } = useDoc();
  const canUpdate = useDocumentRBAC("DiscardAction", ({ canUpdate: canUpdate2 }) => canUpdate2);
  const { discard } = useDocumentActions();
  const [{ query }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  if (!((_a = schema == null ? void 0 : schema.options) == null ? void 0 : _a.draftAndPublish)) {
    return null;
  }
  return {
    disabled: !canUpdate || activeTab === "published" || (document2 == null ? void 0 : document2.status) !== "modified",
    label: formatMessage({
      id: "content-manager.actions.discard.label",
      defaultMessage: "Discard changes"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$3$, {}),
    position: [
      "panel",
      "table-row"
    ],
    variant: "danger",
    dialog: {
      type: "dialog",
      title: formatMessage({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, {
        direction: "column",
        gap: 2,
        children: [
          (0, import_jsx_runtime.jsx)(ForwardRef$3, {
            width: "24px",
            height: "24px",
            fill: "danger600"
          }),
          (0, import_jsx_runtime.jsx)(Typography, {
            tag: "p",
            variant: "omega",
            textAlign: "center",
            children: formatMessage({
              id: "content-manager.actions.discard.dialog.body",
              defaultMessage: "Are you sure?"
            })
          })
        ]
      }),
      onConfirm: async () => {
        await discard({
          collectionType,
          model,
          documentId,
          params
        });
      }
    }
  };
};
DiscardAction.type = "discard";
DiscardAction.position = "panel";
var DEFAULT_ACTIONS = [
  PublishAction$1,
  UpdateAction,
  UnpublishAction$1,
  DiscardAction
];
var intervals = [
  "years",
  "months",
  "days",
  "hours",
  "minutes",
  "seconds"
];
var RelativeTime = React.forwardRef(({ timestamp, customIntervals = [], ...restProps }, forwardedRef) => {
  const { formatRelativeTime, formatDate, formatTime } = useIntl();
  const interval = intervalToDuration({
    start: timestamp,
    end: Date.now()
  });
  const unit = intervals.find((intervalUnit) => {
    return interval[intervalUnit] > 0 && Object.keys(interval).includes(intervalUnit);
  }) ?? "seconds";
  const relativeTime = isPast(timestamp) ? -interval[unit] : interval[unit];
  const customInterval = customIntervals.find((custom) => interval[custom.unit] < custom.threshold);
  const displayText = customInterval ? customInterval.text : formatRelativeTime(relativeTime, unit, {
    numeric: "auto"
  });
  return (0, import_jsx_runtime.jsx)("time", {
    ref: forwardedRef,
    dateTime: timestamp.toISOString(),
    role: "time",
    title: `${formatDate(timestamp)} ${formatTime(timestamp)}`,
    ...restProps,
    children: displayText
  });
});
var getDisplayName = ({ firstname, lastname, username, email } = {}) => {
  if (username) {
    return username;
  }
  if (firstname) {
    return `${firstname} ${lastname ?? ""}`.trim();
  }
  return email ?? "";
};
var capitalise = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var DocumentStatus = ({ status = "draft", size = "S", ...restProps }) => {
  const statusVariant = status === "draft" ? "secondary" : status === "published" ? "success" : "alternative";
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsx)(Status, {
    ...restProps,
    size,
    variant: statusVariant,
    children: (0, import_jsx_runtime.jsx)(Typography, {
      tag: "span",
      variant: "omega",
      fontWeight: "bold",
      children: formatMessage({
        id: `content-manager.containers.List.${status}`,
        defaultMessage: capitalise(status)
      })
    })
  });
};
var Header = ({ isCreating, status, title: documentTitle = "Untitled" }) => {
  const { formatMessage } = useIntl();
  const isCloning = useMatch(CLONE_PATH) !== null;
  const params = useParams();
  const title = isCreating ? formatMessage({
    id: "content-manager.containers.edit.title.new",
    defaultMessage: "Create an entry"
  }) : documentTitle;
  return (0, import_jsx_runtime.jsxs)(Flex, {
    direction: "column",
    alignItems: "flex-start",
    paddingTop: 6,
    paddingBottom: 4,
    gap: 2,
    children: [
      (0, import_jsx_runtime.jsx)(BackButton, {
        fallback: params.collectionType === SINGLE_TYPES ? void 0 : `../${COLLECTION_TYPES}/${params.slug}`
      }),
      (0, import_jsx_runtime.jsxs)(Flex, {
        width: "100%",
        justifyContent: "space-between",
        gap: "80px",
        alignItems: "flex-start",
        children: [
          (0, import_jsx_runtime.jsx)(Typography, {
            variant: "alpha",
            tag: "h1",
            children: title
          }),
          (0, import_jsx_runtime.jsx)(HeaderToolbar, {})
        ]
      }),
      status ? (0, import_jsx_runtime.jsx)(Box, {
        marginTop: 1,
        children: (0, import_jsx_runtime.jsx)(DocumentStatus, {
          status: isCloning ? "draft" : status
        })
      }) : null
    ]
  });
};
var HeaderToolbar = () => {
  const { formatMessage } = useIntl();
  const isCloning = useMatch(CLONE_PATH) !== null;
  const [{ query: { status = "draft" } }] = useQueryParams();
  const { model, id, document: document2, meta, collectionType } = useDoc();
  const plugins = useStrapiApp("HeaderToolbar", (state) => state.plugins);
  return (0, import_jsx_runtime.jsxs)(Flex, {
    gap: 2,
    children: [
      (0, import_jsx_runtime.jsx)(DescriptionComponentRenderer, {
        props: {
          activeTab: status,
          model,
          documentId: id,
          document: isCloning ? void 0 : document2,
          meta: isCloning ? void 0 : meta,
          collectionType
        },
        descriptions: plugins["content-manager"].apis.getHeaderActions(),
        children: (actions2) => {
          if (actions2.length > 0) {
            return (0, import_jsx_runtime.jsx)(HeaderActions, {
              actions: actions2
            });
          } else {
            return null;
          }
        }
      }),
      (0, import_jsx_runtime.jsx)(DescriptionComponentRenderer, {
        props: {
          activeTab: status,
          model,
          documentId: id,
          document: isCloning ? void 0 : document2,
          meta: isCloning ? void 0 : meta,
          collectionType
        },
        descriptions: plugins["content-manager"].apis.getDocumentActions("header"),
        children: (actions2) => {
          const headerActions = actions2.filter((action) => {
            const positions = Array.isArray(action.position) ? action.position : [
              action.position
            ];
            return positions.includes("header");
          });
          return (0, import_jsx_runtime.jsx)(DocumentActionsMenu, {
            actions: headerActions,
            label: formatMessage({
              id: "content-manager.containers.edit.header.more-actions",
              defaultMessage: "More actions"
            }),
            children: (0, import_jsx_runtime.jsx)(Information, {
              activeTab: status
            })
          });
        }
      })
    ]
  });
};
var Information = ({ activeTab }) => {
  const { formatMessage } = useIntl();
  const { document: document2, meta } = useDoc();
  if (!document2 || !document2.id) {
    return null;
  }
  const createAndUpdateDocument = activeTab === "draft" ? document2 : meta == null ? void 0 : meta.availableStatus.find((status) => status.publishedAt === null);
  const publishDocument = activeTab === "published" ? document2 : meta == null ? void 0 : meta.availableStatus.find((status) => status.publishedAt !== null);
  const creator = (createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[CREATED_BY_ATTRIBUTE_NAME]) ? getDisplayName(createAndUpdateDocument[CREATED_BY_ATTRIBUTE_NAME]) : null;
  const updator = (createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[UPDATED_BY_ATTRIBUTE_NAME]) ? getDisplayName(createAndUpdateDocument[UPDATED_BY_ATTRIBUTE_NAME]) : null;
  const information = [
    {
      isDisplayed: !!(publishDocument == null ? void 0 : publishDocument[PUBLISHED_AT_ATTRIBUTE_NAME]),
      label: formatMessage({
        id: "content-manager.containers.edit.information.last-published.label",
        defaultMessage: "Published"
      }),
      value: formatMessage({
        id: "content-manager.containers.edit.information.last-published.value",
        defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
      }, {
        time: (0, import_jsx_runtime.jsx)(RelativeTime, {
          timestamp: new Date(publishDocument == null ? void 0 : publishDocument[PUBLISHED_AT_ATTRIBUTE_NAME])
        }),
        isAnonymous: !(publishDocument == null ? void 0 : publishDocument[PUBLISHED_BY_ATTRIBUTE_NAME]),
        author: (publishDocument == null ? void 0 : publishDocument[PUBLISHED_BY_ATTRIBUTE_NAME]) ? getDisplayName(publishDocument == null ? void 0 : publishDocument[PUBLISHED_BY_ATTRIBUTE_NAME]) : null
      })
    },
    {
      isDisplayed: !!(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[UPDATED_AT_ATTRIBUTE_NAME]),
      label: formatMessage({
        id: "content-manager.containers.edit.information.last-draft.label",
        defaultMessage: "Updated"
      }),
      value: formatMessage({
        id: "content-manager.containers.edit.information.last-draft.value",
        defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
      }, {
        time: (0, import_jsx_runtime.jsx)(RelativeTime, {
          timestamp: new Date(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[UPDATED_AT_ATTRIBUTE_NAME])
        }),
        isAnonymous: !updator,
        author: updator
      })
    },
    {
      isDisplayed: !!(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[CREATED_AT_ATTRIBUTE_NAME]),
      label: formatMessage({
        id: "content-manager.containers.edit.information.document.label",
        defaultMessage: "Created"
      }),
      value: formatMessage({
        id: "content-manager.containers.edit.information.document.value",
        defaultMessage: `{time}{isAnonymous, select, true {} other { by {author}}}`
      }, {
        time: (0, import_jsx_runtime.jsx)(RelativeTime, {
          timestamp: new Date(createAndUpdateDocument == null ? void 0 : createAndUpdateDocument[CREATED_AT_ATTRIBUTE_NAME])
        }),
        isAnonymous: !creator,
        author: creator
      })
    }
  ].filter((info) => info.isDisplayed);
  return (0, import_jsx_runtime.jsx)(Flex, {
    borderWidth: "1px 0 0 0",
    borderStyle: "solid",
    borderColor: "neutral150",
    direction: "column",
    marginTop: 2,
    tag: "dl",
    padding: 5,
    gap: 3,
    alignItems: "flex-start",
    /**
    * The menu content has a padding of 4px, but we want our divider (the border top applied) to
    * be flush with the menu content. So we need to adjust the margin & width to account for the padding.
    */
    marginLeft: "-0.4rem",
    marginRight: "-0.4rem",
    width: "calc(100% + 8px)",
    children: information.map((info) => (0, import_jsx_runtime.jsxs)(Flex, {
      gap: 1,
      direction: "column",
      alignItems: "flex-start",
      children: [
        (0, import_jsx_runtime.jsx)(Typography, {
          tag: "dt",
          variant: "pi",
          fontWeight: "bold",
          children: info.label
        }),
        (0, import_jsx_runtime.jsx)(Typography, {
          tag: "dd",
          variant: "pi",
          textColor: "neutral600",
          children: info.value
        })
      ]
    }, info.label))
  });
};
var HeaderActions = ({ actions: actions2 }) => {
  const [dialogId, setDialogId] = React.useState(null);
  const handleClick = (action) => async (e) => {
    if (!("options" in action)) {
      const { onClick = () => false, dialog, id } = action;
      const muteDialog = await onClick(e);
      if (dialog && !muteDialog) {
        e.preventDefault();
        setDialogId(id);
      }
    }
  };
  const handleClose = () => {
    setDialogId(null);
  };
  return (0, import_jsx_runtime.jsx)(Flex, {
    gap: 1,
    children: actions2.map((action) => {
      if (action.options) {
        return (0, import_jsx_runtime.jsx)(SingleSelect, {
          size: "S",
          // @ts-expect-error – the DS will handle numbers, but we're not allowing the API.
          onChange: action.onSelect,
          "aria-label": action.label,
          ...action,
          children: action.options.map(({ label, ...option }) => (0, import_jsx_runtime.jsx)(SingleSelectOption, {
            ...option,
            children: label
          }, option.value))
        }, action.id);
      } else {
        if (action.type === "icon") {
          return (0, import_jsx_runtime.jsxs)(React.Fragment, {
            children: [
              (0, import_jsx_runtime.jsx)(IconButton, {
                disabled: action.disabled,
                label: action.label,
                size: "S",
                onClick: handleClick(action),
                children: action.icon
              }),
              action.dialog ? (0, import_jsx_runtime.jsx)(HeaderActionDialog, {
                ...action.dialog,
                isOpen: dialogId === action.id,
                onClose: handleClose
              }) : null
            ]
          }, action.id);
        }
      }
    })
  });
};
var HeaderActionDialog = ({ onClose, onCancel, title, content: Content, isOpen }) => {
  const handleClose = async () => {
    if (onCancel) {
      await onCancel();
    }
    onClose();
  };
  return (0, import_jsx_runtime.jsx)(Dialog.Root, {
    open: isOpen,
    onOpenChange: handleClose,
    children: (0, import_jsx_runtime.jsxs)(Dialog.Content, {
      children: [
        (0, import_jsx_runtime.jsx)(Dialog.Header, {
          children: title
        }),
        typeof Content === "function" ? (0, import_jsx_runtime.jsx)(Content, {
          onClose: handleClose
        }) : Content
      ]
    })
  });
};
var ConfigureTheViewAction = ({ collectionType, model }) => {
  const navigate = useNavigate();
  const { formatMessage } = useIntl();
  return {
    label: formatMessage({
      id: "app.links.configure-view",
      defaultMessage: "Configure the view"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$2h, {}),
    onClick: () => {
      navigate(`../${collectionType}/${model}/configurations/edit`);
    },
    position: "header"
  };
};
ConfigureTheViewAction.type = "configure-the-view";
ConfigureTheViewAction.position = "header";
var EditTheModelAction = ({ model }) => {
  const navigate = useNavigate();
  const { formatMessage } = useIntl();
  return {
    label: formatMessage({
      id: "content-manager.link-to-ctb",
      defaultMessage: "Edit the model"
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$1r, {}),
    onClick: () => {
      navigate(`/plugins/content-type-builder/content-types/${model}`);
    },
    position: "header"
  };
};
EditTheModelAction.type = "edit-the-model";
EditTheModelAction.position = "header";
var DeleteAction$1 = ({ documentId, model, collectionType, document: document2 }) => {
  const navigate = useNavigate();
  const { formatMessage } = useIntl();
  const listViewPathMatch = useMatch(LIST_PATH);
  const canDelete = useDocumentRBAC("DeleteAction", (state) => state.canDelete);
  const { delete: deleteAction } = useDocumentActions();
  const { toggleNotification } = useNotification();
  const setSubmitting = useForm("DeleteAction", (state) => state.setSubmitting);
  const isLocalized = (document2 == null ? void 0 : document2.locale) != null;
  return {
    disabled: !canDelete || !document2,
    label: formatMessage({
      id: "content-manager.actions.delete.label",
      defaultMessage: "Delete entry{isLocalized, select, true { (all locales)} other {}}"
    }, {
      isLocalized
    }),
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$j, {}),
    dialog: {
      type: "dialog",
      title: formatMessage({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, {
        direction: "column",
        gap: 2,
        children: [
          (0, import_jsx_runtime.jsx)(ForwardRef$3, {
            width: "24px",
            height: "24px",
            fill: "danger600"
          }),
          (0, import_jsx_runtime.jsx)(Typography, {
            tag: "p",
            variant: "omega",
            textAlign: "center",
            children: formatMessage({
              id: "content-manager.actions.delete.dialog.body",
              defaultMessage: "Are you sure?"
            })
          })
        ]
      }),
      onConfirm: async () => {
        if (!listViewPathMatch) {
          setSubmitting(true);
        }
        try {
          if (!documentId && collectionType !== SINGLE_TYPES) {
            console.error("You're trying to delete a document without an id, this is likely a bug with Strapi. Please open an issue.");
            toggleNotification({
              message: formatMessage({
                id: "content-manager.actions.delete.error",
                defaultMessage: "An error occurred while trying to delete the document."
              }),
              type: "danger"
            });
            return;
          }
          const res = await deleteAction({
            documentId,
            model,
            collectionType,
            params: {
              locale: "*"
            }
          });
          if (!("error" in res)) {
            navigate({
              pathname: `../${collectionType}/${model}`
            }, {
              replace: true
            });
          }
        } finally {
          if (!listViewPathMatch) {
            setSubmitting(false);
          }
        }
      }
    },
    variant: "danger",
    position: [
      "header",
      "table-row"
    ]
  };
};
DeleteAction$1.type = "delete";
DeleteAction$1.position = [
  "header",
  "table-row"
];
var DEFAULT_HEADER_ACTIONS = [
  EditTheModelAction,
  ConfigureTheViewAction,
  DeleteAction$1
];
var Panels = () => {
  const isCloning = useMatch(CLONE_PATH) !== null;
  const [{ query: { status } }] = useQueryParams({
    status: "draft"
  });
  const { model, id, document: document2, meta, collectionType } = useDoc();
  const plugins = useStrapiApp("Panels", (state) => state.plugins);
  const props = {
    activeTab: status,
    model,
    documentId: id,
    document: isCloning ? void 0 : document2,
    meta: isCloning ? void 0 : meta,
    collectionType
  };
  return (0, import_jsx_runtime.jsx)(Flex, {
    direction: "column",
    alignItems: "stretch",
    gap: 2,
    children: (0, import_jsx_runtime.jsx)(DescriptionComponentRenderer, {
      props,
      descriptions: plugins["content-manager"].apis.getEditViewSidePanels(),
      children: (panels) => panels.map(({ content, id: id2, ...description }) => (0, import_jsx_runtime.jsx)(Panel, {
        ...description,
        children: content
      }, id2))
    })
  });
};
var ActionsPanel = () => {
  const { formatMessage } = useIntl();
  return {
    title: formatMessage({
      id: "content-manager.containers.edit.panels.default.title",
      defaultMessage: "Entry"
    }),
    content: (0, import_jsx_runtime.jsx)(ActionsPanelContent, {})
  };
};
ActionsPanel.type = "actions";
var ActionsPanelContent = () => {
  const isCloning = useMatch(CLONE_PATH) !== null;
  const [{ query: { status = "draft" } }] = useQueryParams();
  const { model, id, document: document2, meta, collectionType } = useDoc();
  const plugins = useStrapiApp("ActionsPanel", (state) => state.plugins);
  const props = {
    activeTab: status,
    model,
    documentId: id,
    document: isCloning ? void 0 : document2,
    meta: isCloning ? void 0 : meta,
    collectionType
  };
  return (0, import_jsx_runtime.jsxs)(Flex, {
    direction: "column",
    gap: 2,
    width: "100%",
    children: [
      (0, import_jsx_runtime.jsx)(DescriptionComponentRenderer, {
        props,
        descriptions: plugins["content-manager"].apis.getDocumentActions("panel"),
        children: (actions2) => (0, import_jsx_runtime.jsx)(DocumentActions, {
          actions: actions2
        })
      }),
      (0, import_jsx_runtime.jsx)(InjectionZone, {
        area: "editView.right-links",
        slug: model
      })
    ]
  });
};
var Panel = React.forwardRef(({ children, title }, ref) => {
  return (0, import_jsx_runtime.jsxs)(Flex, {
    ref,
    tag: "aside",
    "aria-labelledby": "additional-information",
    background: "neutral0",
    borderColor: "neutral150",
    hasRadius: true,
    paddingBottom: 4,
    paddingLeft: 4,
    paddingRight: 4,
    paddingTop: 4,
    shadow: "tableShadow",
    gap: 3,
    direction: "column",
    justifyContent: "stretch",
    alignItems: "flex-start",
    children: [
      (0, import_jsx_runtime.jsx)(Typography, {
        tag: "h2",
        variant: "sigma",
        textTransform: "uppercase",
        textColor: "neutral600",
        children: title
      }),
      children
    ]
  });
});
var ConfirmBulkActionDialog = ({ onToggleDialog, isOpen = false, dialogBody, endAction }) => {
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsx)(Dialog.Root, {
    open: isOpen,
    children: (0, import_jsx_runtime.jsxs)(Dialog.Content, {
      children: [
        (0, import_jsx_runtime.jsx)(Dialog.Header, {
          children: formatMessage({
            id: "app.components.ConfirmDialog.title",
            defaultMessage: "Confirmation"
          })
        }),
        (0, import_jsx_runtime.jsx)(Dialog.Body, {
          children: (0, import_jsx_runtime.jsxs)(Flex, {
            direction: "column",
            alignItems: "stretch",
            gap: 2,
            children: [
              (0, import_jsx_runtime.jsx)(Flex, {
                justifyContent: "center",
                children: (0, import_jsx_runtime.jsx)(ForwardRef$3, {
                  width: "24px",
                  height: "24px",
                  fill: "danger600"
                })
              }),
              dialogBody
            ]
          })
        }),
        (0, import_jsx_runtime.jsxs)(Dialog.Footer, {
          children: [
            (0, import_jsx_runtime.jsx)(Dialog.Cancel, {
              children: (0, import_jsx_runtime.jsx)(Button, {
                fullWidth: true,
                onClick: onToggleDialog,
                variant: "tertiary",
                children: formatMessage({
                  id: "app.components.Button.cancel",
                  defaultMessage: "Cancel"
                })
              })
            }),
            endAction
          ]
        })
      ]
    })
  });
};
var BoldChunk = (chunks) => (0, import_jsx_runtime.jsx)(Typography, {
  fontWeight: "bold",
  children: chunks
});
var ConfirmDialogPublishAll = ({ isOpen, onToggleDialog, isConfirmButtonLoading = false, onConfirm }) => {
  var _a, _b;
  const { formatMessage } = useIntl();
  const selectedEntries = useTable("ConfirmDialogPublishAll", (state) => state.selectedRows);
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler(getTranslation);
  const { model, schema } = useDoc();
  const [{ query }] = useQueryParams();
  const enableDraftRelationsCount = false;
  const { data: countDraftRelations = 0, isLoading, error } = useGetManyDraftRelationCountQuery({
    model,
    documentIds: selectedEntries.map((entry) => entry.documentId),
    locale: (_b = (_a = query == null ? void 0 : query.plugins) == null ? void 0 : _a.i18n) == null ? void 0 : _b.locale
  }, {
    skip: !enableDraftRelationsCount
  });
  React.useEffect(() => {
    if (error) {
      toggleNotification({
        type: "danger",
        message: formatAPIError(error)
      });
    }
  }, [
    error,
    formatAPIError,
    toggleNotification
  ]);
  if (error) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(ConfirmBulkActionDialog, {
    isOpen: isOpen && !isLoading,
    onToggleDialog,
    dialogBody: (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
      children: [
        (0, import_jsx_runtime.jsxs)(Typography, {
          id: "confirm-description",
          textAlign: "center",
          children: [
            countDraftRelations > 0 && formatMessage({
              id: getTranslation(`popUpwarning.warning.bulk-has-draft-relations.message`),
              defaultMessage: "<b>{count} {count, plural, one { relation } other { relations } } out of {entities} { entities, plural, one { entry } other { entries } } {count, plural, one { is } other { are } }</b> not published yet and might lead to unexpected behavior. "
            }, {
              b: BoldChunk,
              count: countDraftRelations,
              entities: selectedEntries.length
            }),
            formatMessage({
              id: getTranslation("popUpWarning.bodyMessage.contentType.publish.all"),
              defaultMessage: "Are you sure you want to publish these entries?"
            })
          ]
        }),
        (schema == null ? void 0 : schema.pluginOptions) && "i18n" in schema.pluginOptions && (schema == null ? void 0 : schema.pluginOptions.i18n) && (0, import_jsx_runtime.jsx)(Typography, {
          textColor: "danger500",
          textAlign: "center",
          children: formatMessage({
            id: getTranslation("Settings.list.actions.publishAdditionalInfos"),
            defaultMessage: "This will publish the active locale versions <em>(from Internationalization)</em>"
          }, {
            em: Emphasis
          })
        })
      ]
    }),
    endAction: (0, import_jsx_runtime.jsx)(Button, {
      onClick: onConfirm,
      variant: "secondary",
      startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$4z, {}),
      loading: isConfirmButtonLoading,
      children: formatMessage({
        id: "app.utils.publish",
        defaultMessage: "Publish"
      })
    })
  });
};
var TypographyMaxWidth = dt(Typography)`
  max-width: 300px;
`;
var TableComponent = dt(RawTable)`
  width: 100%;
  table-layout: fixed;
  td:first-child {
    border-right: 1px solid ${({ theme }) => theme.colors.neutral150};
  }
  td:first-of-type {
    padding: ${({ theme }) => theme.spaces[4]};
  }
`;
var formatErrorMessages = (errors, parentKey, formatMessage) => {
  const messages = [];
  Object.entries(errors).forEach(([key, value]) => {
    const currentKey = parentKey ? `${parentKey}.${key}` : key;
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      if ("id" in value && "defaultMessage" in value) {
        messages.push(formatMessage({
          id: `${value.id}.withField`,
          defaultMessage: value.defaultMessage
        }, {
          field: currentKey
        }));
      } else {
        messages.push(...formatErrorMessages(
          // @ts-expect-error TODO: check why value is not compatible with FormErrors
          value,
          currentKey,
          formatMessage
        ));
      }
    } else {
      messages.push(formatMessage({
        id: `${value}.withField`,
        defaultMessage: value
      }, {
        field: currentKey
      }));
    }
  });
  return messages;
};
var EntryValidationText = ({ validationErrors, status }) => {
  const { formatMessage } = useIntl();
  if (validationErrors) {
    const validationErrorsMessages = formatErrorMessages(validationErrors, "", formatMessage).join(" ");
    return (0, import_jsx_runtime.jsxs)(Flex, {
      gap: 2,
      children: [
        (0, import_jsx_runtime.jsx)(ForwardRef$3Z, {
          fill: "danger600"
        }),
        (0, import_jsx_runtime.jsx)(TooltipImpl, {
          description: validationErrorsMessages,
          children: (0, import_jsx_runtime.jsx)(TypographyMaxWidth, {
            textColor: "danger600",
            variant: "omega",
            fontWeight: "semiBold",
            ellipsis: true,
            children: validationErrorsMessages
          })
        })
      ]
    });
  }
  if (status === "published") {
    return (0, import_jsx_runtime.jsxs)(Flex, {
      gap: 2,
      children: [
        (0, import_jsx_runtime.jsx)(ForwardRef$4x, {
          fill: "success600"
        }),
        (0, import_jsx_runtime.jsx)(Typography, {
          textColor: "success600",
          fontWeight: "bold",
          children: formatMessage({
            id: "content-manager.bulk-publish.already-published",
            defaultMessage: "Already Published"
          })
        })
      ]
    });
  }
  if (status === "modified") {
    return (0, import_jsx_runtime.jsxs)(Flex, {
      gap: 2,
      children: [
        (0, import_jsx_runtime.jsx)(ForwardRef$51, {
          fill: "alternative600"
        }),
        (0, import_jsx_runtime.jsx)(Typography, {
          children: formatMessage({
            id: "content-manager.bulk-publish.modified",
            defaultMessage: "Ready to publish changes"
          })
        })
      ]
    });
  }
  return (0, import_jsx_runtime.jsxs)(Flex, {
    gap: 2,
    children: [
      (0, import_jsx_runtime.jsx)(ForwardRef$4x, {
        fill: "success600"
      }),
      (0, import_jsx_runtime.jsx)(Typography, {
        children: formatMessage({
          id: "app.utils.ready-to-publish",
          defaultMessage: "Ready to publish"
        })
      })
    ]
  });
};
var TABLE_HEADERS = [
  {
    name: "id",
    label: "id"
  },
  {
    name: "name",
    label: "name"
  },
  {
    name: "status",
    label: "status"
  },
  {
    name: "publicationStatus",
    label: "Publication status"
  }
];
var SelectedEntriesTableContent = ({ isPublishing, rowsToDisplay = [], entriesToPublish = [], validationErrors = {} }) => {
  const { pathname } = useLocation();
  const { formatMessage } = useIntl();
  const { list: { settings: { mainField } } } = useDocLayout();
  const shouldDisplayMainField = mainField != null && mainField !== "id";
  return (0, import_jsx_runtime.jsxs)(Table.Content, {
    children: [
      (0, import_jsx_runtime.jsxs)(Table.Head, {
        children: [
          (0, import_jsx_runtime.jsx)(Table.HeaderCheckboxCell, {}),
          TABLE_HEADERS.filter((head) => head.name !== "name" || shouldDisplayMainField).map((head) => (0, import_jsx_runtime.jsx)(Table.HeaderCell, {
            ...head
          }, head.name))
        ]
      }),
      (0, import_jsx_runtime.jsx)(Table.Loading, {}),
      (0, import_jsx_runtime.jsx)(Table.Body, {
        children: rowsToDisplay.map((row) => (0, import_jsx_runtime.jsxs)(Table.Row, {
          children: [
            (0, import_jsx_runtime.jsx)(Table.CheckboxCell, {
              id: row.id
            }),
            (0, import_jsx_runtime.jsx)(Table.Cell, {
              children: (0, import_jsx_runtime.jsx)(Typography, {
                children: row.id
              })
            }),
            shouldDisplayMainField && (0, import_jsx_runtime.jsx)(Table.Cell, {
              children: (0, import_jsx_runtime.jsx)(Typography, {
                children: row[mainField]
              })
            }),
            (0, import_jsx_runtime.jsx)(Table.Cell, {
              children: (0, import_jsx_runtime.jsx)(DocumentStatus, {
                status: row.status,
                maxWidth: "min-content"
              })
            }),
            (0, import_jsx_runtime.jsx)(Table.Cell, {
              children: isPublishing && entriesToPublish.includes(row.documentId) ? (0, import_jsx_runtime.jsxs)(Flex, {
                gap: 2,
                children: [
                  (0, import_jsx_runtime.jsx)(Typography, {
                    children: formatMessage({
                      id: "content-manager.success.record.publishing",
                      defaultMessage: "Publishing..."
                    })
                  }),
                  (0, import_jsx_runtime.jsx)(Loader, {
                    small: true
                  })
                ]
              }) : (0, import_jsx_runtime.jsx)(EntryValidationText, {
                validationErrors: validationErrors[row.documentId],
                status: row.status
              })
            }),
            (0, import_jsx_runtime.jsx)(Table.Cell, {
              children: (0, import_jsx_runtime.jsx)(Flex, {
                children: (0, import_jsx_runtime.jsx)(IconButton, {
                  tag: Link,
                  to: {
                    pathname: `${pathname}/${row.documentId}`,
                    search: row.locale && `?plugins[i18n][locale]=${row.locale}`
                  },
                  state: {
                    from: pathname
                  },
                  label: formatMessage({
                    id: "content-manager.bulk-publish.edit",
                    defaultMessage: "Edit"
                  }),
                  target: "_blank",
                  marginLeft: "auto",
                  variant: "ghost",
                  children: (0, import_jsx_runtime.jsx)(ForwardRef$1r, {
                    width: "1.6rem",
                    height: "1.6rem"
                  })
                })
              })
            })
          ]
        }, row.id))
      })
    ]
  });
};
var PublicationStatusSummary = ({ count, icon, message }) => {
  return (0, import_jsx_runtime.jsxs)(Flex, {
    justifyContent: "space-between",
    flex: 1,
    gap: 3,
    children: [
      (0, import_jsx_runtime.jsxs)(Flex, {
        gap: 2,
        children: [
          icon,
          (0, import_jsx_runtime.jsx)(Typography, {
            children: message
          })
        ]
      }),
      (0, import_jsx_runtime.jsx)(Typography, {
        fontWeight: "bold",
        children: count
      })
    ]
  });
};
var PublicationStatusGrid = ({ entriesReadyToPublishCount, entriesPublishedCount, entriesModifiedCount, entriesWithErrorsCount }) => {
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsx)(Box, {
    hasRadius: true,
    borderColor: "neutral150",
    children: (0, import_jsx_runtime.jsx)(TableComponent, {
      colCount: 2,
      rowCount: 2,
      children: (0, import_jsx_runtime.jsxs)(Tbody, {
        children: [
          (0, import_jsx_runtime.jsxs)(Tr, {
            children: [
              (0, import_jsx_runtime.jsx)(Td, {
                children: (0, import_jsx_runtime.jsx)(PublicationStatusSummary, {
                  count: entriesReadyToPublishCount,
                  icon: (0, import_jsx_runtime.jsx)(ForwardRef$4x, {
                    fill: "success600"
                  }),
                  message: formatMessage({
                    id: "app.utils.ready-to-publish",
                    defaultMessage: "Ready to publish"
                  })
                })
              }),
              (0, import_jsx_runtime.jsx)(Td, {
                children: (0, import_jsx_runtime.jsx)(PublicationStatusSummary, {
                  count: entriesPublishedCount,
                  icon: (0, import_jsx_runtime.jsx)(ForwardRef$4x, {
                    fill: "success600"
                  }),
                  message: formatMessage({
                    id: "app.utils.already-published",
                    defaultMessage: "Already published"
                  })
                })
              })
            ]
          }),
          (0, import_jsx_runtime.jsxs)(Tr, {
            children: [
              (0, import_jsx_runtime.jsx)(Td, {
                children: (0, import_jsx_runtime.jsx)(PublicationStatusSummary, {
                  count: entriesModifiedCount,
                  icon: (0, import_jsx_runtime.jsx)(ForwardRef$51, {
                    fill: "alternative600"
                  }),
                  message: formatMessage({
                    id: "content-manager.bulk-publish.modified",
                    defaultMessage: "Ready to publish changes"
                  })
                })
              }),
              (0, import_jsx_runtime.jsx)(Td, {
                children: (0, import_jsx_runtime.jsx)(PublicationStatusSummary, {
                  count: entriesWithErrorsCount,
                  icon: (0, import_jsx_runtime.jsx)(ForwardRef$3Z, {
                    fill: "danger600"
                  }),
                  message: formatMessage({
                    id: "content-manager.bulk-publish.waiting-for-action",
                    defaultMessage: "Waiting for action"
                  })
                })
              })
            ]
          })
        ]
      })
    })
  });
};
var SelectedEntriesModalContent = ({ listViewSelectedEntries, toggleModal, setListViewSelectedDocuments, model }) => {
  var _a, _b;
  const { formatMessage } = useIntl();
  const { schema, components } = useContentTypeSchema(model);
  const documentIds = listViewSelectedEntries.map(({ documentId }) => documentId);
  const [{ query }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  const { data, isLoading, isFetching, refetch } = useGetAllDocumentsQuery({
    model,
    params: {
      page: "1",
      pageSize: documentIds.length.toString(),
      sort: query.sort,
      filters: {
        documentId: {
          $in: documentIds
        }
      },
      locale: (_b = (_a = query.plugins) == null ? void 0 : _a.i18n) == null ? void 0 : _b.locale
    }
  }, {
    selectFromResult: ({ data: data2, ...restRes }) => ({
      data: (data2 == null ? void 0 : data2.results) ?? [],
      ...restRes
    })
  });
  const { rows, validationErrors } = React.useMemo(() => {
    if (data.length > 0 && schema) {
      const validate = createYupSchema(
        schema.attributes,
        components,
        // Since this is the "Publish" action, the validation
        // schema must enforce the rules for published entities
        {
          status: "published"
        }
      );
      const validationErrors2 = {};
      const rows2 = data.map((entry) => {
        try {
          validate.validateSync(entry, {
            abortEarly: false
          });
          return entry;
        } catch (e) {
          if (e instanceof ValidationError) {
            validationErrors2[entry.documentId] = getYupValidationErrors(e);
          }
          return entry;
        }
      });
      return {
        rows: rows2,
        validationErrors: validationErrors2
      };
    }
    return {
      rows: [],
      validationErrors: {}
    };
  }, [
    components,
    data,
    schema
  ]);
  const [isDialogOpen, setIsDialogOpen] = React.useState(false);
  const { publishMany: bulkPublishAction } = useDocumentActions();
  const [, { isLoading: isSubmittingForm }] = usePublishManyDocumentsMutation();
  const selectedRows = useTable("publishAction", (state) => state.selectedRows);
  const selectedEntries = rows.filter((entry) => selectedRows.some((selectedEntry) => selectedEntry.documentId === entry.documentId));
  const entriesToPublish = selectedEntries.filter((entry) => !validationErrors[entry.documentId]).map((entry) => entry.documentId);
  const selectedEntriesWithErrorsCount = selectedEntries.filter(({ documentId }) => validationErrors[documentId]).length;
  const selectedEntriesPublishedCount = selectedEntries.filter(({ status }) => status === "published").length;
  const selectedEntriesModifiedCount = selectedEntries.filter(({ status, documentId }) => status === "modified" && !validationErrors[documentId]).length;
  const selectedEntriesWithNoErrorsCount = selectedEntries.length - selectedEntriesWithErrorsCount - selectedEntriesPublishedCount;
  const toggleDialog = () => setIsDialogOpen((prev) => !prev);
  const handleConfirmBulkPublish = async () => {
    toggleDialog();
    const res = await bulkPublishAction({
      model,
      documentIds: entriesToPublish,
      params
    });
    if (!("error" in res)) {
      const unpublishedEntries = rows.filter((row) => {
        return !entriesToPublish.includes(row.documentId);
      });
      setListViewSelectedDocuments(unpublishedEntries);
    }
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [
      (0, import_jsx_runtime.jsxs)(Modal.Body, {
        children: [
          (0, import_jsx_runtime.jsx)(PublicationStatusGrid, {
            entriesReadyToPublishCount: selectedEntriesWithNoErrorsCount - selectedEntriesModifiedCount,
            entriesPublishedCount: selectedEntriesPublishedCount,
            entriesModifiedCount: selectedEntriesModifiedCount,
            entriesWithErrorsCount: selectedEntriesWithErrorsCount
          }),
          (0, import_jsx_runtime.jsx)(Box, {
            marginTop: 7,
            children: (0, import_jsx_runtime.jsx)(SelectedEntriesTableContent, {
              isPublishing: isSubmittingForm,
              rowsToDisplay: rows,
              entriesToPublish,
              validationErrors
            })
          })
        ]
      }),
      (0, import_jsx_runtime.jsxs)(Modal.Footer, {
        children: [
          (0, import_jsx_runtime.jsx)(Button, {
            onClick: toggleModal,
            variant: "tertiary",
            children: formatMessage({
              id: "app.components.Button.cancel",
              defaultMessage: "Cancel"
            })
          }),
          (0, import_jsx_runtime.jsxs)(Flex, {
            gap: 2,
            children: [
              (0, import_jsx_runtime.jsx)(Button, {
                onClick: refetch,
                variant: "tertiary",
                loading: isFetching,
                children: formatMessage({
                  id: "app.utils.refresh",
                  defaultMessage: "Refresh"
                })
              }),
              (0, import_jsx_runtime.jsx)(Button, {
                onClick: toggleDialog,
                disabled: selectedEntries.length === 0 || selectedEntries.length === selectedEntriesWithErrorsCount || selectedEntriesPublishedCount === selectedEntries.length || isLoading,
                loading: isSubmittingForm,
                children: formatMessage({
                  id: "app.utils.publish",
                  defaultMessage: "Publish"
                })
              })
            ]
          })
        ]
      }),
      (0, import_jsx_runtime.jsx)(ConfirmDialogPublishAll, {
        isOpen: isDialogOpen,
        onToggleDialog: toggleDialog,
        isConfirmButtonLoading: isSubmittingForm,
        onConfirm: handleConfirmBulkPublish
      })
    ]
  });
};
var PublishAction = ({ documents, model }) => {
  const { formatMessage } = useIntl();
  const hasPublishPermission = useDocumentRBAC("unpublishAction", (state) => state.canPublish);
  const showPublishButton = hasPublishPermission && documents.some(({ status }) => status !== "published");
  const setListViewSelectedDocuments = useTable("publishAction", (state) => state.selectRow);
  const refetchList = () => {
    contentManagerApi.util.invalidateTags([
      {
        type: "Document",
        id: `${model}_LIST`
      }
    ]);
  };
  if (!showPublishButton)
    return null;
  return {
    actionType: "publish",
    variant: "tertiary",
    label: formatMessage({
      id: "app.utils.publish",
      defaultMessage: "Publish"
    }),
    dialog: {
      type: "modal",
      title: formatMessage({
        id: getTranslation("containers.ListPage.selectedEntriesModal.title"),
        defaultMessage: "Publish entries"
      }),
      content: ({ onClose }) => {
        return (0, import_jsx_runtime.jsx)(Table.Root, {
          rows: documents,
          defaultSelectedRows: documents,
          headers: TABLE_HEADERS,
          children: (0, import_jsx_runtime.jsx)(SelectedEntriesModalContent, {
            listViewSelectedEntries: documents,
            toggleModal: () => {
              onClose();
              refetchList();
            },
            setListViewSelectedDocuments,
            model
          })
        });
      },
      onClose: () => {
        refetchList();
      }
    }
  };
};
var BulkActionsRenderer = () => {
  const plugins = useStrapiApp("BulkActionsRenderer", (state) => state.plugins);
  const { model, collectionType } = useDoc();
  const { selectedRows } = useTable("BulkActionsRenderer", (state) => state);
  return (0, import_jsx_runtime.jsx)(Flex, {
    gap: 2,
    children: (0, import_jsx_runtime.jsx)(DescriptionComponentRenderer, {
      props: {
        model,
        collectionType,
        documents: selectedRows
      },
      descriptions: plugins["content-manager"].apis.getBulkActions(),
      children: (actions2) => actions2.map((action) => (0, import_jsx_runtime.jsx)(DocumentActionButton, {
        ...action
      }, action.id))
    })
  });
};
var DeleteAction = ({ documents, model }) => {
  var _a;
  const { formatMessage } = useIntl();
  const { schema: contentType } = useDoc();
  const selectRow = useTable("DeleteAction", (state) => state.selectRow);
  const hasI18nEnabled = Boolean((_a = contentType == null ? void 0 : contentType.pluginOptions) == null ? void 0 : _a.i18n);
  const [{ query }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  const hasDeletePermission = useDocumentRBAC("deleteAction", (state) => state.canDelete);
  const { deleteMany: bulkDeleteAction } = useDocumentActions();
  const documentIds = documents.map(({ documentId }) => documentId);
  const handleConfirmBulkDelete = async () => {
    const res = await bulkDeleteAction({
      documentIds,
      model,
      params
    });
    if (!("error" in res)) {
      selectRow([]);
    }
  };
  if (!hasDeletePermission)
    return null;
  return {
    variant: "danger-light",
    label: formatMessage({
      id: "global.delete",
      defaultMessage: "Delete"
    }),
    dialog: {
      type: "dialog",
      title: formatMessage({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, {
        direction: "column",
        alignItems: "stretch",
        gap: 2,
        children: [
          (0, import_jsx_runtime.jsx)(Flex, {
            justifyContent: "center",
            children: (0, import_jsx_runtime.jsx)(ForwardRef$3, {
              width: "24px",
              height: "24px",
              fill: "danger600"
            })
          }),
          (0, import_jsx_runtime.jsx)(Typography, {
            id: "confirm-description",
            textAlign: "center",
            children: formatMessage({
              id: "popUpWarning.bodyMessage.contentType.delete.all",
              defaultMessage: "Are you sure you want to delete these entries?"
            })
          }),
          hasI18nEnabled && (0, import_jsx_runtime.jsx)(Box, {
            textAlign: "center",
            padding: 3,
            children: (0, import_jsx_runtime.jsx)(Typography, {
              textColor: "danger500",
              children: formatMessage({
                id: getTranslation("Settings.list.actions.deleteAdditionalInfos"),
                defaultMessage: "This will delete the active locale versions <em>(from Internationalization)</em>"
              }, {
                em: Emphasis
              })
            })
          })
        ]
      }),
      onConfirm: handleConfirmBulkDelete
    }
  };
};
DeleteAction.type = "delete";
var UnpublishAction = ({ documents, model }) => {
  var _a, _b;
  const { formatMessage } = useIntl();
  const { schema } = useDoc();
  const selectRow = useTable("UnpublishAction", (state) => state.selectRow);
  const hasPublishPermission = useDocumentRBAC("unpublishAction", (state) => state.canPublish);
  const hasI18nEnabled = Boolean((_a = schema == null ? void 0 : schema.pluginOptions) == null ? void 0 : _a.i18n);
  const hasDraftAndPublishEnabled = Boolean((_b = schema == null ? void 0 : schema.options) == null ? void 0 : _b.draftAndPublish);
  const { unpublishMany: bulkUnpublishAction } = useDocumentActions();
  const documentIds = documents.map(({ documentId }) => documentId);
  const [{ query }] = useQueryParams();
  const params = React.useMemo(() => buildValidParams(query), [
    query
  ]);
  const handleConfirmBulkUnpublish = async () => {
    const data = await bulkUnpublishAction({
      documentIds,
      model,
      params
    });
    if (!("error" in data)) {
      selectRow([]);
    }
  };
  const showUnpublishButton = hasDraftAndPublishEnabled && hasPublishPermission && documents.some((entry) => entry.status === "published" || entry.status === "modified");
  if (!showUnpublishButton)
    return null;
  return {
    variant: "tertiary",
    label: formatMessage({
      id: "app.utils.unpublish",
      defaultMessage: "Unpublish"
    }),
    dialog: {
      type: "dialog",
      title: formatMessage({
        id: "app.components.ConfirmDialog.title",
        defaultMessage: "Confirmation"
      }),
      content: (0, import_jsx_runtime.jsxs)(Flex, {
        direction: "column",
        alignItems: "stretch",
        gap: 2,
        children: [
          (0, import_jsx_runtime.jsx)(Flex, {
            justifyContent: "center",
            children: (0, import_jsx_runtime.jsx)(ForwardRef$3, {
              width: "24px",
              height: "24px",
              fill: "danger600"
            })
          }),
          (0, import_jsx_runtime.jsx)(Typography, {
            id: "confirm-description",
            textAlign: "center",
            children: formatMessage({
              id: "popUpWarning.bodyMessage.contentType.unpublish.all",
              defaultMessage: "Are you sure you want to unpublish these entries?"
            })
          }),
          hasI18nEnabled && (0, import_jsx_runtime.jsx)(Box, {
            textAlign: "center",
            padding: 3,
            children: (0, import_jsx_runtime.jsx)(Typography, {
              textColor: "danger500",
              children: formatMessage({
                id: getTranslation("Settings.list.actions.unpublishAdditionalInfos"),
                defaultMessage: "This will unpublish the active locale versions <em>(from Internationalization)</em>"
              }, {
                em: Emphasis
              })
            })
          })
        ]
      }),
      confirmButton: formatMessage({
        id: "app.utils.unpublish",
        defaultMessage: "Unpublish"
      }),
      onConfirm: handleConfirmBulkUnpublish
    }
  };
};
UnpublishAction.type = "unpublish";
var Emphasis = (chunks) => (0, import_jsx_runtime.jsx)(Typography, {
  fontWeight: "semiBold",
  textColor: "danger500",
  children: chunks
});
var DEFAULT_BULK_ACTIONS = [
  PublishAction,
  UnpublishAction,
  DeleteAction
];
var AutoCloneFailureModalBody = ({ prohibitedFields }) => {
  const { formatMessage } = useIntl();
  const getDefaultErrorMessage = (reason) => {
    switch (reason) {
      case "relation":
        return "Duplicating the relation could remove it from the original entry.";
      case "unique":
        return "Identical values in a unique field are not allowed";
      default:
        return reason;
    }
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [
      (0, import_jsx_runtime.jsx)(Typography, {
        variant: "beta",
        children: formatMessage({
          id: getTranslation("containers.list.autoCloneModal.title"),
          defaultMessage: "This entry can't be duplicated directly."
        })
      }),
      (0, import_jsx_runtime.jsx)(Box, {
        marginTop: 2,
        children: (0, import_jsx_runtime.jsx)(Typography, {
          textColor: "neutral600",
          children: formatMessage({
            id: getTranslation("containers.list.autoCloneModal.description"),
            defaultMessage: "A new entry will be created with the same content, but you'll have to change the following fields to save it."
          })
        })
      }),
      (0, import_jsx_runtime.jsx)(Flex, {
        marginTop: 6,
        gap: 2,
        direction: "column",
        alignItems: "stretch",
        children: prohibitedFields.map(([fieldPath, reason]) => (0, import_jsx_runtime.jsxs)(Flex, {
          direction: "column",
          gap: 2,
          alignItems: "flex-start",
          borderColor: "neutral200",
          hasRadius: true,
          padding: 6,
          children: [
            (0, import_jsx_runtime.jsx)(Flex, {
              direction: "row",
              tag: "ol",
              children: fieldPath.map((pathSegment, index2) => (0, import_jsx_runtime.jsxs)(Typography, {
                fontWeight: "semiBold",
                tag: "li",
                children: [
                  pathSegment,
                  index2 !== fieldPath.length - 1 && (0, import_jsx_runtime.jsx)(ForwardRef$4p, {
                    fill: "neutral500",
                    height: "0.8rem",
                    width: "0.8rem",
                    style: {
                      margin: "0 0.8rem"
                    }
                  })
                ]
              }, index2))
            }),
            (0, import_jsx_runtime.jsx)(Typography, {
              tag: "p",
              textColor: "neutral600",
              children: formatMessage({
                id: getTranslation(`containers.list.autoCloneModal.error.${reason}`),
                defaultMessage: getDefaultErrorMessage(reason)
              })
            })
          ]
        }, fieldPath.join()))
      })
    ]
  });
};
var TableActions = ({ document: document2 }) => {
  const { formatMessage } = useIntl();
  const { model, collectionType } = useDoc();
  const plugins = useStrapiApp("TableActions", (state) => state.plugins);
  const props = {
    activeTab: null,
    model,
    documentId: document2.documentId,
    collectionType,
    document: document2
  };
  return (0, import_jsx_runtime.jsx)(DescriptionComponentRenderer, {
    props,
    descriptions: plugins["content-manager"].apis.getDocumentActions("table-row").filter((action) => action.name !== "PublishAction"),
    children: (actions2) => {
      const tableRowActions = actions2.filter((action) => {
        const positions = Array.isArray(action.position) ? action.position : [
          action.position
        ];
        return positions.includes("table-row");
      });
      return (0, import_jsx_runtime.jsx)(DocumentActionsMenu, {
        actions: tableRowActions,
        label: formatMessage({
          id: "content-manager.containers.list.table.row-actions",
          defaultMessage: "Row actions"
        }),
        variant: "ghost"
      });
    }
  });
};
var EditAction = ({ documentId }) => {
  const navigate = useNavigate();
  const { formatMessage } = useIntl();
  const { canRead } = useDocumentRBAC("EditAction", ({ canRead: canRead2 }) => ({
    canRead: canRead2
  }));
  const { toggleNotification } = useNotification();
  const [{ query }] = useQueryParams();
  return {
    disabled: !canRead,
    icon: (0, import_jsx_runtime.jsx)(StyledPencil, {}),
    label: formatMessage({
      id: "content-manager.actions.edit.label",
      defaultMessage: "Edit"
    }),
    position: "table-row",
    onClick: async () => {
      if (!documentId) {
        console.error("You're trying to edit a document without an id, this is likely a bug with Strapi. Please open an issue.");
        toggleNotification({
          message: formatMessage({
            id: "content-manager.actions.edit.error",
            defaultMessage: "An error occurred while trying to edit the document."
          }),
          type: "danger"
        });
        return;
      }
      navigate({
        pathname: documentId,
        search: (0, import_qs.stringify)({
          plugins: query.plugins
        })
      });
    }
  };
};
EditAction.type = "edit";
EditAction.position = "table-row";
var StyledPencil = dt(ForwardRef$1r)`
  path {
    fill: currentColor;
  }
`;
var CloneAction = ({ model, documentId }) => {
  const navigate = useNavigate();
  const { formatMessage } = useIntl();
  const { canCreate } = useDocumentRBAC("CloneAction", ({ canCreate: canCreate2 }) => ({
    canCreate: canCreate2
  }));
  const { toggleNotification } = useNotification();
  const { autoClone } = useDocumentActions();
  const [prohibitedFields, setProhibitedFields] = React.useState([]);
  return {
    disabled: !canCreate,
    icon: (0, import_jsx_runtime.jsx)(StyledDuplicate, {}),
    label: formatMessage({
      id: "content-manager.actions.clone.label",
      defaultMessage: "Duplicate"
    }),
    position: "table-row",
    onClick: async () => {
      if (!documentId) {
        console.error("You're trying to clone a document in the table without an id, this is likely a bug with Strapi. Please open an issue.");
        toggleNotification({
          message: formatMessage({
            id: "content-manager.actions.clone.error",
            defaultMessage: "An error occurred while trying to clone the document."
          }),
          type: "danger"
        });
        return;
      }
      const res = await autoClone({
        model,
        sourceId: documentId
      });
      if ("data" in res) {
        navigate(res.data.documentId);
        return true;
      }
      if (isBaseQueryError(res.error) && res.error.details && typeof res.error.details === "object" && "prohibitedFields" in res.error.details && Array.isArray(res.error.details.prohibitedFields)) {
        const prohibitedFields2 = res.error.details.prohibitedFields;
        setProhibitedFields(prohibitedFields2);
      }
    },
    dialog: {
      type: "modal",
      title: formatMessage({
        id: "content-manager.containers.list.autoCloneModal.header",
        defaultMessage: "Duplicate"
      }),
      content: (0, import_jsx_runtime.jsx)(AutoCloneFailureModalBody, {
        prohibitedFields
      }),
      footer: ({ onClose }) => {
        return (0, import_jsx_runtime.jsxs)(Modal.Footer, {
          children: [
            (0, import_jsx_runtime.jsx)(Button, {
              onClick: onClose,
              variant: "tertiary",
              children: formatMessage({
                id: "cancel",
                defaultMessage: "Cancel"
              })
            }),
            (0, import_jsx_runtime.jsx)(LinkButton, {
              tag: NavLink,
              to: {
                pathname: `clone/${documentId}`
              },
              children: formatMessage({
                id: "content-manager.containers.list.autoCloneModal.create",
                defaultMessage: "Create"
              })
            })
          ]
        });
      }
    }
  };
};
CloneAction.type = "clone";
CloneAction.position = "table-row";
var StyledDuplicate = dt(ForwardRef$3L)`
  path {
    fill: currentColor;
  }
`;
var DEFAULT_TABLE_ROW_ACTIONS = [
  EditAction,
  CloneAction
];
var ContentManagerPlugin = class {
  addEditViewSidePanel(panels) {
    if (Array.isArray(panels)) {
      this.editViewSidePanels = [
        ...this.editViewSidePanels,
        ...panels
      ];
    } else if (typeof panels === "function") {
      this.editViewSidePanels = panels(this.editViewSidePanels);
    } else {
      throw new Error(`Expected the \`panels\` passed to \`addEditViewSidePanel\` to be an array or a function, but received ${getPrintableType(panels)}`);
    }
  }
  addDocumentAction(actions2) {
    if (Array.isArray(actions2)) {
      this.documentActions = [
        ...this.documentActions,
        ...actions2
      ];
    } else if (typeof actions2 === "function") {
      this.documentActions = actions2(this.documentActions);
    } else {
      throw new Error(`Expected the \`actions\` passed to \`addDocumentAction\` to be an array or a function, but received ${getPrintableType(actions2)}`);
    }
  }
  addDocumentHeaderAction(actions2) {
    if (Array.isArray(actions2)) {
      this.headerActions = [
        ...this.headerActions,
        ...actions2
      ];
    } else if (typeof actions2 === "function") {
      this.headerActions = actions2(this.headerActions);
    } else {
      throw new Error(`Expected the \`actions\` passed to \`addDocumentHeaderAction\` to be an array or a function, but received ${getPrintableType(actions2)}`);
    }
  }
  addBulkAction(actions2) {
    if (Array.isArray(actions2)) {
      this.bulkActions = [
        ...this.bulkActions,
        ...actions2
      ];
    } else if (typeof actions2 === "function") {
      this.bulkActions = actions2(this.bulkActions);
    } else {
      throw new Error(`Expected the \`actions\` passed to \`addBulkAction\` to be an array or a function, but received ${getPrintableType(actions2)}`);
    }
  }
  get config() {
    return {
      id: PLUGIN_ID,
      name: "Content Manager",
      injectionZones: INJECTION_ZONES,
      apis: {
        addBulkAction: this.addBulkAction.bind(this),
        addDocumentAction: this.addDocumentAction.bind(this),
        addDocumentHeaderAction: this.addDocumentHeaderAction.bind(this),
        addEditViewSidePanel: this.addEditViewSidePanel.bind(this),
        getBulkActions: () => this.bulkActions,
        getDocumentActions: (position) => {
          if (position) {
            return this.documentActions.filter((action) => action.position == void 0 || [
              action.position
            ].flat().includes(position));
          }
          return this.documentActions;
        },
        getEditViewSidePanels: () => this.editViewSidePanels,
        getHeaderActions: () => this.headerActions
      }
    };
  }
  constructor() {
    this.bulkActions = [
      ...DEFAULT_BULK_ACTIONS
    ];
    this.documentActions = [
      ...DEFAULT_ACTIONS,
      ...DEFAULT_TABLE_ROW_ACTIONS,
      ...DEFAULT_HEADER_ACTIONS
    ];
    this.editViewSidePanels = [
      ActionsPanel
    ];
    this.headerActions = [];
  }
};
var getPrintableType = (value) => {
  const nativeType = typeof value;
  if (nativeType === "object") {
    if (value === null)
      return "null";
    if (Array.isArray(value))
      return "array";
    if (value instanceof Object && value.constructor.name !== "Object") {
      return value.constructor.name;
    }
  }
  return nativeType;
};
var HistoryAction = ({ model, document: document2 }) => {
  const { formatMessage } = useIntl();
  const [{ query }] = useQueryParams();
  const navigate = useNavigate();
  const { trackUsage } = useTracking();
  const { pathname } = useLocation();
  const pluginsQueryParams = (0, import_qs.stringify)({
    plugins: query.plugins
  }, {
    encode: false
  });
  if (!window.strapi.features.isEnabled("cms-content-history")) {
    return null;
  }
  const handleOnClick = () => {
    const destination = {
      pathname: "history",
      search: pluginsQueryParams
    };
    trackUsage("willNavigate", {
      from: pathname,
      to: `${pathname}/${destination.pathname}`
    });
    navigate(destination);
  };
  return {
    icon: (0, import_jsx_runtime.jsx)(ForwardRef$4j, {}),
    label: formatMessage({
      id: "content-manager.history.document-action",
      defaultMessage: "Content History"
    }),
    onClick: handleOnClick,
    disabled: (
      /**
      * The user is creating a new document.
      * It hasn't been saved yet, so there's no history to go to
      */
      !document2 || /**
      * The document has been created but the current dimension has never been saved.
      * For example, the user is creating a new locale in an existing document,
      * so there's no history for the document in that locale
      */
      !document2.id || /**
      * History is only available for content types created by the user.
      * These have the `api::` prefix, as opposed to the ones created by Strapi or plugins,
      * which start with `admin::` or `plugin::`
      */
      !model.startsWith("api::")
    ),
    position: "header"
  };
};
HistoryAction.type = "history";
HistoryAction.position = "header";
var historyAdmin = {
  bootstrap(app) {
    const { addDocumentAction } = app.getPlugin("content-manager").apis;
    addDocumentAction((actions2) => {
      const indexOfDeleteAction = actions2.findIndex((action) => action.type === "delete");
      actions2.splice(indexOfDeleteAction, 0, HistoryAction);
      return actions2;
    });
  }
};
var initialState = {
  collectionTypeLinks: [],
  components: [],
  fieldSizes: {},
  models: [],
  singleTypeLinks: [],
  isLoading: true
};
var appSlice = createSlice({
  name: "app",
  initialState,
  reducers: {
    setInitialData(state, action) {
      const { authorizedCollectionTypeLinks, authorizedSingleTypeLinks, components, contentTypeSchemas, fieldSizes } = action.payload;
      state.collectionTypeLinks = authorizedCollectionTypeLinks.filter(({ isDisplayed }) => isDisplayed);
      state.singleTypeLinks = authorizedSingleTypeLinks.filter(({ isDisplayed }) => isDisplayed);
      state.components = components;
      state.models = contentTypeSchemas;
      state.fieldSizes = fieldSizes;
      state.isLoading = false;
    }
  }
});
var { actions, reducer: reducer$1 } = appSlice;
var { setInitialData } = actions;
var reducer = combineReducers({
  app: reducer$1
});
var previewApi = contentManagerApi.injectEndpoints({
  endpoints: (builder) => ({
    getPreviewUrl: builder.query({
      query({ query, params }) {
        return {
          url: `/content-manager/preview/url/${params.contentType}`,
          method: "GET",
          config: {
            params: query
          }
        };
      }
    })
  })
});
var { useGetPreviewUrlQuery } = previewApi;
var ConditionalTooltip = ({ isShown, label, children }) => {
  if (isShown) {
    return (0, import_jsx_runtime.jsx)(TooltipImpl, {
      label,
      children
    });
  }
  return children;
};
var PreviewSidePanel = ({ model, documentId, document: document2 }) => {
  var _a;
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const { pathname } = useLocation();
  const [{ query }] = useQueryParams();
  const isModified = useForm("PreviewSidePanel", (state) => state.modified);
  const { data, error } = useGetPreviewUrlQuery({
    params: {
      contentType: model
    },
    query: {
      documentId,
      locale: document2 == null ? void 0 : document2.locale,
      status: document2 == null ? void 0 : document2.status
    }
  });
  if (!((_a = data == null ? void 0 : data.data) == null ? void 0 : _a.url) || error) {
    return null;
  }
  const trackNavigation = () => {
    const destinationPathname = pathname.replace(/\/$/, "") + "/preview";
    trackUsage("willNavigate", {
      from: pathname,
      to: destinationPathname
    });
  };
  return {
    title: formatMessage({
      id: "content-manager.preview.panel.title",
      defaultMessage: "Preview"
    }),
    content: (0, import_jsx_runtime.jsx)(ConditionalTooltip, {
      label: formatMessage({
        id: "content-manager.preview.panel.button-disabled-tooltip",
        defaultMessage: "Please save to open the preview"
      }),
      isShown: isModified,
      children: (0, import_jsx_runtime.jsx)(Box, {
        cursor: "not-allowed",
        width: "100%",
        children: (0, import_jsx_runtime.jsx)(Button, {
          variant: "tertiary",
          tag: Link,
          to: {
            pathname: "preview",
            search: (0, import_qs.stringify)(query, {
              encode: false
            })
          },
          onClick: trackNavigation,
          width: "100%",
          disabled: isModified,
          pointerEvents: isModified ? "none" : void 0,
          tabIndex: isModified ? -1 : void 0,
          children: formatMessage({
            id: "content-manager.preview.panel.button",
            defaultMessage: "Open preview"
          })
        })
      })
    })
  };
};
var previewAdmin = {
  bootstrap(app) {
    const contentManagerPluginApis = app.getPlugin("content-manager").apis;
    contentManagerPluginApis.addEditViewSidePanel([
      PreviewSidePanel
    ]);
  }
};
function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case "./translations/ar.json":
      return import("./ar-DckYq_WK-IE57GPIY.js");
    case "./translations/ca.json":
      return import("./ca-DviY7mRj-7X6IZSWO.js");
    case "./translations/cs.json":
      return import("./cs-C7OSYFQ7-SQAUR6QD.js");
    case "./translations/de.json":
      return import("./de-5QRlDHyR-M3HY2I55.js");
    case "./translations/en.json":
      return import("./en-LfhocNG2-7QKDZD2P.js");
    case "./translations/es.json":
      return import("./es-DkoWSExG-RWOTV7NE.js");
    case "./translations/eu.json":
      return import("./eu-BG1xX7HK-2IYS3MVD.js");
    case "./translations/fr.json":
      return import("./fr-CFdRaRVj-WFZEZN36.js");
    case "./translations/gu.json":
      return import("./gu-D5MMMXRs-S5PKQCVM.js");
    case "./translations/hi.json":
      return import("./hi-lp17SCjr-GJFDYZDS.js");
    case "./translations/hu.json":
      return import("./hu-CLka1U2C-SSUOBIKT.js");
    case "./translations/id.json":
      return import("./id-USfY9m1g-7MM6CNBV.js");
    case "./translations/it.json":
      return import("./it-BAHrwmYS-OOSGUSSM.js");
    case "./translations/ja.json":
      return import("./ja-BWKmBJFT-6W5RR53V.js");
    case "./translations/ko.json":
      return import("./ko-CgADGBNt-RQCJWJLM.js");
    case "./translations/ml.json":
      return import("./ml-CnhCfOn_-RHNC7EGT.js");
    case "./translations/ms.json":
      return import("./ms-Bh09NFff-CV5BLKTI.js");
    case "./translations/nl.json":
      return import("./nl-C8HYflTc-WARVPPDH.js");
    case "./translations/pl.json":
      return import("./pl-MFCZJZuZ-OKQKQ6VV.js");
    case "./translations/pt-BR.json":
      return import("./pt-BR-CcotyBGJ-SXPBA23W.js");
    case "./translations/pt.json":
      return import("./pt-HbmgeiYO-PUY6ENWC.js");
    case "./translations/ru.json":
      return import("./ru-CB4BUyQp-U3I2BB5X.js");
    case "./translations/sa.json":
      return import("./sa-n_aPA-pU-C7JPBUZI.js");
    case "./translations/sk.json":
      return import("./sk-tn_BDjE2-JRTEKBBI.js");
    case "./translations/sv.json":
      return import("./sv-cq4ZrQRd-WA2OMESH.js");
    case "./translations/th.json":
      return import("./th-mUH7hEtc-4AVOE45A.js");
    case "./translations/tr.json":
      return import("./tr-Yt38daxh-PHG6Z6NG.js");
    case "./translations/uk.json":
      return import("./uk-Cpgmm7gE-PRJ2LBU4.js");
    case "./translations/vi.json":
      return import("./vi-CvBGlTjr-ZQSPENX7.js");
    case "./translations/zh-Hans.json":
      return import("./zh-Hans-CI0HKio3-OH3JCSVL.js");
    case "./translations/zh.json":
      return import("./zh-BmF-sHaT-RMP6FQBM.js");
    default:
      return new Promise(function(resolve, reject) {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
          reject.bind(null, new Error("Unknown variable dynamic import: " + path))
        );
      });
  }
}
var index = {
  register(app) {
    const cm = new ContentManagerPlugin();
    app.addReducers({
      [PLUGIN_ID]: reducer
    });
    app.addMenuLink({
      to: PLUGIN_ID,
      icon: ForwardRef$3r,
      intlLabel: {
        id: `content-manager.plugin.name`,
        defaultMessage: "Content Manager"
      },
      permissions: [],
      position: 1
    });
    app.router.addRoute({
      path: "content-manager/*",
      lazy: async () => {
        const { Layout } = await import("./layout-DStNia_P-L25BT6O4.js");
        return {
          Component: Layout
        };
      },
      children: routes
    });
    app.registerPlugin(cm.config);
  },
  bootstrap(app) {
    if (typeof historyAdmin.bootstrap === "function") {
      historyAdmin.bootstrap(app);
    }
    if (typeof previewAdmin.bootstrap === "function") {
      previewAdmin.bootstrap(app);
    }
  },
  async registerTrads({ locales }) {
    const importedTrads = await Promise.all(locales.map((locale) => {
      return __variableDynamicImportRuntime1__(`./translations/${locale}.json`).then(({ default: data }) => {
        return {
          data: prefixPluginTranslations(data, PLUGIN_ID),
          locale
        };
      }).catch(() => {
        return {
          data: {},
          locale
        };
      });
    }));
    return Promise.resolve(importedTrads);
  }
};

export {
  require_mapValues2 as require_mapValues,
  require_prism,
  PERMISSIONS,
  InjectionZone,
  CREATOR_FIELDS,
  ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD,
  SINGLE_TYPES,
  COLLECTION_TYPES,
  useDocumentRBAC,
  DocumentRBAC,
  prepareTempKeys,
  removeFieldsThatDontExistOnSchema,
  transformDocument,
  createDefaultForm,
  contentManagerApi,
  useGetAllDocumentsQuery,
  buildValidParams,
  createYupSchema,
  useGetInitialDataQuery,
  useContentTypeSchema,
  extractContentTypeComponents,
  HOOKS,
  useGetContentTypeConfigurationQuery,
  useGetAllContentTypeSettingsQuery,
  useUpdateContentTypeConfigurationMutation,
  checkIfAttributeIsDisplayable,
  getMainField,
  DEFAULT_SETTINGS,
  useDocumentLayout,
  useDocLayout,
  convertEditLayoutToFieldLayouts,
  convertListLayoutToFieldLayouts,
  useDocument,
  useDoc,
  useContentManagerContext,
  getTranslation,
  useDocumentActions,
  CLONE_PATH,
  RelativeTime,
  getDisplayName,
  capitalise,
  DocumentStatus,
  Header,
  Panels,
  BulkActionsRenderer,
  TableActions,
  setInitialData,
  useGetPreviewUrlQuery,
  index
};
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=chunk-7EUVMRZZ.js.map
