{
  "version": 3,
  "sources": ["../../../@strapi/content-manager/admin/src/hooks/useDebounce.ts", "../../../@strapi/content-manager/admin/src/services/relations.ts", "../../../@strapi/content-manager/admin/src/utils/relations.ts"],
  "sourcesContent": ["import { useEffect, useState } from 'react';\n\nexport function useDebounce<TValue>(value: TValue, delay: number): TValue {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n", "import { generateNKeysBetween } from 'fractional-indexing';\n\nimport {\n  RelationResult as RelResult,\n  FindAvailable,\n  FindExisting,\n} from '../../../shared/contracts/relations';\n\nimport { contentManagerApi } from './api';\n\nimport type { Modules } from '@strapi/types';\nimport type { errors } from '@strapi/utils';\n\ninterface RelationResult extends RelResult {\n  __temp_key__: string;\n}\n\ntype GetRelationsResponse =\n  | {\n      results: Array<RelationResult>;\n      pagination: {\n        page: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['page']>;\n        pageSize: NonNullable<Modules.EntityService.Params.Pagination.PageNotation['pageSize']>;\n        pageCount: number;\n        total: number;\n      } | null;\n      error?: never;\n    }\n  | {\n      results?: never;\n      pagination?: never;\n      error: errors.ApplicationError | errors.YupValidationError;\n    };\n\nconst relationsApi = contentManagerApi.injectEndpoints({\n  endpoints: (build) => ({\n    getRelations: build.query<\n      GetRelationsResponse,\n      FindExisting.Params & {\n        params?: FindExisting.Request['query'];\n      }\n    >({\n      query: ({ model, id, targetField, params }) => {\n        return {\n          url: `/content-manager/relations/${model}/${id}/${targetField}`,\n          method: 'GET',\n          config: {\n            params,\n          },\n        };\n      },\n      serializeQueryArgs: (args) => {\n        const { endpointName, queryArgs } = args;\n        return {\n          endpointName,\n          model: queryArgs.model,\n          id: queryArgs.id,\n          targetField: queryArgs.targetField,\n          locale: queryArgs.params?.locale,\n          status: queryArgs.params?.status,\n        };\n      },\n      merge: (currentCache, newItems) => {\n        if (currentCache.pagination && newItems.pagination) {\n          if (currentCache.pagination.page < newItems.pagination.page) {\n            /**\n             * Relations will always have unique IDs, so we can therefore assume\n             * that we only need to push the new items to the cache.\n             *\n             * Push new items at the beginning as latest items are shown first\n             */\n            currentCache.results = [\n              ...prepareTempKeys(newItems.results, currentCache.results),\n              ...currentCache.results,\n            ];\n            currentCache.pagination = newItems.pagination;\n          } else if (newItems.pagination.page === 1) {\n            /**\n             * We're resetting the relations\n             */\n            currentCache.results = prepareTempKeys(newItems.results);\n            currentCache.pagination = newItems.pagination;\n          }\n        }\n      },\n      forceRefetch({ currentArg, previousArg }) {\n        if (!currentArg?.params && !previousArg?.params) {\n          return false;\n        }\n\n        return (\n          currentArg?.params?.page !== previousArg?.params?.page ||\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\n        );\n      },\n      transformResponse: (response: FindExisting.Response) => {\n        if ('results' in response && response.results) {\n          return {\n            ...response,\n            results: prepareTempKeys(response.results.toReversed()),\n          };\n        } else {\n          return response;\n        }\n      },\n      providesTags: ['Relations'],\n    }),\n    searchRelations: build.query<\n      FindAvailable.Response,\n      FindAvailable.Params & {\n        params?: FindAvailable.Request['query'];\n      }\n    >({\n      query: ({ model, targetField, params }) => {\n        return {\n          url: `/content-manager/relations/${model}/${targetField}`,\n          method: 'GET',\n          config: {\n            params,\n          },\n        };\n      },\n      serializeQueryArgs: (args) => {\n        const { endpointName, queryArgs } = args;\n        return {\n          endpointName,\n          model: queryArgs.model,\n          targetField: queryArgs.targetField,\n          _q: queryArgs.params?._q,\n          idsToOmit: queryArgs.params?.idsToOmit,\n          idsToInclude: queryArgs.params?.idsToInclude,\n        };\n      },\n      merge: (currentCache, newItems) => {\n        if (currentCache.pagination && newItems.pagination) {\n          if (currentCache.pagination.page < newItems.pagination.page) {\n            /**\n             * Relations will always have unique IDs, so we can therefore assume\n             * that we only need to push the new items to the cache.\n             */\n            const existingIds = currentCache.results.map((item) => item.documentId);\n            const uniqueNewItems = newItems.results.filter(\n              (item) => !existingIds.includes(item.documentId)\n            );\n            currentCache.results.push(...uniqueNewItems);\n            currentCache.pagination = newItems.pagination;\n          } else if (newItems.pagination.page === 1) {\n            /**\n             * We're resetting the relations\n             */\n            currentCache.results = newItems.results;\n            currentCache.pagination = newItems.pagination;\n          }\n        }\n      },\n      forceRefetch({ currentArg, previousArg }) {\n        if (!currentArg?.params && !previousArg?.params) {\n          return false;\n        }\n\n        return (\n          currentArg?.params?.page !== previousArg?.params?.page ||\n          currentArg?.params?.pageSize !== previousArg?.params?.pageSize\n        );\n      },\n      transformResponse: (response: FindAvailable.Response) => {\n        if (response.results) {\n          return {\n            ...response,\n            results: response.results,\n          };\n        } else {\n          return response;\n        }\n      },\n    }),\n  }),\n});\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each relation item. This gives us\n * a stable identifier regardless of it's ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = (relations: RelResult[], existingRelations: RelationResult[] = []) => {\n  const [firstItem] = existingRelations.slice(0);\n  const keys = generateNKeysBetween(null, firstItem?.__temp_key__ ?? null, relations.length);\n\n  return relations.map((datum, index) => ({\n    ...datum,\n    __temp_key__: keys[index],\n  }));\n};\n\nconst { useGetRelationsQuery, useLazySearchRelationsQuery } = relationsApi;\n\nexport { useGetRelationsQuery, useLazySearchRelationsQuery };\nexport type { RelationResult };\n", "import type { MainField } from './attributes';\nimport type { RelationResult } from '../../../shared/contracts/relations';\n\n/**\n * @internal\n * @description Get the label of a relation, the contract has [key: string]: unknown,\n * so we need to check if the mainFieldKey is defined and if the relation has a value\n * under that property. If it does, we then verify it's type of string and return it.\n *\n * We fallback to the documentId.\n */\nconst getRelationLabel = (relation: RelationResult, mainField?: MainField): string => {\n  const label = mainField && relation[mainField.name] ? relation[mainField.name] : null;\n\n  if (typeof label === 'string') {\n    return label;\n  }\n\n  return relation.documentId;\n};\n\nexport { getRelationLabel };\n"],
  "mappings": "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",
  "names": ["useDebounce", "value", "delay", "debouncedValue", "setDebouncedValue", "useState", "useEffect", "handler", "setTimeout", "clearTimeout", "relationsApi", "contentManagerApi", "injectEndpoints", "endpoints", "build", "getRelations", "query", "model", "id", "targetField", "params", "url", "method", "config", "serializeQueryArgs", "args", "endpointName", "queryArgs", "locale", "status", "merge", "currentCache", "newItems", "pagination", "page", "results", "prepareTempKeys", "forceRefetch", "currentArg", "previousArg", "pageSize", "transformResponse", "response", "toReversed", "providesTags", "searchRelations", "_q", "idsToOmit", "idsToInclude", "existingIds", "map", "item", "documentId", "uniqueNewItems", "filter", "includes", "push", "relations", "existingRelations", "firstItem", "slice", "keys", "generateNKeysBetween", "__temp_key__", "length", "datum", "index", "useGetRelationsQuery", "useLazySearchRelationsQuery", "getRelationLabel", "relation", "mainField", "label", "name"]
}
