import {
  require_escape_string_regexp
} from "./chunk-IDV2IX4L.js";
import {
  require_pluralize
} from "./chunk-JKSD74O7.js";
import {
  require_cloneDeep
} from "./chunk-MJ6P67TK.js";
import {
  create6 as create,
  require_snakeCase
} from "./chunk-RWGGLXMY.js";
import {
  require_set
} from "./chunk-SNGAK6QT.js";
import {
  Box,
  Flex,
  Link,
  R,
  Typography,
  createSlice,
  require_get,
  useIntl
} from "./chunk-Y2P3SHYJ.js";
import {
  require_react_dom
} from "./chunk-XUW2YTNL.js";
import {
  ForwardRef$2r,
  ForwardRef$4l,
  ForwardRef$5b
} from "./chunk-TKMBRDQV.js";
import {
  require_jsx_runtime
} from "./chunk-GOQBQZHW.js";
import {
  dt,
  mt
} from "./chunk-GO6TWMX3.js";
import {
  require_react
} from "./chunk-MTZNWPB2.js";
import {
  __commonJS,
  __toESM
} from "./chunk-GFT2G5UO.js";

// node_modules/lodash.deburr/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.deburr/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol = root.Symbol;
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements = __commonJS({
  "node_modules/@sindresorhus/transliterate/replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      // German umlauts
      ["ß", "ss"],
      ["ä", "ae"],
      ["Ä", "Ae"],
      ["ö", "oe"],
      ["Ö", "Oe"],
      ["ü", "ue"],
      ["Ü", "Ue"],
      // Latin
      ["À", "A"],
      ["Á", "A"],
      ["Â", "A"],
      ["Ã", "A"],
      ["Ä", "Ae"],
      ["Å", "A"],
      ["Æ", "AE"],
      ["Ç", "C"],
      ["È", "E"],
      ["É", "E"],
      ["Ê", "E"],
      ["Ë", "E"],
      ["Ì", "I"],
      ["Í", "I"],
      ["Î", "I"],
      ["Ï", "I"],
      ["Ð", "D"],
      ["Ñ", "N"],
      ["Ò", "O"],
      ["Ó", "O"],
      ["Ô", "O"],
      ["Õ", "O"],
      ["Ö", "Oe"],
      ["Ő", "O"],
      ["Ø", "O"],
      ["Ù", "U"],
      ["Ú", "U"],
      ["Û", "U"],
      ["Ü", "Ue"],
      ["Ű", "U"],
      ["Ý", "Y"],
      ["Þ", "TH"],
      ["ß", "ss"],
      ["à", "a"],
      ["á", "a"],
      ["â", "a"],
      ["ã", "a"],
      ["ä", "ae"],
      ["å", "a"],
      ["æ", "ae"],
      ["ç", "c"],
      ["è", "e"],
      ["é", "e"],
      ["ê", "e"],
      ["ë", "e"],
      ["ì", "i"],
      ["í", "i"],
      ["î", "i"],
      ["ï", "i"],
      ["ð", "d"],
      ["ñ", "n"],
      ["ò", "o"],
      ["ó", "o"],
      ["ô", "o"],
      ["õ", "o"],
      ["ö", "oe"],
      ["ő", "o"],
      ["ø", "o"],
      ["ù", "u"],
      ["ú", "u"],
      ["û", "u"],
      ["ü", "ue"],
      ["ű", "u"],
      ["ý", "y"],
      ["þ", "th"],
      ["ÿ", "y"],
      ["ẞ", "SS"],
      // Vietnamese
      ["à", "a"],
      ["À", "A"],
      ["á", "a"],
      ["Á", "A"],
      ["â", "a"],
      ["Â", "A"],
      ["ã", "a"],
      ["Ã", "A"],
      ["è", "e"],
      ["È", "E"],
      ["é", "e"],
      ["É", "E"],
      ["ê", "e"],
      ["Ê", "E"],
      ["ì", "i"],
      ["Ì", "I"],
      ["í", "i"],
      ["Í", "I"],
      ["ò", "o"],
      ["Ò", "O"],
      ["ó", "o"],
      ["Ó", "O"],
      ["ô", "o"],
      ["Ô", "O"],
      ["õ", "o"],
      ["Õ", "O"],
      ["ù", "u"],
      ["Ù", "U"],
      ["ú", "u"],
      ["Ú", "U"],
      ["ý", "y"],
      ["Ý", "Y"],
      ["ă", "a"],
      ["Ă", "A"],
      ["Đ", "D"],
      ["đ", "d"],
      ["ĩ", "i"],
      ["Ĩ", "I"],
      ["ũ", "u"],
      ["Ũ", "U"],
      ["ơ", "o"],
      ["Ơ", "O"],
      ["ư", "u"],
      ["Ư", "U"],
      ["ạ", "a"],
      ["Ạ", "A"],
      ["ả", "a"],
      ["Ả", "A"],
      ["ấ", "a"],
      ["Ấ", "A"],
      ["ầ", "a"],
      ["Ầ", "A"],
      ["ẩ", "a"],
      ["Ẩ", "A"],
      ["ẫ", "a"],
      ["Ẫ", "A"],
      ["ậ", "a"],
      ["Ậ", "A"],
      ["ắ", "a"],
      ["Ắ", "A"],
      ["ằ", "a"],
      ["Ằ", "A"],
      ["ẳ", "a"],
      ["Ẳ", "A"],
      ["ẵ", "a"],
      ["Ẵ", "A"],
      ["ặ", "a"],
      ["Ặ", "A"],
      ["ẹ", "e"],
      ["Ẹ", "E"],
      ["ẻ", "e"],
      ["Ẻ", "E"],
      ["ẽ", "e"],
      ["Ẽ", "E"],
      ["ế", "e"],
      ["Ế", "E"],
      ["ề", "e"],
      ["Ề", "E"],
      ["ể", "e"],
      ["Ể", "E"],
      ["ễ", "e"],
      ["Ễ", "E"],
      ["ệ", "e"],
      ["Ệ", "E"],
      ["ỉ", "i"],
      ["Ỉ", "I"],
      ["ị", "i"],
      ["Ị", "I"],
      ["ọ", "o"],
      ["Ọ", "O"],
      ["ỏ", "o"],
      ["Ỏ", "O"],
      ["ố", "o"],
      ["Ố", "O"],
      ["ồ", "o"],
      ["Ồ", "O"],
      ["ổ", "o"],
      ["Ổ", "O"],
      ["ỗ", "o"],
      ["Ỗ", "O"],
      ["ộ", "o"],
      ["Ộ", "O"],
      ["ớ", "o"],
      ["Ớ", "O"],
      ["ờ", "o"],
      ["Ờ", "O"],
      ["ở", "o"],
      ["Ở", "O"],
      ["ỡ", "o"],
      ["Ỡ", "O"],
      ["ợ", "o"],
      ["Ợ", "O"],
      ["ụ", "u"],
      ["Ụ", "U"],
      ["ủ", "u"],
      ["Ủ", "U"],
      ["ứ", "u"],
      ["Ứ", "U"],
      ["ừ", "u"],
      ["Ừ", "U"],
      ["ử", "u"],
      ["Ử", "U"],
      ["ữ", "u"],
      ["Ữ", "U"],
      ["ự", "u"],
      ["Ự", "U"],
      ["ỳ", "y"],
      ["Ỳ", "Y"],
      ["ỵ", "y"],
      ["Ỵ", "Y"],
      ["ỷ", "y"],
      ["Ỷ", "Y"],
      ["ỹ", "y"],
      ["Ỹ", "Y"],
      // Arabic
      ["ء", "e"],
      ["آ", "a"],
      ["أ", "a"],
      ["ؤ", "w"],
      ["إ", "i"],
      ["ئ", "y"],
      ["ا", "a"],
      ["ب", "b"],
      ["ة", "t"],
      ["ت", "t"],
      ["ث", "th"],
      ["ج", "j"],
      ["ح", "h"],
      ["خ", "kh"],
      ["د", "d"],
      ["ذ", "dh"],
      ["ر", "r"],
      ["ز", "z"],
      ["س", "s"],
      ["ش", "sh"],
      ["ص", "s"],
      ["ض", "d"],
      ["ط", "t"],
      ["ظ", "z"],
      ["ع", "e"],
      ["غ", "gh"],
      ["ـ", "_"],
      ["ف", "f"],
      ["ق", "q"],
      ["ك", "k"],
      ["ل", "l"],
      ["م", "m"],
      ["ن", "n"],
      ["ه", "h"],
      ["و", "w"],
      ["ى", "a"],
      ["ي", "y"],
      ["َ‎", "a"],
      ["ُ", "u"],
      ["ِ‎", "i"],
      ["٠", "0"],
      ["١", "1"],
      ["٢", "2"],
      ["٣", "3"],
      ["٤", "4"],
      ["٥", "5"],
      ["٦", "6"],
      ["٧", "7"],
      ["٨", "8"],
      ["٩", "9"],
      // Persian / Farsi
      ["چ", "ch"],
      ["ک", "k"],
      ["گ", "g"],
      ["پ", "p"],
      ["ژ", "zh"],
      ["ی", "y"],
      ["۰", "0"],
      ["۱", "1"],
      ["۲", "2"],
      ["۳", "3"],
      ["۴", "4"],
      ["۵", "5"],
      ["۶", "6"],
      ["۷", "7"],
      ["۸", "8"],
      ["۹", "9"],
      // Pashto
      ["ټ", "p"],
      ["ځ", "z"],
      ["څ", "c"],
      ["ډ", "d"],
      ["ﺫ", "d"],
      ["ﺭ", "r"],
      ["ړ", "r"],
      ["ﺯ", "z"],
      ["ږ", "g"],
      ["ښ", "x"],
      ["ګ", "g"],
      ["ڼ", "n"],
      ["ۀ", "e"],
      ["ې", "e"],
      ["ۍ", "ai"],
      // Urdu
      ["ٹ", "t"],
      ["ڈ", "d"],
      ["ڑ", "r"],
      ["ں", "n"],
      ["ہ", "h"],
      ["ھ", "h"],
      ["ے", "e"],
      // Russian
      ["А", "A"],
      ["а", "a"],
      ["Б", "B"],
      ["б", "b"],
      ["В", "V"],
      ["в", "v"],
      ["Г", "G"],
      ["г", "g"],
      ["Д", "D"],
      ["д", "d"],
      ["Е", "E"],
      ["е", "e"],
      ["Ж", "Zh"],
      ["ж", "zh"],
      ["З", "Z"],
      ["з", "z"],
      ["И", "I"],
      ["и", "i"],
      ["Й", "J"],
      ["й", "j"],
      ["К", "K"],
      ["к", "k"],
      ["Л", "L"],
      ["л", "l"],
      ["М", "M"],
      ["м", "m"],
      ["Н", "N"],
      ["н", "n"],
      ["О", "O"],
      ["о", "o"],
      ["П", "P"],
      ["п", "p"],
      ["Р", "R"],
      ["р", "r"],
      ["С", "S"],
      ["с", "s"],
      ["Т", "T"],
      ["т", "t"],
      ["У", "U"],
      ["у", "u"],
      ["Ф", "F"],
      ["ф", "f"],
      ["Х", "H"],
      ["х", "h"],
      ["Ц", "Cz"],
      ["ц", "cz"],
      ["Ч", "Ch"],
      ["ч", "ch"],
      ["Ш", "Sh"],
      ["ш", "sh"],
      ["Щ", "Shh"],
      ["щ", "shh"],
      ["Ъ", ""],
      ["ъ", ""],
      ["Ы", "Y"],
      ["ы", "y"],
      ["Ь", ""],
      ["ь", ""],
      ["Э", "E"],
      ["э", "e"],
      ["Ю", "Yu"],
      ["ю", "yu"],
      ["Я", "Ya"],
      ["я", "ya"],
      ["Ё", "Yo"],
      ["ё", "yo"],
      // Romanian
      ["ă", "a"],
      ["Ă", "A"],
      ["ș", "s"],
      ["Ș", "S"],
      ["ț", "t"],
      ["Ț", "T"],
      ["ţ", "t"],
      ["Ţ", "T"],
      // Turkish
      ["ş", "s"],
      ["Ş", "S"],
      ["ç", "c"],
      ["Ç", "C"],
      ["ğ", "g"],
      ["Ğ", "G"],
      ["ı", "i"],
      ["İ", "I"],
      // Armenian
      ["ա", "a"],
      ["Ա", "A"],
      ["բ", "b"],
      ["Բ", "B"],
      ["գ", "g"],
      ["Գ", "G"],
      ["դ", "d"],
      ["Դ", "D"],
      ["ե", "ye"],
      ["Ե", "Ye"],
      ["զ", "z"],
      ["Զ", "Z"],
      ["է", "e"],
      ["Է", "E"],
      ["ը", "y"],
      ["Ը", "Y"],
      ["թ", "t"],
      ["Թ", "T"],
      ["ժ", "zh"],
      ["Ժ", "Zh"],
      ["ի", "i"],
      ["Ի", "I"],
      ["լ", "l"],
      ["Լ", "L"],
      ["խ", "kh"],
      ["Խ", "Kh"],
      ["ծ", "ts"],
      ["Ծ", "Ts"],
      ["կ", "k"],
      ["Կ", "K"],
      ["հ", "h"],
      ["Հ", "H"],
      ["ձ", "dz"],
      ["Ձ", "Dz"],
      ["ղ", "gh"],
      ["Ղ", "Gh"],
      ["ճ", "tch"],
      ["Ճ", "Tch"],
      ["մ", "m"],
      ["Մ", "M"],
      ["յ", "y"],
      ["Յ", "Y"],
      ["ն", "n"],
      ["Ն", "N"],
      ["շ", "sh"],
      ["Շ", "Sh"],
      ["ո", "vo"],
      ["Ո", "Vo"],
      ["չ", "ch"],
      ["Չ", "Ch"],
      ["պ", "p"],
      ["Պ", "P"],
      ["ջ", "j"],
      ["Ջ", "J"],
      ["ռ", "r"],
      ["Ռ", "R"],
      ["ս", "s"],
      ["Ս", "S"],
      ["վ", "v"],
      ["Վ", "V"],
      ["տ", "t"],
      ["Տ", "T"],
      ["ր", "r"],
      ["Ր", "R"],
      ["ց", "c"],
      ["Ց", "C"],
      ["ու", "u"],
      ["ՈՒ", "U"],
      ["Ու", "U"],
      ["փ", "p"],
      ["Փ", "P"],
      ["ք", "q"],
      ["Ք", "Q"],
      ["օ", "o"],
      ["Օ", "O"],
      ["ֆ", "f"],
      ["Ֆ", "F"],
      ["և", "yev"],
      // Georgian
      ["ა", "a"],
      ["ბ", "b"],
      ["გ", "g"],
      ["დ", "d"],
      ["ე", "e"],
      ["ვ", "v"],
      ["ზ", "z"],
      ["თ", "t"],
      ["ი", "i"],
      ["კ", "k"],
      ["ლ", "l"],
      ["მ", "m"],
      ["ნ", "n"],
      ["ო", "o"],
      ["პ", "p"],
      ["ჟ", "zh"],
      ["რ", "r"],
      ["ს", "s"],
      ["ტ", "t"],
      ["უ", "u"],
      ["ფ", "ph"],
      ["ქ", "q"],
      ["ღ", "gh"],
      ["ყ", "k"],
      ["შ", "sh"],
      ["ჩ", "ch"],
      ["ც", "ts"],
      ["ძ", "dz"],
      ["წ", "ts"],
      ["ჭ", "tch"],
      ["ხ", "kh"],
      ["ჯ", "j"],
      ["ჰ", "h"],
      // Czech
      ["č", "c"],
      ["ď", "d"],
      ["ě", "e"],
      ["ň", "n"],
      ["ř", "r"],
      ["š", "s"],
      ["ť", "t"],
      ["ů", "u"],
      ["ž", "z"],
      ["Č", "C"],
      ["Ď", "D"],
      ["Ě", "E"],
      ["Ň", "N"],
      ["Ř", "R"],
      ["Š", "S"],
      ["Ť", "T"],
      ["Ů", "U"],
      ["Ž", "Z"],
      // Dhivehi
      ["ހ", "h"],
      ["ށ", "sh"],
      ["ނ", "n"],
      ["ރ", "r"],
      ["ބ", "b"],
      ["ޅ", "lh"],
      ["ކ", "k"],
      ["އ", "a"],
      ["ވ", "v"],
      ["މ", "m"],
      ["ފ", "f"],
      ["ދ", "dh"],
      ["ތ", "th"],
      ["ލ", "l"],
      ["ގ", "g"],
      ["ޏ", "gn"],
      ["ސ", "s"],
      ["ޑ", "d"],
      ["ޒ", "z"],
      ["ޓ", "t"],
      ["ޔ", "y"],
      ["ޕ", "p"],
      ["ޖ", "j"],
      ["ޗ", "ch"],
      ["ޘ", "tt"],
      ["ޙ", "hh"],
      ["ޚ", "kh"],
      ["ޛ", "th"],
      ["ޜ", "z"],
      ["ޝ", "sh"],
      ["ޞ", "s"],
      ["ޟ", "d"],
      ["ޠ", "t"],
      ["ޡ", "z"],
      ["ޢ", "a"],
      ["ޣ", "gh"],
      ["ޤ", "q"],
      ["ޥ", "w"],
      ["ަ", "a"],
      ["ާ", "aa"],
      ["ި", "i"],
      ["ީ", "ee"],
      ["ު", "u"],
      ["ޫ", "oo"],
      ["ެ", "e"],
      ["ޭ", "ey"],
      ["ޮ", "o"],
      ["ޯ", "oa"],
      ["ް", ""],
      // Greek
      ["α", "a"],
      ["β", "v"],
      ["γ", "g"],
      ["δ", "d"],
      ["ε", "e"],
      ["ζ", "z"],
      ["η", "i"],
      ["θ", "th"],
      ["ι", "i"],
      ["κ", "k"],
      ["λ", "l"],
      ["μ", "m"],
      ["ν", "n"],
      ["ξ", "ks"],
      ["ο", "o"],
      ["π", "p"],
      ["ρ", "r"],
      ["σ", "s"],
      ["τ", "t"],
      ["υ", "y"],
      ["φ", "f"],
      ["χ", "x"],
      ["ψ", "ps"],
      ["ω", "o"],
      ["ά", "a"],
      ["έ", "e"],
      ["ί", "i"],
      ["ό", "o"],
      ["ύ", "y"],
      ["ή", "i"],
      ["ώ", "o"],
      ["ς", "s"],
      ["ϊ", "i"],
      ["ΰ", "y"],
      ["ϋ", "y"],
      ["ΐ", "i"],
      ["Α", "A"],
      ["Β", "B"],
      ["Γ", "G"],
      ["Δ", "D"],
      ["Ε", "E"],
      ["Ζ", "Z"],
      ["Η", "I"],
      ["Θ", "TH"],
      ["Ι", "I"],
      ["Κ", "K"],
      ["Λ", "L"],
      ["Μ", "M"],
      ["Ν", "N"],
      ["Ξ", "KS"],
      ["Ο", "O"],
      ["Π", "P"],
      ["Ρ", "R"],
      ["Σ", "S"],
      ["Τ", "T"],
      ["Υ", "Y"],
      ["Φ", "F"],
      ["Χ", "X"],
      ["Ψ", "PS"],
      ["Ω", "O"],
      ["Ά", "A"],
      ["Έ", "E"],
      ["Ί", "I"],
      ["Ό", "O"],
      ["Ύ", "Y"],
      ["Ή", "I"],
      ["Ώ", "O"],
      ["Ϊ", "I"],
      ["Ϋ", "Y"],
      // Disabled as it conflicts with German and Latin.
      // Hungarian
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // ['ü', 'u'],
      // ['Ü', 'U'],
      // ['ű', 'u'],
      // ['Ű', 'U'],
      // Latvian
      ["ā", "a"],
      ["ē", "e"],
      ["ģ", "g"],
      ["ī", "i"],
      ["ķ", "k"],
      ["ļ", "l"],
      ["ņ", "n"],
      ["ū", "u"],
      ["Ā", "A"],
      ["Ē", "E"],
      ["Ģ", "G"],
      ["Ī", "I"],
      ["Ķ", "K"],
      ["Ļ", "L"],
      ["Ņ", "N"],
      ["Ū", "U"],
      ["č", "c"],
      ["š", "s"],
      ["ž", "z"],
      ["Č", "C"],
      ["Š", "S"],
      ["Ž", "Z"],
      // Lithuanian
      ["ą", "a"],
      ["č", "c"],
      ["ę", "e"],
      ["ė", "e"],
      ["į", "i"],
      ["š", "s"],
      ["ų", "u"],
      ["ū", "u"],
      ["ž", "z"],
      ["Ą", "A"],
      ["Č", "C"],
      ["Ę", "E"],
      ["Ė", "E"],
      ["Į", "I"],
      ["Š", "S"],
      ["Ų", "U"],
      ["Ū", "U"],
      // Macedonian
      ["Ќ", "Kj"],
      ["ќ", "kj"],
      ["Љ", "Lj"],
      ["љ", "lj"],
      ["Њ", "Nj"],
      ["њ", "nj"],
      ["Тс", "Ts"],
      ["тс", "ts"],
      // Polish
      ["ą", "a"],
      ["ć", "c"],
      ["ę", "e"],
      ["ł", "l"],
      ["ń", "n"],
      ["ś", "s"],
      ["ź", "z"],
      ["ż", "z"],
      ["Ą", "A"],
      ["Ć", "C"],
      ["Ę", "E"],
      ["Ł", "L"],
      ["Ń", "N"],
      ["Ś", "S"],
      ["Ź", "Z"],
      ["Ż", "Z"],
      // Disabled as it conflicts with Vietnamese.
      // Serbian
      // ['љ', 'lj'],
      // ['њ', 'nj'],
      // ['Љ', 'Lj'],
      // ['Њ', 'Nj'],
      // ['đ', 'dj'],
      // ['Đ', 'Dj'],
      // ['ђ', 'dj'],
      // ['ј', 'j'],
      // ['ћ', 'c'],
      // ['џ', 'dz'],
      // ['Ђ', 'Dj'],
      // ['Ј', 'j'],
      // ['Ћ', 'C'],
      // ['Џ', 'Dz'],
      // Disabled as it conflicts with German and Latin.
      // Slovak
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ľ', 'l'],
      // ['ĺ', 'l'],
      // ['ŕ', 'r'],
      // ['Ľ', 'L'],
      // ['Ĺ', 'L'],
      // ['Ŕ', 'R'],
      // Disabled as it conflicts with German and Latin.
      // Swedish
      // ['å', 'o'],
      // ['Å', 'o'],
      // ['ä', 'a'],
      // ['Ä', 'A'],
      // ['ë', 'e'],
      // ['Ë', 'E'],
      // ['ö', 'o'],
      // ['Ö', 'O'],
      // Ukrainian
      ["Є", "Ye"],
      ["І", "I"],
      ["Ї", "Yi"],
      ["Ґ", "G"],
      ["є", "ye"],
      ["і", "i"],
      ["ї", "yi"],
      ["ґ", "g"]
      // Danish
      // ['Æ', 'Ae'],
      // ['Ø', 'Oe'],
      // ['Å', 'Aa'],
      // ['æ', 'ae'],
      // ['ø', 'oe'],
      // ['å', 'aa']
    ];
  }
});

// node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS({
  "node_modules/@sindresorhus/transliterate/index.js"(exports, module) {
    "use strict";
    var deburr = require_lodash();
    var escapeStringRegexp = require_escape_string_regexp2();
    var builtinReplacements = require_replacements();
    var doCustomReplacements = (string, replacements) => {
      for (const [key, value] of replacements) {
        string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
      }
      return string;
    };
    module.exports = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        customReplacements: [],
        ...options
      };
      const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
      ]);
      string = string.normalize();
      string = doCustomReplacements(string, customReplacements);
      string = deburr(string);
      return string;
    };
  }
});

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS({
  "node_modules/@sindresorhus/slugify/overridable-replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      ["&", " and "],
      ["🦄", " unicorn "],
      ["♥", " love "]
    ];
  }
});

// node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS({
  "node_modules/@sindresorhus/slugify/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var transliterate = require_transliterate();
    var builtinOverridableReplacements = require_overridable_replacements();
    var decamelize = (string) => {
      return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
    };
    var removeMootSeparators = (string, separator) => {
      const escapedSeparator = escapeStringRegexp(separator);
      return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
    };
    var slugify2 = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        ...options
      };
      const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
      const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
      ]);
      string = transliterate(string, { customReplacements });
      if (options.decamelize) {
        string = decamelize(string);
      }
      let patternSlug = /[^a-zA-Z\d]+/g;
      if (options.lowercase) {
        string = string.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
      }
      string = string.replace(patternSlug, options.separator);
      string = string.replace(/\\/g, "");
      if (options.separator) {
        string = removeMootSeparators(string, options.separator);
      }
      if (shouldPrependUnderscore) {
        string = `_${string}`;
      }
      return string;
    };
    var counter = () => {
      const occurrences = /* @__PURE__ */ new Map();
      const countable = (string, options) => {
        string = slugify2(string, options);
        if (!string) {
          return "";
        }
        const stringLower = string.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter2 = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter2 === "number" ? counter2 + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
          string = `${string}-${newCounter}`;
        }
        return string;
      };
      countable.reset = () => {
        occurrences.clear();
      };
      return countable;
    };
    module.exports = slugify2;
    module.exports.counter = counter;
  }
});

// node_modules/@strapi/content-type-builder/dist/admin/chunks/index-BhX2euW0.mjs
var import_get = __toESM(require_get(), 1);
var import_set = __toESM(require_set(), 1);
var import_snakeCase = __toESM(require_snakeCase(), 1);
var import_pluralize = __toESM(require_pluralize(), 1);
var import_slugify = __toESM(require_slugify(), 1);
var import_cloneDeep = __toESM(require_cloneDeep(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var PERMISSIONS = {
  // This permission regards the main component (App) and is used to tell
  // If the plugin link should be displayed in the menu
  // And also if the plugin is accessible. This use case is found when a user types the url of the
  // plugin directly in the browser
  main: [
    {
      action: "plugin::content-type-builder.read",
      subject: null
    }
  ]
};
var MAX_COMPONENT_DEPTH = 6;
var pluginId = "content-type-builder";
var getRelationType = (relation, targetAttribute) => {
  const hasNotTargetAttribute = targetAttribute === void 0 || targetAttribute === null;
  if (relation === "oneToOne" && hasNotTargetAttribute) {
    return "oneWay";
  }
  if (relation === "oneToMany" && hasNotTargetAttribute) {
    return "manyWay";
  }
  return relation;
};
var makeUnique = (array) => [
  ...new Set(array)
];
var retrieveComponentsFromSchema = (attributes, allComponentsData) => {
  const allComponents = attributes.reduce((acc, current) => {
    const type = current.type;
    if (type === "component") {
      const currentComponentName = current.component;
      acc.push(currentComponentName);
      const currentComponentAttributes = (0, import_get.default)(allComponentsData, [
        currentComponentName,
        "schema",
        "attributes"
      ], []);
      acc.push(...retrieveComponentsFromSchema(currentComponentAttributes, allComponentsData));
    }
    if (type === "dynamiczone") {
      const dynamicZoneComponents = current.components;
      const componentsFromDZComponents = dynamicZoneComponents.reduce((acc2, currentUid) => {
        const compoAttrs = (0, import_get.default)(allComponentsData, [
          currentUid,
          "schema",
          "attributes"
        ], []);
        return [
          ...acc2,
          ...retrieveComponentsFromSchema(compoAttrs, allComponentsData)
        ];
      }, []);
      return [
        ...acc,
        ...dynamicZoneComponents,
        ...componentsFromDZComponents
      ];
    }
    return acc;
  }, []);
  return makeUnique(allComponents);
};
var DEFAULT_MODIFIED_DATA = {
  components: {},
  contentTypes: {}
};
var initialState$1 = {
  components: {},
  contentTypes: {},
  initialComponents: {},
  initialContentTypes: {},
  initialData: {},
  modifiedData: {
    ...DEFAULT_MODIFIED_DATA
  },
  reservedNames: {},
  isLoading: true
};
var ONE_SIDE_RELATIONS = [
  "oneWay",
  "manyWay"
];
var getOppositeRelation = (originalRelation) => {
  if (originalRelation === "manyToOne") {
    return "oneToMany";
  }
  if (originalRelation === "oneToMany") {
    return "manyToOne";
  }
  return originalRelation;
};
var findAttributeIndex = (schema, attributeToFind) => {
  return schema.schema.attributes.findIndex(({ name }) => name === attributeToFind);
};
var slice$1 = createSlice({
  name: "data-manager",
  initialState: initialState$1,
  reducers: {
    init: (state, action) => {
      const { components, contentTypes, reservedNames } = action.payload;
      state.components = components;
      state.initialComponents = components;
      state.initialContentTypes = contentTypes;
      state.contentTypes = contentTypes;
      state.reservedNames = reservedNames;
      state.isLoading = false;
      state.modifiedData = {
        ...DEFAULT_MODIFIED_DATA,
        component: state.modifiedData.component ? components[state.modifiedData.component.uid] : void 0,
        contentType: state.modifiedData.contentType ? contentTypes[state.modifiedData.contentType.uid] : void 0,
        components: state.modifiedData.components ? Object.keys(state.modifiedData.components).reduce((acc, key) => {
          acc[key] = components[key];
          return acc;
        }, {}) : {},
        contentTypes: state.modifiedData.contentTypes ? Object.keys(state.modifiedData.contentTypes).reduce((acc, key) => {
          acc[key] = contentTypes[key];
          return acc;
        }, {}) : {}
      };
      state.initialData = state.modifiedData;
    },
    addAttribute: (state, action) => {
      var _a;
      const { attributeToSet, forTarget, targetUid, shouldAddComponentToData } = action.payload;
      const { name, ...rest } = attributeToSet;
      delete rest.createComponent;
      const pathToDataToEdit = [
        "component",
        "contentType"
      ].includes(forTarget) ? [
        forTarget
      ] : [
        forTarget,
        targetUid
      ];
      const currentAttributes = (0, import_get.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes"
      ], []).slice();
      const updatedAttributes = [
        ...currentAttributes,
        {
          ...rest,
          name
        }
      ];
      (0, import_set.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes"
      ], updatedAttributes);
      if (shouldAddComponentToData) {
        const componentToAddUID = rest.component;
        const componentToAdd = state.components[componentToAddUID];
        const isTemporaryComponent = componentToAdd == null ? void 0 : componentToAdd.isTemporary;
        const hasComponentAlreadyBeenAdded = ((_a = state.modifiedData.components) == null ? void 0 : _a[componentToAddUID]) !== void 0;
        if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {
          return;
        }
        if (!state.modifiedData.components) {
          state.modifiedData.components = {};
        }
        state.modifiedData.components[componentToAddUID] = componentToAdd;
        const nestedComponents = retrieveComponentsFromSchema(componentToAdd.schema.attributes, state.components);
        const nestedComponentsToAddInModifiedData = nestedComponents.filter((compoUID) => {
          return (0, import_get.default)(state, [
            "modifiedData",
            "components",
            compoUID
          ]) === void 0;
        });
        nestedComponentsToAddInModifiedData.forEach((compoUID) => {
          const compoSchema = (0, import_get.default)(state, [
            "components",
            compoUID
          ], {});
          const isTemporary = compoSchema.isTemporary || false;
          if (!isTemporary) {
            if (!state.modifiedData.components) {
              state.modifiedData.components = {};
            }
            state.modifiedData.components[compoUID] = compoSchema;
          }
        });
        return;
      }
      const isCreatingRelationAttribute = rest.type === "relation";
      if (isCreatingRelationAttribute) {
        const target = rest.target;
        const targetAttribute = rest.targetAttribute || null;
        const relation = rest.relation;
        const relationType = getRelationType(relation, targetAttribute);
        const currentUid = (0, import_get.default)(state, [
          "modifiedData",
          ...pathToDataToEdit,
          "uid"
        ]);
        if (rest.type === "relation" && relationType !== "oneWay" && relationType !== "manyWay" && target === currentUid) {
          const oppositeAttribute = {
            name: targetAttribute,
            relation: getOppositeRelation(relationType),
            target,
            targetAttribute: name,
            type: "relation"
          };
          if (rest.private) {
            oppositeAttribute.private = rest.private;
          }
          const attributesToSet = [
            ...updatedAttributes,
            oppositeAttribute
          ];
          (0, import_set.default)(state, [
            "modifiedData",
            ...pathToDataToEdit,
            "schema",
            "attributes"
          ], attributesToSet);
        }
      }
    },
    addCreatedComponentToDynamicZone: (state, action) => {
      const { dynamicZoneTarget, componentsToAdd } = action.payload;
      const dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, dynamicZoneTarget);
      componentsToAdd.forEach((componentUid) => {
        if (!state.modifiedData.contentType) {
          return;
        }
        if (!state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components) {
          state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components = [];
        }
        state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.push(componentUid);
      });
    },
    addCustomFieldAttribute: (state, action) => {
      const { attributeToSet, forTarget, targetUid } = action.payload;
      const { name, ...rest } = attributeToSet;
      const pathToDataToEdit = [
        "component",
        "contentType"
      ].includes(forTarget) ? [
        forTarget
      ] : [
        forTarget,
        targetUid
      ];
      const currentAttributes = (0, import_get.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes"
      ], []).slice();
      const updatedAttributes = [
        ...currentAttributes,
        {
          ...rest,
          name
        }
      ];
      (0, import_set.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes"
      ], updatedAttributes);
    },
    changeDynamicZoneComponents: (state, action) => {
      var _a, _b, _c;
      const { dynamicZoneTarget, newComponents } = action.payload;
      const dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, dynamicZoneTarget);
      const currentDZComponents = ((_a = state.modifiedData.contentType) == null ? void 0 : _a.schema.attributes[dzAttributeIndex]).components;
      const updatedComponents = makeUnique([
        ...currentDZComponents,
        ...newComponents
      ]);
      ((_b = state.modifiedData.contentType) == null ? void 0 : _b.schema.attributes[dzAttributeIndex]).components = updatedComponents;
      const nestedComponents = retrieveComponentsFromSchema(R((_c = state.modifiedData.contentType) == null ? void 0 : _c.schema.attributes), state.components);
      const nestedComponentsToAddInModifiedData = nestedComponents.filter((compoUID) => {
        return (0, import_get.default)(state, [
          "modifiedData",
          "components",
          compoUID
        ]) === void 0;
      });
      nestedComponentsToAddInModifiedData.forEach((compoUID) => {
        const compoSchema = (0, import_get.default)(state, [
          "components",
          compoUID
        ], {});
        const isTemporary = compoSchema.isTemporary || false;
        if (!isTemporary) {
          if (!state.modifiedData.components) {
            state.modifiedData.components = {};
          }
          state.modifiedData.components[compoUID] = compoSchema;
        }
      });
    },
    createComponentSchema: (state, action) => {
      const { uid, data, componentCategory, shouldAddComponentToData } = action.payload;
      const newSchema = {
        uid,
        isTemporary: true,
        category: componentCategory,
        schema: {
          ...data,
          attributes: []
        }
      };
      state.components[uid] = newSchema;
      if (shouldAddComponentToData) {
        state.modifiedData.components[uid] = newSchema;
      }
    },
    createSchema: (state, action) => {
      const { uid, data } = action.payload;
      const newSchema = {
        uid,
        isTemporary: true,
        schema: {
          ...data,
          attributes: []
        }
      };
      state.contentTypes[uid] = newSchema;
    },
    editAttribute: (state, action) => {
      const { attributeToSet, forTarget, targetUid, initialAttribute } = action.payload;
      const { name, ...rest } = attributeToSet;
      const initialAttributeName = initialAttribute.name;
      const pathToDataToEdit = [
        "component",
        "contentType"
      ].includes(forTarget) ? [
        forTarget
      ] : [
        forTarget,
        targetUid
      ];
      const initialAttributeIndex = findAttributeIndex((0, import_get.default)(state, [
        "modifiedData",
        ...pathToDataToEdit
      ]), initialAttributeName);
      const isEditingRelation = rest.type === "relation";
      if (!isEditingRelation) {
        (0, import_set.default)(state, [
          "modifiedData",
          ...pathToDataToEdit,
          "schema",
          "attributes",
          initialAttributeIndex
        ], attributeToSet);
        return;
      }
      const updatedAttributes = (0, import_get.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes"
      ]).slice();
      const toSet = {
        name,
        relation: rest.relation,
        target: rest.target,
        targetAttribute: rest.targetAttribute,
        type: "relation"
      };
      if (rest.private) {
        toSet.private = rest.private;
      }
      if (rest.pluginOptions) {
        toSet.pluginOptions = rest.pluginOptions;
      }
      const currentAttributeIndex = updatedAttributes.findIndex((value) => {
        return value.name !== void 0 && value.name === initialAttribute.name;
      });
      if (currentAttributeIndex !== -1) {
        updatedAttributes.splice(currentAttributeIndex, 1, toSet);
      }
      let oppositeAttributeNameToRemove = null;
      let oppositeAttributeNameToUpdate = null;
      let oppositeAttributeToCreate = null;
      let initialOppositeAttribute = null;
      const currentUid = (0, import_get.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "uid"
      ]);
      const didChangeTargetRelation = initialAttribute.target !== rest.target;
      const didCreateInternalRelation = rest.target === currentUid;
      const relationType = getRelationType(rest.relation, rest.targetAttribute);
      const initialRelationType = getRelationType(initialAttribute.relation, initialAttribute.targetAttribute);
      const hadInternalRelation = initialAttribute.target === currentUid;
      const didChangeRelationType = initialRelationType !== relationType;
      const shouldRemoveOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && !didCreateInternalRelation && hadInternalRelation && isEditingRelation;
      const shouldRemoveOppositeAttributeBecauseOfRelationTypeChange = didChangeRelationType && hadInternalRelation && [
        "oneWay",
        "manyWay"
      ].includes(relationType) && isEditingRelation;
      const shouldUpdateOppositeAttributeBecauseOfRelationTypeChange = !ONE_SIDE_RELATIONS.includes(initialRelationType) && !ONE_SIDE_RELATIONS.includes(relationType) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;
      const shouldCreateOppositeAttributeBecauseOfRelationTypeChange = ONE_SIDE_RELATIONS.includes(initialRelationType) && !ONE_SIDE_RELATIONS.includes(relationType) && hadInternalRelation && didCreateInternalRelation && isEditingRelation;
      const shouldCreateOppositeAttributeBecauseOfTargetChange = didChangeTargetRelation && didCreateInternalRelation && !ONE_SIDE_RELATIONS.includes(relationType);
      if (shouldRemoveOppositeAttributeBecauseOfTargetChange || shouldRemoveOppositeAttributeBecauseOfRelationTypeChange) {
        oppositeAttributeNameToRemove = initialAttribute.targetAttribute;
      }
      if (oppositeAttributeNameToRemove) {
        const indexToRemove = updatedAttributes.findIndex((value) => value.name === oppositeAttributeNameToRemove);
        updatedAttributes.splice(indexToRemove, 1);
      }
      if (!shouldRemoveOppositeAttributeBecauseOfTargetChange) {
        const initialTargetContentType = (0, import_get.default)(state, [
          "initialContentTypes",
          initialAttribute.target
        ]);
        if (initialTargetContentType) {
          const oppositeAttributeIndex = findAttributeIndex(initialTargetContentType, initialAttribute.targetAttribute);
          initialOppositeAttribute = (0, import_get.default)(state, [
            "initialContentTypes",
            initialAttribute.target,
            "schema",
            "attributes",
            oppositeAttributeIndex
          ]);
        }
      }
      if (shouldCreateOppositeAttributeBecauseOfRelationTypeChange || shouldCreateOppositeAttributeBecauseOfTargetChange) {
        oppositeAttributeToCreate = {
          name: rest.targetAttribute,
          relation: getOppositeRelation(relationType),
          target: rest.target,
          targetAttribute: name,
          type: "relation"
        };
        if (rest.private) {
          oppositeAttributeToCreate.private = rest.private;
        }
        if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {
          oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;
        }
        const indexOfInitialAttribute = updatedAttributes.findIndex(({ name: name2 }) => name2 === initialAttribute.name);
        const indexOfUpdatedAttribute = updatedAttributes.findIndex(({ name: attrName }) => name === attrName);
        const indexToInsert = (indexOfInitialAttribute === -1 ? indexOfUpdatedAttribute : indexOfInitialAttribute) + 1;
        updatedAttributes.splice(indexToInsert, 0, oppositeAttributeToCreate);
      }
      if (shouldUpdateOppositeAttributeBecauseOfRelationTypeChange) {
        oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;
        oppositeAttributeToCreate = {
          name: rest.targetAttribute,
          relation: getOppositeRelation(relationType),
          target: rest.target,
          targetAttribute: name,
          type: "relation"
        };
        if (rest.private) {
          oppositeAttributeToCreate.private = rest.private;
        }
        if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {
          oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;
        }
        if (oppositeAttributeNameToUpdate) {
          const indexToUpdate = updatedAttributes.findIndex(({ name: name2 }) => name2 === oppositeAttributeNameToUpdate);
          updatedAttributes.splice(indexToUpdate, 1, oppositeAttributeToCreate);
        }
      }
      (0, import_set.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes"
      ], updatedAttributes);
    },
    editCustomFieldAttribute: (state, action) => {
      const { forTarget, targetUid, initialAttribute, attributeToSet } = action.payload;
      const initialAttributeName = initialAttribute.name;
      const pathToDataToEdit = [
        "component",
        "contentType"
      ].includes(forTarget) ? [
        forTarget
      ] : [
        forTarget,
        targetUid
      ];
      const initialAttributeIndex = findAttributeIndex((0, import_get.default)(state, [
        "modifiedData",
        ...pathToDataToEdit
      ]), initialAttributeName);
      (0, import_set.default)(state, [
        "modifiedData",
        ...pathToDataToEdit,
        "schema",
        "attributes",
        initialAttributeIndex
      ], attributeToSet);
    },
    updateInitialState: (state) => {
      state.initialData = state.modifiedData;
    },
    deleteNotSavedType: (state) => {
      state.contentTypes = state.initialContentTypes;
      state.components = state.initialComponents;
    },
    reloadPlugin: () => {
      return initialState$1;
    },
    removeComponentFromDynamicZone: (state, action) => {
      const { dzName, componentToRemoveIndex } = action.payload;
      const dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, dzName);
      if (state.modifiedData.contentType) {
        state.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.splice(componentToRemoveIndex, 1);
      }
    },
    removeField: (state, action) => {
      var _a, _b, _c;
      const { mainDataKey, attributeToRemoveName } = action.payload;
      const pathToAttributes = [
        "modifiedData",
        mainDataKey,
        "schema",
        "attributes"
      ];
      const attributeToRemoveIndex = findAttributeIndex(state.modifiedData[mainDataKey], attributeToRemoveName);
      const pathToAttributeToRemove = [
        ...pathToAttributes,
        attributeToRemoveIndex
      ];
      const attributeToRemoveData = (0, import_get.default)(state, pathToAttributeToRemove);
      const isRemovingRelationAttribute = attributeToRemoveData.type === "relation";
      const canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === "contentType";
      if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {
        const { target, relation, targetAttribute } = attributeToRemoveData;
        const relationType = getRelationType(relation, targetAttribute);
        const uid = (_a = state.modifiedData.contentType) == null ? void 0 : _a.uid;
        const shouldRemoveOppositeAttribute = target === uid && !ONE_SIDE_RELATIONS.includes(relationType);
        if (shouldRemoveOppositeAttribute) {
          const attributes = (_b = state.modifiedData[mainDataKey]) == null ? void 0 : _b.schema.attributes.slice();
          const nextAttributes = attributes.filter((attribute) => {
            if (attribute.name === attributeToRemoveName) {
              return false;
            }
            if (attribute.target === uid && attribute.targetAttribute === attributeToRemoveName) {
              return false;
            }
            return true;
          });
          const schema = state.modifiedData[mainDataKey];
          if (schema) {
            schema.schema.attributes = nextAttributes;
          }
          return;
        }
      }
      const uidFieldsToUpdate = state.modifiedData[mainDataKey].schema.attributes.slice().reduce((acc, current) => {
        if (current.type !== "uid") {
          return acc;
        }
        if (current.targetField !== attributeToRemoveName) {
          return acc;
        }
        acc.push(current.name);
        return acc;
      }, []);
      uidFieldsToUpdate.forEach((fieldName) => {
        var _a2;
        const fieldIndex = findAttributeIndex(state.modifiedData[mainDataKey], fieldName);
        (_a2 = state.modifiedData[mainDataKey]) == null ? true : delete _a2.schema.attributes[fieldIndex].targetField;
      });
      (_c = state.modifiedData[mainDataKey]) == null ? void 0 : _c.schema.attributes.splice(attributeToRemoveIndex, 1);
    },
    removeFieldFromDisplayedComponent: (state, action) => {
      var _a, _b, _c, _d, _e;
      const { attributeToRemoveName, componentUid } = action.payload;
      const attributeToRemoveIndex = findAttributeIndex((_a = state.modifiedData.components) == null ? void 0 : _a[componentUid], attributeToRemoveName);
      (_e = (_d = (_c = (_b = state.modifiedData.components) == null ? void 0 : _b[componentUid]) == null ? void 0 : _c.schema) == null ? void 0 : _d.attributes) == null ? void 0 : _e.splice(attributeToRemoveIndex, 1);
    },
    setModifiedData: (state, action) => {
      const { schemaToSet, hasJustCreatedSchema } = action.payload;
      const schema = {
        ...DEFAULT_MODIFIED_DATA,
        ...schemaToSet
      };
      state.initialData = schema;
      state.modifiedData = schema;
      if (!hasJustCreatedSchema) {
        state.components = state.initialComponents;
        state.contentTypes = state.initialContentTypes;
      }
    },
    updateSchema: (state, action) => {
      const { data, schemaType } = action.payload;
      const schema = state.modifiedData[schemaType];
      if (!schema) {
        return;
      }
      schema.schema.displayName = data.displayName;
      if (schemaType === "component") {
        const { uid } = action.payload;
        schema.category = data.category;
        schema.schema.icon = data.icon;
        const addedComponent = R(schema);
        state.components[uid] = addedComponent;
      } else {
        schema.schema.kind = data.kind;
      }
    }
  }
});
var { reducer: reducer$1, actions: actions$1 } = slice$1;
var nameToSlug = (name) => (0, import_slugify.default)(name, {
  separator: "-"
});
var createUid = (name) => {
  const modelName = nameToSlug(name);
  return `api::${modelName}.${modelName}`;
};
var createComponentUid = (name, category) => {
  return `${nameToSlug(category)}.${nameToSlug(name)}`;
};
var customFieldDefaultOptionsReducer = (acc, option) => {
  if (option.items) {
    return option.items.reduce(customFieldDefaultOptionsReducer, acc);
  }
  if ("defaultValue" in option) {
    const { name, defaultValue } = option;
    acc.push({
      name,
      defaultValue
    });
  }
  return acc;
};
var shouldPluralizeName = (nature) => [
  "manyToMany",
  "oneToMany",
  "manyWay"
].includes(nature) ? 2 : 1;
var shouldPluralizeTargetAttribute = (nature) => [
  "manyToMany",
  "manyToOne"
].includes(nature) ? 2 : 1;
var initialState = {
  formErrors: {},
  modifiedData: {},
  initialData: {},
  componentToCreate: {},
  isCreatingComponentWhileAddingAField: false
};
var slice = createSlice({
  name: "formModal",
  initialState,
  reducers: {
    onChange: (state, action) => {
      const { keys, value } = action.payload;
      const obj = state.modifiedData;
      const hasDefaultValue = Boolean(obj.default);
      if (hasDefaultValue && keys.length === 1 && keys.includes("type")) {
        const previousType = obj.type;
        if (previousType && [
          "date",
          "datetime",
          "time"
        ].includes(previousType)) {
          delete state.modifiedData.default;
        }
      }
      (0, import_set.default)(state, [
        "modifiedData",
        ...keys
      ], value);
    },
    onChangeRelationTarget: (state, action) => {
      const { target: { oneThatIsCreatingARelationWithAnother, selectedContentTypeFriendlyName, targetContentTypeAllowedRelations, value } } = action.payload;
      let didChangeRelationTypeBecauseOfRestrictedRelation = false;
      let changedRelationType = null;
      (0, import_set.default)(state, [
        "modifiedData",
        "target"
      ], value);
      const modifiedData = state.modifiedData;
      if (Array.isArray(targetContentTypeAllowedRelations)) {
        const currentRelationType = getRelationType(modifiedData.relation, modifiedData.targetAttribute);
        if (currentRelationType && !targetContentTypeAllowedRelations.includes(currentRelationType)) {
          const relationToSet = targetContentTypeAllowedRelations[0];
          didChangeRelationTypeBecauseOfRestrictedRelation = true;
          changedRelationType = relationToSet;
          if (relationToSet === "oneWay") {
            (0, import_set.default)(state, [
              "modifiedData",
              "relation"
            ], "oneToOne");
          } else if (relationToSet === "manyWay") {
            (0, import_set.default)(state, [
              "modifiedData",
              "relation"
            ], "oneToMany");
          } else {
            (0, import_set.default)(state, [
              "modifiedData",
              "relation"
            ], relationToSet);
          }
        }
      }
      let nameToSet;
      if (didChangeRelationTypeBecauseOfRestrictedRelation && changedRelationType) {
        nameToSet = (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(selectedContentTypeFriendlyName)), shouldPluralizeName(changedRelationType));
      } else {
        nameToSet = (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(selectedContentTypeFriendlyName)), shouldPluralizeName(modifiedData.relation));
      }
      (0, import_set.default)(state, [
        "modifiedData",
        "name"
      ], nameToSet);
      const currentTargetAttribute = state.modifiedData.targetAttribute;
      if (currentTargetAttribute === null) {
        return;
      }
      if (didChangeRelationTypeBecauseOfRestrictedRelation && changedRelationType && [
        "oneWay",
        "manyWay"
      ].includes(changedRelationType)) {
        (0, import_set.default)(state, [
          "modifiedData",
          "targetAttribute"
        ], null);
        return;
      }
      const targetAttributeToSet = (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(oneThatIsCreatingARelationWithAnother)), shouldPluralizeTargetAttribute(modifiedData.relation));
      (0, import_set.default)(state, [
        "modifiedData",
        "targetAttribute"
      ], targetAttributeToSet);
    },
    onChangeRelationType: (state, action) => {
      const { target: { oneThatIsCreatingARelationWithAnother, value } } = action.payload;
      const currentName = state.modifiedData.name;
      if (![
        "oneWay",
        "manyWay"
      ].includes(value)) {
        (0, import_set.default)(state, [
          "modifiedData",
          "relation"
        ], value);
        const currentTargetAttribute = state.modifiedData.targetAttribute;
        (0, import_set.default)(state, [
          "modifiedData",
          "name"
        ], (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(currentName)), shouldPluralizeName(value)));
        (0, import_set.default)(state, [
          "modifiedData",
          "targetAttribute"
        ], (0, import_pluralize.default)(currentTargetAttribute || (0, import_snakeCase.default)(nameToSlug(oneThatIsCreatingARelationWithAnother)), shouldPluralizeTargetAttribute(value)));
        return;
      }
      if (value === "oneWay") {
        (0, import_set.default)(state, [
          "modifiedData",
          "relation"
        ], "oneToOne");
        (0, import_set.default)(state, [
          "modifiedData",
          "targetAttribute"
        ], null);
        (0, import_set.default)(state, [
          "modifiedData",
          "name"
        ], (0, import_pluralize.default)((0, import_snakeCase.default)(currentName), 1));
        return;
      }
      (0, import_set.default)(state, [
        "modifiedData",
        "relation"
      ], "oneToMany");
      (0, import_set.default)(state, [
        "modifiedData",
        "targetAttribute"
      ], null);
      (0, import_set.default)(state, [
        "modifiedData",
        "name"
      ], (0, import_pluralize.default)((0, import_snakeCase.default)(currentName), 2));
    },
    resetProps: () => {
      return initialState;
    },
    resetPropsAndSetFormForAddingAnExistingCompo: (state, action) => {
      const { options = {} } = action.payload;
      return {
        ...initialState,
        modifiedData: {
          type: "component",
          repeatable: true,
          ...options
        }
      };
    },
    resetPropsAndSaveCurrentData: (state, action) => {
      const { options = {} } = action.payload;
      const componentToCreate = state.modifiedData.componentToCreate;
      const modifiedData = {
        displayName: componentToCreate.displayName,
        type: "component",
        repeatable: false,
        ...options,
        component: createComponentUid(componentToCreate.displayName, componentToCreate.category)
      };
      return {
        ...initialState,
        componentToCreate,
        modifiedData,
        isCreatingComponentWhileAddingAField: state.modifiedData.createComponent
      };
    },
    resetPropsAndSetTheFormForAddingACompoToADz: (state) => {
      const createdDZ = state.modifiedData;
      const dataToSet = {
        ...createdDZ,
        createComponent: true,
        componentToCreate: {
          type: "component"
        }
      };
      return {
        ...initialState,
        modifiedData: dataToSet
      };
    },
    setDataToEdit: (state, action) => {
      const { data } = action.payload;
      state.modifiedData = data;
      state.initialData = data;
    },
    setAttributeDataSchema: (state, action) => {
      const { isEditing } = action.payload;
      if (isEditing) {
        const { modifiedDataToSetForEditing } = action.payload;
        state.modifiedData = modifiedDataToSetForEditing;
        state.initialData = modifiedDataToSetForEditing;
        return;
      }
      const { attributeType, nameToSetForRelation, targetUid, step, options = {} } = action.payload;
      let dataToSet;
      if (attributeType === "component") {
        if (step === "1") {
          dataToSet = {
            type: "component",
            createComponent: true,
            componentToCreate: {
              type: "component"
            }
          };
        } else {
          dataToSet = {
            ...options,
            type: "component",
            repeatable: true
          };
        }
      } else if (attributeType === "dynamiczone") {
        dataToSet = {
          ...options,
          type: "dynamiczone",
          components: []
        };
      } else if (attributeType === "text") {
        dataToSet = {
          ...options,
          type: "string"
        };
      } else if (attributeType === "number" || attributeType === "date") {
        dataToSet = options;
      } else if (attributeType === "media") {
        dataToSet = {
          allowedTypes: [
            "images",
            "files",
            "videos",
            "audios"
          ],
          type: "media",
          multiple: true,
          ...options
        };
      } else if (attributeType === "enumeration") {
        dataToSet = {
          ...options,
          type: "enumeration",
          enum: []
        };
      } else if (attributeType === "relation") {
        dataToSet = {
          name: (0, import_snakeCase.default)(nameToSetForRelation),
          relation: "oneToOne",
          targetAttribute: null,
          target: targetUid,
          type: "relation"
        };
      } else {
        dataToSet = {
          ...options,
          type: attributeType,
          default: null
        };
      }
      state.modifiedData = dataToSet;
    },
    setCustomFieldDataSchema: (state, action) => {
      var _a, _b;
      const { isEditing } = action.payload;
      if (isEditing) {
        const { modifiedDataToSetForEditing } = action.payload;
        state.modifiedData = modifiedDataToSetForEditing;
        state.initialData = modifiedDataToSetForEditing;
        return;
      }
      const { customField, options = {} } = action.payload;
      state.modifiedData = {
        ...options,
        type: customField.type
      };
      const allOptions = [
        ...((_a = customField == null ? void 0 : customField.options) == null ? void 0 : _a.base) || [],
        ...((_b = customField == null ? void 0 : customField.options) == null ? void 0 : _b.advanced) || []
      ];
      const optionDefaults = allOptions.reduce(customFieldDefaultOptionsReducer, []);
      if (optionDefaults.length) {
        optionDefaults.forEach(({ name, defaultValue }) => (0, import_set.default)(state.modifiedData, name, defaultValue));
      }
    },
    setDynamicZoneDataSchema: (state, action) => {
      const { attributeToEdit } = action.payload;
      state.modifiedData = attributeToEdit;
      state.initialData = attributeToEdit;
    },
    setErrors: (state, action) => {
      state.formErrors = action.payload.errors;
    }
  }
});
var { actions, reducer } = slice;
var reducers = {
  [`${pluginId}_formModal`]: reducer,
  [`${pluginId}_dataManagerProvider`]: reducer$1
};
var formsAPI = {
  components: {
    inputs: {},
    add({ id, component }) {
      if (!this.inputs[id]) {
        this.inputs[id] = component;
      }
    }
  },
  types: {
    attribute: {},
    contentType: {
      validators: [],
      form: {
        advanced: [],
        base: []
      }
    },
    component: {
      validators: [],
      form: {
        advanced: [],
        base: []
      }
    }
  },
  contentTypeSchemaMutations: [],
  addContentTypeSchemaMutation(cb) {
    this.contentTypeSchemaMutations.push(cb);
  },
  extendContentType({ validator, form: { advanced, base } }) {
    const { contentType } = this.types;
    if (validator) {
      contentType.validators.push(validator);
    }
    contentType.form.advanced.push(advanced);
    contentType.form.base.push(base);
  },
  extendFields(fields, { validator, form: { advanced, base } }) {
    const formType = this.types.attribute;
    fields.forEach((field) => {
      if (!formType[field]) {
        formType[field] = {
          validators: [],
          form: {
            advanced: [],
            base: []
          }
        };
      }
      if (validator) {
        formType[field].validators.push(validator);
      }
      formType[field].form.advanced.push(advanced);
      formType[field].form.base.push(base);
    });
  },
  getAdvancedForm(target, props = null) {
    const sectionsToAdd = (0, import_get.default)(this.types, [
      ...target,
      "form",
      "advanced"
    ], []).reduce((acc, current) => {
      const sections = current(props);
      return [
        ...acc,
        ...sections
      ];
    }, []);
    return sectionsToAdd;
  },
  makeCustomFieldValidator(attributeShape, validator, ...validatorArgs) {
    if (!validator)
      return attributeShape;
    return attributeShape.shape({
      options: create().shape(validator(validatorArgs))
    });
  },
  makeValidator(target, initShape, ...args) {
    const validators = (0, import_get.default)(this.types, [
      ...target,
      "validators"
    ], []);
    const pluginOptionsShape = validators.reduce((acc, current) => {
      const pluginOptionShape = current(args);
      return {
        ...acc,
        ...pluginOptionShape
      };
    }, {});
    return initShape.shape({
      pluginOptions: create().shape(pluginOptionsShape)
    });
  },
  mutateContentTypeSchema(data, initialData) {
    let enhancedData = (0, import_cloneDeep.default)(data);
    const refData = (0, import_cloneDeep.default)(initialData);
    this.contentTypeSchemaMutations.forEach((cb) => {
      enhancedData = cb(enhancedData, refData);
    });
    return enhancedData;
  }
};
var prefixPluginTranslations = (trad, pluginId2) => {
  return Object.keys(trad).reduce((acc, current) => {
    acc[`${pluginId2}.${current}`] = trad[current];
    return acc;
  }, {});
};
var AutoReloadOverlayBlockerContext = React.createContext({});
var MAX_ELAPSED_TIME = 30 * 1e3;
var AutoReloadOverlayBlockerProvider = ({ children }) => {
  const [isOpen, setIsOpen] = React.useState(false);
  const [config, setConfig] = React.useState({});
  const [failed, setFailed] = React.useState(false);
  const lockAppWithAutoreload = React.useCallback((config2 = {}) => {
    setIsOpen(true);
    setConfig(config2);
  }, []);
  const unlockAppWithAutoreload = React.useCallback(() => {
    setIsOpen(false);
    setConfig({});
  }, []);
  React.useEffect(() => {
    if (isOpen) {
      const timeout = setTimeout(() => {
        setFailed(true);
      }, MAX_ELAPSED_TIME);
      return () => {
        clearTimeout(timeout);
      };
    }
  }, [
    isOpen
  ]);
  let displayedIcon = (config == null ? void 0 : config.icon) || "reload";
  let description = {
    id: (config == null ? void 0 : config.description) || "components.OverlayBlocker.description",
    defaultMessage: "You're using a feature that needs the server to restart. The page will reload automatically."
  };
  let title = {
    id: (config == null ? void 0 : config.title) || "components.OverlayBlocker.title",
    defaultMessage: "Waiting for restart"
  };
  if (failed) {
    displayedIcon = "time";
    description = {
      id: "components.OverlayBlocker.description.serverError",
      defaultMessage: "The server should have restarted, please check your logs in the terminal."
    };
    title = {
      id: "components.OverlayBlocker.title.serverError",
      defaultMessage: "The restart is taking longer than expected"
    };
  }
  const autoReloadValue = React.useMemo(() => ({
    lockAppWithAutoreload,
    unlockAppWithAutoreload
  }), [
    lockAppWithAutoreload,
    unlockAppWithAutoreload
  ]);
  return (0, import_jsx_runtime.jsxs)(AutoReloadOverlayBlockerContext.Provider, {
    value: autoReloadValue,
    children: [
      (0, import_jsx_runtime.jsx)(Blocker, {
        displayedIcon,
        isOpen,
        description,
        title
      }),
      children
    ]
  });
};
var Blocker = ({ displayedIcon, description, title, isOpen }) => {
  var _a;
  const { formatMessage } = useIntl();
  return isOpen && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body) ? (0, import_react_dom.createPortal)(
    (0, import_jsx_runtime.jsxs)(Overlay, {
      id: "autoReloadOverlayBlocker",
      direction: "column",
      alignItems: "center",
      gap: 6,
      children: [
        (0, import_jsx_runtime.jsxs)(Flex, {
          direction: "column",
          alignItems: "center",
          gap: 2,
          children: [
            (0, import_jsx_runtime.jsx)(Typography, {
              tag: "h1",
              variant: "alpha",
              children: formatMessage(title)
            }),
            (0, import_jsx_runtime.jsx)(Typography, {
              tag: "h2",
              textColor: "neutral600",
              fontSize: 4,
              fontWeight: "regular",
              children: formatMessage(description)
            })
          ]
        }),
        displayedIcon === "reload" && (0, import_jsx_runtime.jsx)(IconBox, {
          padding: 6,
          background: "primary100",
          borderColor: "primary200",
          children: (0, import_jsx_runtime.jsx)(LoaderReload, {
            width: "4rem",
            height: "4rem"
          })
        }),
        displayedIcon === "time" && (0, import_jsx_runtime.jsx)(IconBox, {
          padding: 6,
          background: "primary100",
          borderColor: "primary200",
          children: (0, import_jsx_runtime.jsx)(ForwardRef$4l, {
            width: "4rem",
            height: "4rem"
          })
        }),
        (0, import_jsx_runtime.jsx)(Box, {
          marginTop: 2,
          children: (0, import_jsx_runtime.jsx)(Link, {
            href: "https://docs.strapi.io",
            isExternal: true,
            children: formatMessage({
              id: "global.documentation",
              defaultMessage: "Read the documentation"
            })
          })
        })
      ]
    }),
    // eslint-disable-next-line no-undef
    globalThis.document.body
  ) : null;
};
var rotation = mt`
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(359deg);
    }
  `;
var LoaderReload = dt(ForwardRef$5b)`
  animation: ${rotation} 1s infinite linear;
`;
var Overlay = dt(Flex)`
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* TODO: set this up in the theme for consistence z-index values */
  z-index: 1140;
  padding-top: 16rem;

  & > * {
    position: relative;
    z-index: 1;
  }

  &:before {
    content: '';
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background: ${({ theme }) => theme.colors.neutral0};
    opacity: 0.9;
  }
`;
var IconBox = dt(Box)`
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    > path {
      fill: ${({ theme }) => theme.colors.primary600} !important;
    }
  }
`;
var useAutoReloadOverlayBlocker = () => React.useContext(AutoReloadOverlayBlockerContext);
function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case "./translations/ar.json":
      return import("./ar-sRW9VFC--TCNL5VKK.js");
    case "./translations/cs.json":
      return import("./cs-BpQ26jiq-QDT7AXQC.js");
    case "./translations/de.json":
      return import("./de-DSxx5_x--CGV6WAVT.js");
    case "./translations/dk.json":
      return import("./dk-BnjVZ7A_-UQXFZVYQ.js");
    case "./translations/en.json":
      return import("./en-Bhut8Yay-A374NZ2T.js");
    case "./translations/es.json":
      return import("./es-DG8g9igJ-VZ32QC66.js");
    case "./translations/fr.json":
      return import("./fr-UpV34MHY-CRWCQH2O.js");
    case "./translations/id.json":
      return import("./id-BWM18ljw-4W6LJQEL.js");
    case "./translations/it.json":
      return import("./it-1_vd9gV4-6WQDH56R.js");
    case "./translations/ja.json":
      return import("./ja-Cx23a2Ui-VXL5BLTR.js");
    case "./translations/ko.json":
      return import("./ko-DC7paEx5-7DGYHZLU.js");
    case "./translations/ms.json":
      return import("./ms-C3s4kxq6-VEMRVWK6.js");
    case "./translations/nl.json":
      return import("./nl-TzvfktV_-7ODKQJEL.js");
    case "./translations/pl.json":
      return import("./pl-BdvupIN_-M2SSZSOC.js");
    case "./translations/pt-BR.json":
      return import("./pt-BR-DPrVmKeZ-QI3GJVW7.js");
    case "./translations/pt.json":
      return import("./pt-BTLIwmCv-5ONH3SJP.js");
    case "./translations/ru.json":
      return import("./ru-D46no502-FRCJSF4N.js");
    case "./translations/sk.json":
      return import("./sk-Byr_l4Jc-JSXONBZ7.js");
    case "./translations/sv.json":
      return import("./sv-Bbam7IDm-7OU7YJL6.js");
    case "./translations/th.json":
      return import("./th-hfS0Wmk_-VZFTDC7X.js");
    case "./translations/tr.json":
      return import("./tr-DS7DBOhC-2QSSNF6D.js");
    case "./translations/uk.json":
      return import("./uk-Cj8-BKeu-YCE4MP7Z.js");
    case "./translations/zh-Hans.json":
      return import("./zh-Hans-BElOnuRb-N4LVQPDL.js");
    case "./translations/zh.json":
      return import("./zh-BUVXH75--LXETDEHK.js");
    default:
      return new Promise(function(resolve, reject) {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
          reject.bind(null, new Error("Unknown variable dynamic import: " + path))
        );
      });
  }
}
var index = {
  register(app) {
    app.addReducers(reducers);
    app.addMenuLink({
      to: `plugins/${pluginId}`,
      icon: ForwardRef$2r,
      intlLabel: {
        id: `${pluginId}.plugin.name`,
        defaultMessage: "Content-Type Builder"
      },
      permissions: PERMISSIONS.main,
      Component: () => import("./index-Cr5tfW7U-P34JVMZ4.js").then(function(n) {
        return n.i;
      }),
      position: 5
    });
    app.registerPlugin({
      id: pluginId,
      name: pluginId,
      // Internal APIs exposed by the CTB for the other plugins to use
      apis: {
        forms: formsAPI
      }
    });
  },
  bootstrap() {
  },
  async registerTrads({ locales }) {
    const importedTrads = await Promise.all(locales.map((locale) => {
      return __variableDynamicImportRuntime1__(`./translations/${locale}.json`).then(({ default: data }) => {
        return {
          data: prefixPluginTranslations(data, pluginId),
          locale
        };
      }).catch(() => {
        return {
          data: {},
          locale
        };
      });
    }));
    return Promise.resolve(importedTrads);
  }
};

export {
  require_slugify,
  PERMISSIONS,
  MAX_COMPONENT_DEPTH,
  pluginId,
  getRelationType,
  makeUnique,
  retrieveComponentsFromSchema,
  initialState$1,
  actions$1,
  nameToSlug,
  createUid,
  createComponentUid,
  initialState,
  actions,
  AutoReloadOverlayBlockerProvider,
  useAutoReloadOverlayBlocker,
  index
};
//# sourceMappingURL=chunk-K3KKSQVD.js.map
