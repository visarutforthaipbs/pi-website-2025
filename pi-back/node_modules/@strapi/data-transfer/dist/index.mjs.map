{"version":3,"file":"index.mjs","sources":["../src/utils/encryption/encrypt.ts","../src/utils/encryption/decrypt.ts","../src/utils/stream.ts","../src/utils/json.ts","../src/utils/schema.ts","../src/utils/transaction.ts","../src/utils/middleware.ts","../src/utils/diagnostic.ts","../src/engine/validation/schemas/index.ts","../src/errors/constants.ts","../src/errors/base.ts","../src/engine/errors.ts","../src/engine/validation/provider.ts","../src/errors/providers.ts","../src/engine/index.ts","../src/utils/components.ts","../src/strapi/queries/entity.ts","../src/strapi/queries/link.ts","../src/strapi/providers/local-destination/strategies/restore/entities.ts","../src/strapi/providers/local-destination/strategies/restore/configuration.ts","../src/strapi/providers/local-destination/strategies/restore/links.ts","../src/strapi/providers/local-destination/strategies/restore/index.ts","../src/utils/providers.ts","../src/strapi/providers/local-destination/index.ts","../src/strapi/providers/local-source/entities.ts","../src/strapi/providers/local-source/links.ts","../src/strapi/providers/local-source/configuration.ts","../src/strapi/providers/local-source/assets.ts","../src/strapi/providers/local-source/index.ts","../src/strapi/providers/utils.ts","../src/strapi/remote/constants.ts","../src/strapi/providers/remote-destination/index.ts","../src/strapi/providers/remote-source/index.ts","../src/strapi/providers/index.ts","../src/strapi/remote/flows/default.ts","../src/strapi/remote/flows/index.ts","../src/strapi/remote/handlers/constants.ts","../src/strapi/remote/handlers/utils.ts","../src/strapi/remote/handlers/push.ts","../src/strapi/remote/handlers/pull.ts","../src/file/providers/source/utils.ts","../src/file/providers/source/index.ts","../src/file/providers/destination/utils.ts","../src/file/providers/destination/index.ts"],"sourcesContent":["import { createCipheriv, Cipher, scryptSync, CipherKey, BinaryLike } from 'crypto';\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\n\n// different key values depending on algorithm chosen\nconst getEncryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\n  const strategies: Strategies = {\n    'aes-128-ecb'(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 16);\n      const initVector: BinaryLike | null = null;\n      const securityKey: CipherKey = hashedKey;\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes128(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 32);\n      const initVector: BinaryLike | null = hashedKey.slice(16);\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes192(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 40);\n      const initVector: BinaryLike | null = hashedKey.slice(24);\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n    aes256(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 48);\n      const initVector: BinaryLike | null = hashedKey.slice(32);\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\n      return createCipheriv(algorithm, securityKey, initVector);\n    },\n  };\n\n  return strategies[algorithm];\n};\n\n/**\n * It creates a cipher instance used for encryption\n *\n * @param key - The encryption key\n * @param algorithm - The algorithm to use to create the Cipher\n *\n * @returns A {@link Cipher} instance created with the given key & algorithm\n */\nexport const createEncryptionCipher = (\n  key: string,\n  algorithm: Algorithm = 'aes-128-ecb'\n): Cipher => {\n  return getEncryptionStrategy(algorithm)(key);\n};\n","import { Cipher, scryptSync, CipherKey, BinaryLike, createDecipheriv } from 'crypto';\nimport { EncryptionStrategy, Strategies, Algorithm } from '../../../types';\n\n// different key values depending on algorithm chosen\nconst getDecryptionStrategy = (algorithm: Algorithm): EncryptionStrategy => {\n  const strategies: Strategies = {\n    'aes-128-ecb'(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 16);\n      const initVector: BinaryLike | null = null;\n      const securityKey: CipherKey = hashedKey;\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes128(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 32);\n      const initVector: BinaryLike | null = hashedKey.slice(16);\n      const securityKey: CipherKey = hashedKey.slice(0, 16);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes192(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 40);\n      const initVector: BinaryLike | null = hashedKey.slice(24);\n      const securityKey: CipherKey = hashedKey.slice(0, 24);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n    aes256(key: string): Cipher {\n      const hashedKey = scryptSync(key, '', 48);\n      const initVector: BinaryLike | null = hashedKey.slice(32);\n      const securityKey: CipherKey = hashedKey.slice(0, 32);\n      return createDecipheriv(algorithm, securityKey, initVector);\n    },\n  };\n\n  return strategies[algorithm];\n};\n\n/**\n * It creates a cipher instance used for decryption\n *\n * @param key - The decryption key\n * @param algorithm - The algorithm to use to create the Cipher\n *\n * @returns A {@link Cipher} instance created with the given key & algorithm\n */\nexport const createDecryptionCipher = (\n  key: string,\n  algorithm: Algorithm = 'aes-128-ecb'\n): Cipher => {\n  return getDecryptionStrategy(algorithm)(key);\n};\n","import { Transform, Readable } from 'stream';\n\ntype TransformOptions = ConstructorParameters<typeof Transform>[0];\n\n/**\n * Create a filter stream that discard chunks which doesn't satisfies the given predicate\n *\n * @param predicate - A filter predicate, takes a stream data chunk as parameter and returns a boolean value\n * @param options - Transform stream options\n */\nexport const filter = <T>(\n  predicate: (value: T) => boolean | Promise<boolean>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const keep = await predicate(chunk);\n\n      callback(null, keep ? chunk : undefined);\n    },\n  });\n};\n\n/**\n * Create a map stream that transform chunks using the given predicate\n *\n * @param predicate - A map predicate, takes a stream data chunk as parameter and returns a mapped value\n * @param options - Transform stream options\n */\nexport const map = <T, U = T>(\n  predicate: (value: T) => U | Promise<U>,\n  options: TransformOptions = { objectMode: true }\n): Transform => {\n  return new Transform({\n    ...options,\n\n    async transform(chunk, _encoding, callback) {\n      const mappedValue = await predicate(chunk);\n\n      callback(null, mappedValue);\n    },\n  });\n};\n\n/**\n * Collect every chunks from a Readable stream.\n *\n * @param stream - The redable stream to collect data from\n * @param options.destroy - If set to true, it automatically calls `destroy()` on the given stream upon receiving the 'end' event\n */\nexport const collect = <T = unknown>(\n  stream: Readable,\n  options: { destroy: boolean } = { destroy: true }\n): Promise<T[]> => {\n  const chunks: T[] = [];\n\n  return new Promise((resolve, reject) => {\n    stream\n      .on('close', () => resolve(chunks))\n      .on('error', reject)\n      .on('data', (chunk) => chunks.push(chunk))\n      .on('end', () => {\n        if (options.destroy) {\n          stream.destroy();\n        }\n\n        resolve(chunks);\n      });\n  });\n};\n","import { isArray, isObject, zip, isEqual, uniq } from 'lodash/fp';\n\nconst createContext = (): Context => ({ path: [] });\n\n/**\n * Compute differences between two JSON objects and returns them\n *\n * @param a - First object\n * @param b - Second object\n * @param ctx - Context used to keep track of the current path during recursion\n */\nexport const diff = (a: unknown, b: unknown, ctx: Context = createContext()): Diff[] => {\n  const diffs: Diff[] = [];\n  const { path } = ctx;\n\n  const aType = typeof a;\n  const bType = typeof b;\n\n  // Define helpers\n\n  const added = () => {\n    diffs.push({ kind: 'added', path, type: bType, value: b });\n    return diffs;\n  };\n\n  const deleted = () => {\n    diffs.push({ kind: 'deleted', path, type: aType, value: a });\n    return diffs;\n  };\n\n  const modified = () => {\n    diffs.push({\n      kind: 'modified',\n      path,\n      types: [aType, bType],\n      values: [a, b],\n    });\n    return diffs;\n  };\n\n  if (isArray(a) && isArray(b)) {\n    let k = 0;\n\n    for (const [aItem, bItem] of zip(a, b)) {\n      const kCtx: Context = { path: [...path, k.toString()] };\n      const kDiffs = diff(aItem, bItem, kCtx);\n\n      diffs.push(...kDiffs);\n\n      k += 1;\n    }\n\n    return diffs;\n  }\n\n  if (isObject(a) && isObject(b)) {\n    const keys = uniq(Object.keys(a).concat(Object.keys(b)));\n\n    for (const key of keys) {\n      const aValue = (a as Record<string, unknown>)[key];\n      const bValue = (b as Record<string, unknown>)[key];\n\n      const nestedDiffs = diff(aValue, bValue, { path: [...path, key] });\n\n      diffs.push(...nestedDiffs);\n    }\n\n    return diffs;\n  }\n\n  if (!isEqual(a, b)) {\n    if (aType === 'undefined') {\n      return added();\n    }\n\n    if (bType === 'undefined') {\n      return deleted();\n    }\n\n    return modified();\n  }\n\n  return diffs;\n};\n\nexport interface AddedDiff<T = unknown> {\n  kind: 'added';\n  path: string[];\n  type: string;\n  value: T;\n}\n\nexport interface ModifiedDiff<T = unknown, P = unknown> {\n  kind: 'modified';\n  path: string[];\n  types: [string, string];\n  values: [T, P];\n}\n\nexport interface DeletedDiff<T = unknown> {\n  kind: 'deleted';\n  path: string[];\n  type: string;\n  value: T;\n}\n\nexport type Diff<T = unknown> = AddedDiff<T> | ModifiedDiff<T> | DeletedDiff<T>;\n\nexport interface Context {\n  path: string[];\n}\n","import type { Struct, Utils } from '@strapi/types';\nimport { mapValues, pick } from 'lodash/fp';\n\n/**\n * List of schema properties that should be kept when sanitizing schemas\n */\nconst VALID_SCHEMA_PROPERTIES = [\n  'collectionName',\n  'info',\n  'options',\n  'pluginOptions',\n  'attributes',\n  'kind',\n  'modelType',\n  'modelName',\n  'uid',\n  'plugin',\n  'globalId',\n];\n\n/**\n * Sanitize a schemas dictionary by omitting unwanted properties\n * The list of allowed properties can be found here: {@link VALID_SCHEMA_PROPERTIES}\n */\nexport const mapSchemasValues = (schemas: Utils.String.Dict<Struct.Schema>) => {\n  return mapValues(pick(VALID_SCHEMA_PROPERTIES), schemas) as Utils.String.Dict<Struct.Schema>;\n};\n\nexport const schemasToValidJSON = (schemas: Utils.String.Dict<Struct.Schema>) => {\n  return JSON.parse(JSON.stringify(schemas));\n};\n","import { EventEmitter } from 'events';\nimport { randomUUID } from 'crypto';\nimport type { Core } from '@strapi/types';\n\nimport { Transaction, TransactionCallback } from '../../types/utils';\n\nexport const createTransaction = (strapi: Core.Strapi): Transaction => {\n  const fns: { fn: TransactionCallback; uuid: string }[] = [];\n\n  let done = false;\n  let resume: null | (() => void) = null;\n\n  const e = new EventEmitter();\n  e.on('spawn', (uuid, cb) => {\n    fns.push({ fn: cb, uuid });\n    resume?.();\n  });\n\n  e.on('close', () => {\n    e.removeAllListeners('rollback');\n    e.removeAllListeners('spawn');\n\n    done = true;\n    resume?.();\n  });\n\n  strapi.db.transaction(async ({ trx, rollback }) => {\n    e.once('rollback', async () => {\n      e.removeAllListeners('close');\n      e.removeAllListeners('spawn');\n\n      try {\n        await rollback();\n        e.emit('rollback_completed');\n      } catch {\n        e.emit('rollback_failed');\n      } finally {\n        done = true;\n        resume?.();\n      }\n    });\n\n    while (!done) {\n      while (fns.length) {\n        const item = fns.shift();\n\n        if (item) {\n          const { fn, uuid } = item;\n\n          try {\n            const res = await fn(trx);\n            e.emit(uuid, { data: res });\n          } catch (error) {\n            e.emit(uuid, { error });\n          }\n        }\n      }\n      if (!done && !fns.length) {\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        await new Promise<void>((resolve) => {\n          resume = resolve;\n        });\n      }\n    }\n  });\n\n  return {\n    async attach<T = undefined>(callback: TransactionCallback): Promise<T | undefined> {\n      const uuid = randomUUID();\n      e.emit('spawn', uuid, callback);\n      return new Promise<T | undefined>((resolve, reject) => {\n        e.on(uuid, ({ data, error }) => {\n          if (data) {\n            resolve(data);\n          }\n\n          if (error) {\n            reject(error);\n          }\n          resolve(undefined);\n        });\n      });\n    },\n\n    end() {\n      return e.emit('close');\n    },\n\n    rollback() {\n      return new Promise<boolean>((resolve) => {\n        e.emit('rollback');\n\n        e.once('rollback_failed', () => resolve(false));\n        e.once('rollback_completed', () => resolve(true));\n      });\n    },\n  };\n};\n","import { Middleware } from '../../types';\n\nexport const runMiddleware = async <T>(context: T, middlewares: Middleware<T>[]): Promise<void> => {\n  if (!middlewares.length) {\n    return;\n  }\n  const cb = middlewares[0];\n  await cb(context, async (newContext: T) => {\n    await runMiddleware(newContext, middlewares.slice(1));\n  });\n};\n","import { EventEmitter } from 'events';\n\nexport interface IDiagnosticReporterOptions {\n  stackSize?: number;\n}\n\nexport type GenericDiagnostic<K extends DiagnosticKind, T = unknown> = {\n  kind: K;\n  details: {\n    message: string;\n    createdAt: Date;\n  } & T;\n};\n\nexport type DiagnosticKind = 'error' | 'warning' | 'info';\n\nexport type DiagnosticListener<T extends DiagnosticKind = DiagnosticKind> = (\n  diagnostic: { kind: T } & Diagnostic extends infer U ? U : never\n) => void | Promise<void>;\n\nexport type DiagnosticEvent = 'diagnostic' | `diagnostic.${DiagnosticKind}`;\n\nexport type GetEventListener<E extends DiagnosticEvent> = E extends 'diagnostic'\n  ? DiagnosticListener\n  : E extends `diagnostic.${infer K}`\n    ? K extends DiagnosticKind\n      ? DiagnosticListener<K>\n      : never\n    : never;\n\nexport type Diagnostic = ErrorDiagnostic | WarningDiagnostic | InfoDiagnostic;\n\nexport type ErrorDiagnosticSeverity = 'fatal' | 'error' | 'silly';\n\nexport type ErrorDiagnostic = GenericDiagnostic<\n  'error',\n  {\n    name: string;\n    severity: ErrorDiagnosticSeverity;\n    error: Error;\n  }\n>;\n\nexport type WarningDiagnostic = GenericDiagnostic<\n  'warning',\n  {\n    origin?: string;\n  }\n>;\n\nexport type InfoDiagnostic<T = unknown> = GenericDiagnostic<\n  'info',\n  {\n    origin?: string;\n    params?: T;\n  }\n>;\n\nexport interface IDiagnosticReporter {\n  stack: {\n    readonly size: number;\n    readonly items: Diagnostic[];\n  };\n\n  report(diagnostic: Diagnostic): IDiagnosticReporter;\n  onDiagnostic(listener: DiagnosticListener): IDiagnosticReporter;\n  on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>): IDiagnosticReporter;\n}\n\nconst createDiagnosticReporter = (\n  options: IDiagnosticReporterOptions = {}\n): IDiagnosticReporter => {\n  const { stackSize = -1 } = options;\n\n  const emitter = new EventEmitter();\n  const stack: Diagnostic[] = [];\n\n  const addListener = <T extends DiagnosticEvent>(event: T, listener: GetEventListener<T>) => {\n    emitter.on(event, listener);\n  };\n\n  const isDiagnosticValid = (diagnostic: Diagnostic) => {\n    if (!diagnostic.kind || !diagnostic.details || !diagnostic.details.message) {\n      return false;\n    }\n    return true;\n  };\n\n  return {\n    stack: {\n      get size() {\n        return stack.length;\n      },\n\n      get items() {\n        return stack;\n      },\n    },\n\n    report(diagnostic: Diagnostic) {\n      if (!isDiagnosticValid(diagnostic)) {\n        return this;\n      }\n\n      emitter.emit('diagnostic', diagnostic);\n      emitter.emit(`diagnostic.${diagnostic.kind}`, diagnostic);\n\n      if (stackSize !== -1 && stack.length >= stackSize) {\n        stack.shift();\n      }\n\n      stack.push(diagnostic);\n\n      return this;\n    },\n\n    onDiagnostic(listener: DiagnosticListener) {\n      addListener('diagnostic', listener);\n\n      return this;\n    },\n\n    on<T extends DiagnosticKind>(kind: T, listener: DiagnosticListener<T>) {\n      addListener(`diagnostic.${kind}`, listener as never);\n\n      return this;\n    },\n  };\n};\n\nexport { createDiagnosticReporter };\n","import type { Struct } from '@strapi/types';\nimport { isArray, isObject, reject } from 'lodash/fp';\nimport type { Diff } from '../../../utils/json';\nimport * as utils from '../../../utils';\n\nconst OPTIONAL_CONTENT_TYPES = ['audit-log'] as const;\n\nconst isAttributeIgnorable = (diff: Diff) => {\n  return (\n    diff.path.length === 3 &&\n    // Root property must be attributes\n    diff.path[0] === 'attributes' &&\n    // Need a valid string attribute name\n    typeof diff.path[1] === 'string' &&\n    // The diff must be on ignorable attribute properties\n    ['private', 'required', 'configurable', 'default'].includes(diff.path[2])\n  );\n};\n\n// TODO: clean up the type checking, which will require cleaning up the typings in utils/json.ts\n// exclude admin tables that are not transferable and are optionally available (such as audit logs which are only available in EE)\nconst isOptionalAdminType = (diff: Diff) => {\n  // added/deleted\n  if ('value' in diff && isObject(diff.value)) {\n    const name = (diff?.value as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  // modified\n  if ('values' in diff && isArray(diff.values) && isObject(diff.values[0])) {\n    const name = (diff?.values[0] as Struct.ContentTypeSchema)?.info?.singularName;\n    return (OPTIONAL_CONTENT_TYPES as ReadonlyArray<string | undefined>).includes(name);\n  }\n\n  return false;\n};\n\nconst isIgnorableStrict = (diff: Diff) => isAttributeIgnorable(diff) || isOptionalAdminType(diff);\n\nconst strategies = {\n  // No diffs\n  exact(diffs: Diff[]) {\n    return diffs;\n  },\n\n  // Strict: all content types must match except:\n  // - the property within a content type is an ignorable one\n  // - those that are (not transferrable and optionally available), for example EE features such as audit logs\n  strict(diffs: Diff[]) {\n    return reject(isIgnorableStrict, diffs);\n  },\n};\n\nconst compareSchemas = <T, P>(a: T, b: P, strategy: keyof typeof strategies) => {\n  const diffs = utils.json.diff(a, b);\n  return strategies[strategy](diffs);\n};\n\nexport { compareSchemas };\n","import { ErrorDiagnosticSeverity } from '../utils/diagnostic';\n\nexport const SeverityKind: Record<string, ErrorDiagnosticSeverity> = {\n  FATAL: 'fatal',\n  ERROR: 'error',\n  SILLY: 'silly',\n} as const;\nexport type Severity = (typeof SeverityKind)[keyof typeof SeverityKind];\n","import { Severity } from './constants';\n\nclass DataTransferError<T = unknown> extends Error {\n  origin: string;\n\n  severity: Severity;\n\n  details: T | null;\n\n  constructor(origin: string, severity: Severity, message?: string, details?: T | null) {\n    super(message);\n\n    this.origin = origin;\n    this.severity = severity;\n    this.details = details ?? null;\n  }\n}\n\nexport { DataTransferError };\n","import { DataTransferError, Severity, SeverityKind } from '../errors';\n\ntype TransferEngineStep = 'initialization' | 'validation' | 'transfer';\n\ntype TransferEngineErrorDetails<P extends TransferEngineStep = TransferEngineStep, U = never> = {\n  step: P;\n} & ([U] extends [never] ? unknown : { details?: U });\n\nclass TransferEngineError<\n  P extends TransferEngineStep = TransferEngineStep,\n  U = never,\n  T extends TransferEngineErrorDetails<P, U> = TransferEngineErrorDetails<P, U>,\n> extends DataTransferError<T> {\n  constructor(severity: Severity, message?: string, details?: T | null) {\n    super('engine', severity, message, details);\n  }\n}\n\nclass TransferEngineInitializationError extends TransferEngineError<'initialization'> {\n  constructor(message?: string) {\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\n  }\n}\n\nclass TransferEngineValidationError<\n  T extends { check: string } = { check: string },\n> extends TransferEngineError<'validation', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'validation', details });\n  }\n}\n\nclass TransferEngineTransferError<\n  T extends { check: string } = { check: string },\n> extends TransferEngineError<'transfer', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\n  }\n}\n\nexport {\n  TransferEngineError,\n  TransferEngineInitializationError,\n  TransferEngineValidationError,\n  TransferEngineTransferError,\n};\n","import { capitalize } from 'lodash/fp';\n\nimport type { IDestinationProvider, ISourceProvider, ProviderType } from '../../../types';\nimport { TransferEngineValidationError } from '../errors';\n\nconst reject = (reason: string): never => {\n  throw new TransferEngineValidationError(`Invalid provider supplied. ${reason}`);\n};\n\nconst validateProvider = <T extends ProviderType>(\n  type: ProviderType,\n  provider?: ([T] extends ['source'] ? ISourceProvider : IDestinationProvider) | null\n) => {\n  if (!provider) {\n    return reject(\n      `Expected an instance of \"${capitalize(type)}Provider\", but got \"${typeof provider}\" instead.`\n    );\n  }\n\n  if (provider.type !== type) {\n    return reject(\n      `Expected the provider to be of type \"${type}\" but got \"${provider.type}\" instead.`\n    );\n  }\n};\n\nexport { validateProvider };\n","import { ErrorCode } from '../../types';\nimport { DataTransferError } from './base';\nimport { Severity, SeverityKind } from './constants';\n\ntype ProviderStep = 'initialization' | 'validation' | 'transfer';\n\nexport type ProviderErrorDetails<P extends ProviderStep = ProviderStep, U = never> = {\n  step: P;\n  code?: ErrorCode;\n} & ([U] extends [never] ? unknown : { details?: U });\n\nexport class ProviderError<\n  P extends ProviderStep = ProviderStep,\n  U = never,\n  T extends ProviderErrorDetails<P, U> = ProviderErrorDetails<P, U>,\n> extends DataTransferError<T> {\n  constructor(severity: Severity, message?: string, details?: T | null) {\n    super('provider', severity, message, details);\n  }\n}\n\nexport class ProviderInitializationError extends ProviderError<'initialization'> {\n  constructor(message?: string) {\n    super(SeverityKind.FATAL, message, { step: 'initialization' });\n  }\n}\n\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\nexport class ProviderValidationError<T = ProviderErrorDetails> extends ProviderError<\n  'validation',\n  T\n> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.SILLY, message, { step: 'validation', details });\n  }\n}\n// TODO: these types are not working correctly, ProviderTransferError() is accepting any details object rather than requiring T\nexport class ProviderTransferError<T = ProviderErrorDetails> extends ProviderError<'transfer', T> {\n  constructor(message?: string, details?: T) {\n    super(SeverityKind.FATAL, message, { step: 'transfer', details });\n  }\n}\n","import { PassThrough, Transform, Readable, Writable } from 'stream';\nimport { extname } from 'path';\nimport { EOL } from 'os';\nimport type Chain from 'stream-chain';\nimport { chain } from 'stream-chain';\nimport { isEmpty, uniq, last, isNumber, set, pick } from 'lodash/fp';\nimport { diff as semverDiff } from 'semver';\n\nimport type { Struct, Utils } from '@strapi/types';\n\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IEntity,\n  ILink,\n  IMetadata,\n  ISourceProvider,\n  ITransferEngine,\n  ITransferEngineOptions,\n  TransferProgress,\n  ITransferResults,\n  TransferStage,\n  TransferTransform,\n  IProvider,\n  TransferFilters,\n  TransferFilterPreset,\n  StreamItem,\n  SchemaDiffHandler,\n  SchemaDiffHandlerContext,\n  ErrorHandler,\n  ErrorHandlerContext,\n  ErrorHandlers,\n  ErrorCode,\n} from '../../types';\nimport type { Diff } from '../utils/json';\n\nimport { compareSchemas, validateProvider } from './validation';\n\nimport { TransferEngineError, TransferEngineValidationError } from './errors';\nimport {\n  createDiagnosticReporter,\n  IDiagnosticReporter,\n  ErrorDiagnosticSeverity,\n} from '../utils/diagnostic';\nimport { DataTransferError } from '../errors';\nimport * as utils from '../utils';\nimport { ProviderTransferError } from '../errors/providers';\n\nexport const TRANSFER_STAGES: ReadonlyArray<TransferStage> = Object.freeze([\n  'entities',\n  'links',\n  'assets',\n  'schemas',\n  'configuration',\n]);\n\nexport type TransferGroupFilter = Record<TransferFilterPreset, TransferFilters>;\n\n/**\n * Preset filters for only/exclude options\n * */\nexport const TransferGroupPresets: TransferGroupFilter = {\n  content: {\n    links: true, // Example: content includes the entire links stage\n    entities: true,\n    // TODO: If we need to implement filtering on a running stage, it would be done like this, but we still need to implement it\n    // [\n    //   // Example: content processes the entities stage, but filters individual entities\n    //   {\n    //     filter(data) {\n    //       return shouldIncludeThisData(data);\n    //     },\n    //   },\n    // ],\n  },\n  files: {\n    assets: true,\n  },\n  config: {\n    configuration: true,\n  },\n};\n\nexport const DEFAULT_VERSION_STRATEGY = 'ignore';\nexport const DEFAULT_SCHEMA_STRATEGY = 'strict';\n\ntype SchemaMap = Utils.String.Dict<Struct.Schema>;\n\nclass TransferEngine<\n  S extends ISourceProvider = ISourceProvider,\n  D extends IDestinationProvider = IDestinationProvider,\n> implements ITransferEngine\n{\n  sourceProvider: ISourceProvider;\n\n  destinationProvider: IDestinationProvider;\n\n  options: ITransferEngineOptions;\n\n  #metadata: { source?: IMetadata; destination?: IMetadata } = {};\n\n  #schema: { source?: SchemaMap; destination?: SchemaMap } = {};\n\n  // Progress of the current stage\n  progress: {\n    // metrics on the progress such as size and record count\n    data: TransferProgress;\n    // stream that emits events\n    stream: PassThrough;\n  };\n\n  diagnostics: IDiagnosticReporter;\n\n  #handlers: {\n    schemaDiff: SchemaDiffHandler[];\n    errors: Partial<ErrorHandlers>;\n  } = {\n    schemaDiff: [],\n    errors: {},\n  };\n\n  onSchemaDiff(handler: SchemaDiffHandler) {\n    this.#handlers?.schemaDiff?.push(handler);\n  }\n\n  addErrorHandler(handlerName: ErrorCode, handler: ErrorHandler) {\n    if (!this.#handlers.errors[handlerName]) {\n      this.#handlers.errors[handlerName] = [];\n    }\n    this.#handlers.errors[handlerName]?.push(handler);\n  }\n\n  async attemptResolveError(error: Error) {\n    const context: ErrorHandlerContext = {};\n    if (error instanceof ProviderTransferError && error.details?.details.code) {\n      const errorCode = error.details?.details.code as ErrorCode;\n      if (!this.#handlers.errors[errorCode]) {\n        this.#handlers.errors[errorCode] = [];\n      }\n      await utils.middleware.runMiddleware(context ?? {}, this.#handlers.errors[errorCode] ?? []);\n    }\n\n    return !!context.ignore;\n  }\n\n  // Save the currently open stream so that we can access it at any time\n  #currentStream?: Writable;\n\n  constructor(sourceProvider: S, destinationProvider: D, options: ITransferEngineOptions) {\n    this.diagnostics = createDiagnosticReporter();\n\n    validateProvider('source', sourceProvider);\n    validateProvider('destination', destinationProvider);\n\n    this.sourceProvider = sourceProvider;\n    this.destinationProvider = destinationProvider;\n    this.options = options;\n\n    this.progress = { data: {}, stream: new PassThrough({ objectMode: true }) };\n  }\n\n  /**\n   * Report a fatal error and throw it\n   */\n  panic(error: Error) {\n    this.reportError(error, 'fatal');\n\n    throw error;\n  }\n\n  /**\n   * Report an error diagnostic\n   */\n  reportError(error: Error, severity: ErrorDiagnosticSeverity) {\n    this.diagnostics.report({\n      kind: 'error',\n      details: {\n        severity,\n        createdAt: new Date(),\n        name: error.name,\n        message: error.message,\n        error,\n      },\n    });\n  }\n\n  /**\n   * Report a warning diagnostic\n   */\n  reportWarning(message: string, origin?: string) {\n    this.diagnostics.report({\n      kind: 'warning',\n      details: { createdAt: new Date(), message, origin },\n    });\n  }\n\n  /**\n   * Report an info diagnostic\n   */\n  reportInfo(message: string, params?: unknown) {\n    this.diagnostics.report({\n      kind: 'info',\n      details: { createdAt: new Date(), message, params, origin: 'engine' },\n    });\n  }\n\n  /**\n   * Create and return a transform stream based on the given stage and options.\n   *\n   * Allowed transformations includes 'filter' and 'map'.\n   */\n  #createStageTransformStream<T extends TransferStage>(\n    key: T,\n    options: { includeGlobal?: boolean } = {}\n  ): PassThrough | Transform {\n    const { includeGlobal = true } = options;\n    const { throttle } = this.options;\n    const { global: globalTransforms, [key]: stageTransforms } = this.options?.transforms ?? {};\n\n    let stream: PassThrough | Chain = new PassThrough({ objectMode: true });\n\n    const applyTransforms = <U>(transforms: TransferTransform<U>[] = []) => {\n      const chainTransforms: StreamItem[] = [];\n      for (const transform of transforms) {\n        if ('filter' in transform) {\n          chainTransforms.push(utils.stream.filter(transform.filter));\n        }\n\n        if ('map' in transform) {\n          chainTransforms.push(utils.stream.map(transform.map));\n        }\n      }\n      if (chainTransforms.length) {\n        stream = stream.pipe(chain(chainTransforms));\n      }\n    };\n\n    if (includeGlobal) {\n      applyTransforms(globalTransforms);\n    }\n\n    if (isNumber(throttle) && throttle > 0) {\n      stream = stream.pipe(\n        new PassThrough({\n          objectMode: true,\n          async transform(data, _encoding, callback) {\n            await new Promise((resolve) => {\n              setTimeout(resolve, throttle);\n            });\n            callback(null, data);\n          },\n        })\n      );\n    }\n\n    applyTransforms(stageTransforms as TransferTransform<unknown>[]);\n\n    return stream;\n  }\n\n  /**\n   * Update the Engine's transfer progress data for a given stage.\n   *\n   * Providing aggregate options enable custom computation to get the size (bytes) or the aggregate key associated with the data\n   */\n  #updateTransferProgress<T = unknown>(\n    stage: TransferStage,\n    data: T,\n    aggregate?: {\n      size?: (value: T) => number;\n      key?: (value: T) => string;\n    }\n  ) {\n    if (!this.progress.data[stage]) {\n      this.progress.data[stage] = { count: 0, bytes: 0, startTime: Date.now() };\n    }\n\n    const stageProgress = this.progress.data[stage];\n\n    if (!stageProgress) {\n      return;\n    }\n\n    const size = aggregate?.size?.(data) ?? JSON.stringify(data).length;\n    const key = aggregate?.key?.(data);\n\n    stageProgress.count += 1;\n    stageProgress.bytes += size;\n\n    // Handle aggregate updates if necessary\n    if (key) {\n      if (!stageProgress.aggregates) {\n        stageProgress.aggregates = {};\n      }\n\n      const { aggregates } = stageProgress;\n\n      if (!aggregates[key]) {\n        aggregates[key] = { count: 0, bytes: 0 };\n      }\n\n      aggregates[key].count += 1;\n      aggregates[key].bytes += size;\n    }\n  }\n\n  /**\n   * Create and return a PassThrough stream.\n   *\n   * Upon writing data into it, it'll update the Engine's transfer progress data and trigger stage update events.\n   */\n  #progressTracker(\n    stage: TransferStage,\n    aggregate?: {\n      size?(value: unknown): number;\n      key?(value: unknown): string;\n    }\n  ) {\n    return new PassThrough({\n      objectMode: true,\n      transform: (data, _encoding, callback) => {\n        this.#updateTransferProgress(stage, data, aggregate);\n        this.#emitStageUpdate('progress', stage);\n        callback(null, data);\n      },\n    });\n  }\n\n  /**\n   * Shorthand method used to trigger transfer update events to every listeners\n   */\n  #emitTransferUpdate(type: 'init' | 'start' | 'finish' | 'error', payload?: object) {\n    this.progress.stream.emit(`transfer::${type}`, payload);\n  }\n\n  /**\n   * Shorthand method used to trigger stage update events to every listeners\n   */\n  #emitStageUpdate(\n    type: 'start' | 'finish' | 'progress' | 'skip' | 'error',\n    transferStage: TransferStage\n  ) {\n    this.progress.stream.emit(`stage::${type}`, {\n      data: this.progress.data,\n      stage: transferStage,\n    });\n  }\n\n  /**\n   * Run a version check between two strapi version (source and destination) using the strategy given to the engine during initialization.\n   *\n   * If there is a mismatch, throws a validation error.\n   */\n  #assertStrapiVersionIntegrity(sourceVersion?: string, destinationVersion?: string) {\n    const strategy = this.options.versionStrategy || DEFAULT_VERSION_STRATEGY;\n\n    const reject = () => {\n      throw new TransferEngineValidationError(\n        `The source and destination provide are targeting incompatible Strapi versions (using the \"${strategy}\" strategy). The source (${this.sourceProvider.name}) version is ${sourceVersion} and the destination (${this.destinationProvider.name}) version is ${destinationVersion}`,\n        {\n          check: 'strapi.version',\n          strategy,\n          versions: { source: sourceVersion, destination: destinationVersion },\n        }\n      );\n    };\n\n    if (\n      !sourceVersion ||\n      !destinationVersion ||\n      strategy === 'ignore' ||\n      destinationVersion === sourceVersion\n    ) {\n      return;\n    }\n\n    let diff;\n    try {\n      diff = semverDiff(sourceVersion, destinationVersion);\n    } catch {\n      reject();\n    }\n\n    if (!diff) {\n      return;\n    }\n\n    const validPatch = ['prelease', 'build'];\n    const validMinor = [...validPatch, 'patch', 'prepatch'];\n    const validMajor = [...validMinor, 'minor', 'preminor'];\n    if (strategy === 'patch' && validPatch.includes(diff)) {\n      return;\n    }\n    if (strategy === 'minor' && validMinor.includes(diff)) {\n      return;\n    }\n    if (strategy === 'major' && validMajor.includes(diff)) {\n      return;\n    }\n\n    reject();\n  }\n\n  /**\n   * Run a check between two set of schemas (source and destination) using the strategy given to the engine during initialization.\n   *\n   * If there are differences and/or incompatibilities between source and destination schemas, then throw a validation error.\n   */\n  #assertSchemasMatching(sourceSchemas: SchemaMap, destinationSchemas: SchemaMap) {\n    const strategy = this.options.schemaStrategy || DEFAULT_SCHEMA_STRATEGY;\n\n    if (strategy === 'ignore') {\n      return;\n    }\n\n    const keys = uniq(Object.keys(sourceSchemas).concat(Object.keys(destinationSchemas)));\n    const diffs: { [key: string]: Diff[] } = {};\n\n    keys.forEach((key) => {\n      const sourceSchema = sourceSchemas[key];\n      const destinationSchema = destinationSchemas[key];\n      const schemaDiffs = compareSchemas(sourceSchema, destinationSchema, strategy);\n\n      if (schemaDiffs.length) {\n        diffs[key] = schemaDiffs as Diff<Struct.Schema>[];\n      }\n    });\n\n    if (!isEmpty(diffs)) {\n      const formattedDiffs = Object.entries(diffs)\n        .map(([uid, ctDiffs]) => {\n          let msg = `- ${uid}:${EOL}`;\n\n          msg += ctDiffs\n            .sort((a, b) => (a.kind > b.kind ? -1 : 1))\n            .map((diff) => {\n              const path = diff.path.join('.');\n\n              if (diff.kind === 'added') {\n                return `${path} exists in destination schema but not in source schema and the data will not be transferred.`;\n              }\n\n              if (diff.kind === 'deleted') {\n                return `${path} exists in source schema but not in destination schema and the data will not be transferred.`;\n              }\n\n              if (diff.kind === 'modified') {\n                if (diff.types[0] === diff.types[1]) {\n                  return `Schema value changed at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\n                }\n\n                return `Schema has differing data types at \"${path}\": \"${diff.values[0]}\" (${diff.types[0]}) => \"${diff.values[1]}\" (${diff.types[1]})`;\n              }\n\n              throw new TransferEngineValidationError(`Invalid diff found for \"${uid}\"`, {\n                check: `schema on ${uid}`,\n              });\n            })\n            .map((line) => `  - ${line}`)\n            .join(EOL);\n\n          return msg;\n        })\n        .join(EOL);\n\n      throw new TransferEngineValidationError(\n        `Invalid schema changes detected during integrity checks (using the ${strategy} strategy). Please find a summary of the changes below:\\n${formattedDiffs}`,\n        {\n          check: 'schema.changes',\n          strategy,\n          diffs,\n        }\n      );\n    }\n  }\n\n  shouldSkipStage(stage: TransferStage) {\n    const { exclude, only } = this.options;\n\n    // schemas must always be included\n    if (stage === 'schemas') {\n      return false;\n    }\n\n    // everything is included by default unless 'only' has been set\n    let included = isEmpty(only);\n    if (only && only.length > 0) {\n      included = only.some((transferGroup) => {\n        return TransferGroupPresets[transferGroup][stage];\n      });\n    }\n\n    if (exclude && exclude.length > 0) {\n      if (included) {\n        included = !exclude.some((transferGroup) => {\n          return TransferGroupPresets[transferGroup][stage];\n        });\n      }\n    }\n\n    return !included;\n  }\n\n  async #transferStage(options: {\n    stage: TransferStage;\n    source?: Readable;\n    destination?: Writable;\n    transform?: PassThrough | Chain;\n    tracker?: PassThrough;\n  }) {\n    const { stage, source, destination, transform, tracker } = options;\n\n    const updateEndTime = () => {\n      const stageData = this.progress.data[stage];\n\n      if (stageData) {\n        stageData.endTime = Date.now();\n      }\n    };\n\n    if (!source || !destination || this.shouldSkipStage(stage)) {\n      // Wait until source and destination are closed\n      const results = await Promise.allSettled(\n        [source, destination].map((stream) => {\n          // if stream is undefined or already closed, resolve immediately\n          if (!stream || stream.destroyed) {\n            return Promise.resolve();\n          }\n\n          // Wait until the close event is produced and then destroy the stream and resolve\n          return new Promise((resolve, reject) => {\n            stream.on('close', resolve).on('error', reject).destroy();\n          });\n        })\n      );\n\n      results.forEach((state) => {\n        if (state.status === 'rejected') {\n          this.reportWarning(state.reason, `transfer(${stage})`);\n        }\n      });\n\n      this.#emitStageUpdate('skip', stage);\n\n      return;\n    }\n\n    this.#emitStageUpdate('start', stage);\n\n    await new Promise<void>((resolve, reject) => {\n      let stream: Readable = source;\n\n      if (transform) {\n        stream = stream.pipe(transform);\n      }\n\n      if (tracker) {\n        stream = stream.pipe(tracker);\n      }\n\n      this.#currentStream = stream\n        .pipe(destination)\n        .on('error', (e) => {\n          updateEndTime();\n          this.#emitStageUpdate('error', stage);\n          this.reportError(e, 'error');\n          destination.destroy(e);\n          reject(e);\n        })\n        .on('close', () => {\n          this.#currentStream = undefined;\n          updateEndTime();\n          resolve();\n        });\n    });\n\n    this.#emitStageUpdate('finish', stage);\n  }\n\n  // Cause an ongoing transfer to abort gracefully\n  async abortTransfer(): Promise<void> {\n    const err = new TransferEngineError('fatal', 'Transfer aborted.');\n    if (!this.#currentStream) {\n      throw err;\n    }\n    this.#currentStream.destroy(err);\n  }\n\n  async init(): Promise<void> {\n    // Resolve providers' resource and store\n    // them in the engine's internal state\n    await this.#resolveProviderResource();\n\n    // Update the destination provider's source metadata\n    const { source: sourceMetadata } = this.#metadata;\n\n    if (sourceMetadata) {\n      this.destinationProvider.setMetadata?.('source', sourceMetadata);\n    }\n  }\n\n  /**\n   * Run the bootstrap method in both source and destination providers\n   */\n  async bootstrap(): Promise<void> {\n    const results = await Promise.allSettled([\n      this.sourceProvider.bootstrap?.(this.diagnostics),\n      this.destinationProvider.bootstrap?.(this.diagnostics),\n    ]);\n\n    results.forEach((result) => {\n      if (result.status === 'rejected') {\n        this.panic(result.reason);\n      }\n    });\n  }\n\n  /**\n   * Run the close method in both source and destination providers\n   */\n  async close(): Promise<void> {\n    const results = await Promise.allSettled([\n      this.sourceProvider.close?.(),\n      this.destinationProvider.close?.(),\n    ]);\n\n    results.forEach((result) => {\n      if (result.status === 'rejected') {\n        this.panic(result.reason);\n      }\n    });\n  }\n\n  async #resolveProviderResource() {\n    const sourceMetadata = await this.sourceProvider.getMetadata();\n    const destinationMetadata = await this.destinationProvider.getMetadata();\n\n    if (sourceMetadata) {\n      this.#metadata.source = sourceMetadata;\n    }\n\n    if (destinationMetadata) {\n      this.#metadata.destination = destinationMetadata;\n    }\n  }\n\n  async #getSchemas() {\n    if (!this.#schema.source) {\n      this.#schema.source = (await this.sourceProvider.getSchemas?.()) as SchemaMap;\n    }\n\n    if (!this.#schema.destination) {\n      this.#schema.destination = (await this.destinationProvider.getSchemas?.()) as SchemaMap;\n    }\n\n    return {\n      sourceSchemas: this.#schema.source,\n      destinationSchemas: this.#schema.destination,\n    };\n  }\n\n  async integrityCheck() {\n    const sourceMetadata = await this.sourceProvider.getMetadata();\n    const destinationMetadata = await this.destinationProvider.getMetadata();\n\n    if (sourceMetadata && destinationMetadata) {\n      this.#assertStrapiVersionIntegrity(\n        sourceMetadata?.strapi?.version,\n        destinationMetadata?.strapi?.version\n      );\n    }\n\n    const { sourceSchemas, destinationSchemas } = await this.#getSchemas();\n\n    try {\n      if (sourceSchemas && destinationSchemas) {\n        this.#assertSchemasMatching(sourceSchemas, destinationSchemas);\n      }\n    } catch (error) {\n      // if this is a schema matching error, allow handlers to resolve it\n      if (error instanceof TransferEngineValidationError && error.details?.details?.diffs) {\n        const schemaDiffs = error.details?.details?.diffs as Record<string, Diff[]>;\n\n        const context: SchemaDiffHandlerContext = {\n          ignoredDiffs: {},\n          diffs: schemaDiffs,\n          source: this.sourceProvider,\n          destination: this.destinationProvider,\n        };\n\n        // if we don't have any handlers, throw the original error\n        if (isEmpty(this.#handlers.schemaDiff)) {\n          throw error;\n        }\n\n        await utils.middleware.runMiddleware<SchemaDiffHandlerContext>(\n          context,\n          this.#handlers.schemaDiff\n        );\n\n        // if there are any remaining diffs that weren't ignored\n        const unresolvedDiffs = utils.json.diff(context.diffs, context.ignoredDiffs);\n        if (unresolvedDiffs.length) {\n          this.panic(\n            new TransferEngineValidationError('Unresolved differences in schema', {\n              check: 'schema.changes',\n              unresolvedDiffs,\n            })\n          );\n        }\n\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  async transfer(): Promise<ITransferResults<S, D>> {\n    // reset data between transfers\n    this.progress.data = {};\n\n    try {\n      this.#emitTransferUpdate('init');\n      await this.bootstrap();\n      await this.init();\n\n      await this.integrityCheck();\n\n      this.#emitTransferUpdate('start');\n\n      await this.beforeTransfer();\n\n      // Run the transfer stages\n      await this.transferSchemas();\n      await this.transferEntities();\n      await this.transferAssets();\n      await this.transferLinks();\n      await this.transferConfiguration();\n      // Gracefully close the providers\n      await this.close();\n\n      this.#emitTransferUpdate('finish');\n    } catch (e: unknown) {\n      this.#emitTransferUpdate('error', { error: e });\n\n      const lastDiagnostic = last(this.diagnostics.stack.items);\n      // Do not report an error diagnostic if the last one reported the same error\n      if (\n        e instanceof Error &&\n        (!lastDiagnostic || lastDiagnostic.kind !== 'error' || lastDiagnostic.details.error !== e)\n      ) {\n        this.reportError(e, (e as DataTransferError).severity || 'fatal');\n      }\n\n      // Rollback the destination provider if an exception is thrown during the transfer\n      // Note: This will be configurable in the future\n      await this.destinationProvider.rollback?.(e as Error);\n\n      throw e;\n    }\n\n    return {\n      source: this.sourceProvider.results,\n      destination: this.destinationProvider.results,\n      engine: this.progress.data,\n    };\n  }\n\n  async beforeTransfer(): Promise<void> {\n    const runWithDiagnostic = async (provider: IProvider) => {\n      try {\n        await provider.beforeTransfer?.();\n      } catch (error) {\n        if (error instanceof Error) {\n          const resolved = await this.attemptResolveError(error);\n\n          if (resolved) {\n            return;\n          }\n          this.panic(error);\n        } else {\n          this.panic(\n            new Error(`Unknwon error when executing \"beforeTransfer\" on the ${origin} provider`)\n          );\n        }\n      }\n    };\n\n    await runWithDiagnostic(this.sourceProvider);\n    await runWithDiagnostic(this.destinationProvider);\n  }\n\n  async transferSchemas(): Promise<void> {\n    const stage: TransferStage = 'schemas';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createSchemasReadStream?.();\n    const destination = await this.destinationProvider.createSchemasWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage, {\n      key: (value: Struct.Schema) => value.modelType,\n    });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferEntities(): Promise<void> {\n    const stage: TransferStage = 'entities';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createEntitiesReadStream?.();\n    const destination = await this.destinationProvider.createEntitiesWriteStream?.();\n\n    const transform = chain([\n      this.#createStageTransformStream(stage),\n      new Transform({\n        objectMode: true,\n        transform: async (entity: IEntity, _encoding, callback) => {\n          const { destinationSchemas: schemas } = await this.#getSchemas();\n\n          if (!schemas) {\n            return callback(null, entity);\n          }\n\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\n          const availableContentTypes = Object.entries(schemas)\n            .filter(([, schema]) => schema.modelType === 'contentType')\n            .map(([uid]) => uid);\n\n          // If the type of the transferred entity doesn't exist in the destination, then discard it\n          if (!availableContentTypes.includes(entity.type)) {\n            return callback(null, undefined);\n          }\n\n          const { type, data } = entity;\n          const attributes = schemas[type].attributes;\n          const attributesToKeep = Object.keys(attributes).concat('documentId');\n          const updatedEntity = set('data', pick(attributesToKeep, data), entity);\n\n          callback(null, updatedEntity);\n        },\n      }),\n    ]);\n\n    const tracker = this.#progressTracker(stage, { key: (value: IEntity) => value.type });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferLinks(): Promise<void> {\n    const stage: TransferStage = 'links';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createLinksReadStream?.();\n    const destination = await this.destinationProvider.createLinksWriteStream?.();\n\n    const transform = chain([\n      this.#createStageTransformStream(stage),\n      new Transform({\n        objectMode: true,\n        transform: async (link: ILink, _encoding, callback) => {\n          const { destinationSchemas: schemas } = await this.#getSchemas();\n          if (!schemas) {\n            return callback(null, link);\n          }\n\n          // TODO: this would be safer if we only ignored things in ignoredDiffs, otherwise continue and let an error be thrown\n          const availableContentTypes = Object.keys(schemas);\n\n          const isValidType = (uid: string) => availableContentTypes.includes(uid);\n\n          if (!isValidType(link.left.type) || !isValidType(link.right.type)) {\n            return callback(null, undefined); // ignore the link\n          }\n\n          callback(null, link);\n        },\n      }),\n    ]);\n\n    const tracker = this.#progressTracker(stage);\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferAssets(): Promise<void> {\n    const stage: TransferStage = 'assets';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createAssetsReadStream?.();\n    const destination = await this.destinationProvider.createAssetsWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage, {\n      size: (value: IAsset) => value.stats.size,\n      key: (value: IAsset) => extname(value.filename) || 'No extension',\n    });\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n\n  async transferConfiguration(): Promise<void> {\n    const stage: TransferStage = 'configuration';\n    if (this.shouldSkipStage(stage)) {\n      return;\n    }\n\n    const source = await this.sourceProvider.createConfigurationReadStream?.();\n    const destination = await this.destinationProvider.createConfigurationWriteStream?.();\n\n    const transform = this.#createStageTransformStream(stage);\n    const tracker = this.#progressTracker(stage);\n\n    await this.#transferStage({ stage, source, destination, transform, tracker });\n  }\n}\n\nexport const createTransferEngine = <S extends ISourceProvider, D extends IDestinationProvider>(\n  sourceProvider: S,\n  destinationProvider: D,\n  options: ITransferEngineOptions\n): TransferEngine<S, D> => {\n  return new TransferEngine<S, D>(sourceProvider, destinationProvider, options);\n};\n\nexport type {\n  TransferEngine,\n  ITransferEngine,\n  ITransferEngineOptions,\n  ISourceProvider,\n  IDestinationProvider,\n  TransferStage,\n  TransferFilterPreset,\n  ErrorHandlerContext,\n  SchemaDiffHandlerContext,\n  ITransferResults,\n};\n\nexport * as errors from './errors';\n","import _ from 'lodash';\nimport { get, has, omit, pipe, assign } from 'lodash/fp';\n\nimport { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';\nimport type { Modules, UID, Data, Utils, Schema, Core } from '@strapi/types';\n\ntype LoadedComponents<TUID extends UID.Schema> = Data.Entity<\n  TUID,\n  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>\n>;\n\ntype ComponentValue = Schema.Attribute.Value<\n  Schema.Attribute.Component<UID.Component, false> | Schema.Attribute.Component<UID.Component, true>\n>;\n\ntype ComponentBody = {\n  [key: string]: Schema.Attribute.Value<\n    | Schema.Attribute.Component<UID.Component, false>\n    | Schema.Attribute.Component<UID.Component, true>\n    | Schema.Attribute.DynamicZone\n  >;\n};\n\nconst isDialectMySQL = () => strapi.db?.dialect.client === 'mysql';\n\nfunction omitComponentData(\n  contentType: Schema.ContentType,\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>\n): Partial<Modules.EntityService.Params.Data.Input<Schema.ContentType['uid']>>;\nfunction omitComponentData(\n  contentType: Schema.Component,\n  data: Modules.EntityService.Params.Data.Input<Schema.Component['uid']>\n): Partial<Modules.EntityService.Params.Data.Input<Schema.Component['uid']>>;\nfunction omitComponentData(\n  contentType: Schema.ContentType | Schema.Component,\n  data: Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\n): Partial<\n  Modules.EntityService.Params.Data.Input<Schema.ContentType['uid'] | Schema.Component['uid']>\n> {\n  const { attributes } = contentType;\n  const componentAttributes = Object.keys(attributes).filter((attributeName) =>\n    contentTypesUtils.isComponentAttribute(attributes[attributeName])\n  );\n\n  return omit(componentAttributes, data);\n}\n\n// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer\nconst createComponents = async <\n  TUID extends UID.Schema,\n  TData extends Modules.EntityService.Params.Data.Input<TUID>,\n>(\n  uid: TUID,\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[attributeName as keyof TData];\n\n      if (componentValue === null) {\n        continue;\n      }\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components = (await async.map(\n          componentValue,\n          (value: any) => createComponent(componentUID, value),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n\n        componentBody[attributeName] = components.map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await createComponent(\n          componentUID,\n          componentValue as Modules.EntityService.Params.Data.Input<UID.Component>\n        );\n        componentBody[attributeName] = {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      const createDynamicZoneComponents = async (\n        value: Utils.Array.Values<typeof dynamiczoneValues>\n      ) => {\n        const { id } = await createComponent(value.__component, value);\n        return {\n          id,\n          __component: value.__component,\n          __pivot: {\n            field: attributeName,\n          },\n        };\n      };\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        createDynamicZoneComponents,\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst getComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entity: { id: Modules.EntityService.Params.Attribute.ID }\n): Promise<LoadedComponents<TUID>> => {\n  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));\n\n  if (_.isEmpty(componentAttributes)) {\n    return {} as LoadedComponents<TUID>;\n  }\n\n  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;\n};\n\n/*\n  delete old components\n  create or update\n*/\nconst updateComponents = async <\n  TUID extends UID.Schema,\n  TData extends Partial<Modules.EntityService.Params.Data.Input<TUID>>,\n>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[\n        attributeName as keyof TData\n      ] as Schema.Attribute.Value<Schema.Attribute.Component>;\n\n      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components = (await async.map(\n          componentValue,\n          (value: any) => updateOrCreateComponent(componentUID, value),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        )) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n\n        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await updateOrCreateComponent(componentUID, componentValue);\n        componentBody[attributeName] = component && {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        async (value: any) => {\n          const { id } = await updateOrCreateComponent(value.__component, value);\n\n          return {\n            id,\n            __component: value.__component,\n            __pivot: {\n              field: attributeName,\n            },\n          };\n        },\n        { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst pickStringifiedId = ({\n  id,\n}: {\n  id: Modules.EntityService.Params.Attribute.ID;\n}): Modules.EntityService.Params.Attribute.ID & string => {\n  if (typeof id === 'string') {\n    return id;\n  }\n\n  return `${id}`;\n};\n\nconst deleteOldComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  componentUID: UID.Component,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  componentValue: Schema.Attribute.Value<Schema.Attribute.Component>\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as ComponentValue;\n\n  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);\n  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);\n\n  idsToKeep.forEach((id) => {\n    if (!allIds.includes(id)) {\n      throw new errors.ApplicationError(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n    }\n  });\n\n  const idsToDelete = _.difference(allIds, idsToKeep);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      await deleteComponent(componentUID, { id: idToDelete });\n    }\n  }\n};\n\nconst deleteOldDZComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  dynamiczoneValues: Schema.Attribute.Value<Schema.Attribute.DynamicZone>\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n  const idsToKeep = _.castArray(dynamiczoneValues)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  const allIds = _.castArray(previousValue)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  idsToKeep.forEach(({ id, __component }) => {\n    if (!allIds.find((el) => el.id === id && el.__component === __component)) {\n      const err = new Error(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n\n      Object.assign(err, { status: 400 });\n      throw err;\n    }\n  });\n\n  type IdsToDelete = Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n  const idsToDelete = allIds.reduce((acc, { id, __component }) => {\n    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {\n      acc.push({ id, __component });\n    }\n\n    return acc;\n  }, [] as IdsToDelete);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      const { id, __component } = idToDelete;\n      await deleteComponent(__component, { id });\n    }\n  }\n};\n\nconst deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(\n  uid: TUID,\n  entityToDelete: TEntity,\n  { loadComponents = true } = {}\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\n      let value;\n      if (loadComponents) {\n        value = await strapi.db.query(uid).load(entityToDelete, attributeName);\n      } else {\n        value = entityToDelete[attributeName as keyof TEntity];\n      }\n\n      if (!value) {\n        continue;\n      }\n\n      if (attribute.type === 'component') {\n        const { component: componentUID } = attribute;\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        await async.map(\n          _.castArray(value),\n          (subValue: any) => deleteComponent(componentUID, subValue),\n          {\n            concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity,\n          }\n        );\n      } else {\n        // delete dynamic zone components\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        await async.map(\n          _.castArray(value),\n          (subValue: any) => deleteComponent(subValue.__component, subValue),\n          { concurrency: isDialectMySQL() && !strapi.db?.inTransaction() ? 1 : Infinity }\n        );\n      }\n\n      continue;\n    }\n  }\n};\n\n/** *************************\n    Component queries\n************************** */\n\n// components can have nested compos so this must be recursive\nconst createComponent = async <TUID extends UID.Component = UID.Component>(\n  uid: TUID,\n  data: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  const model = strapi.getModel(uid) as Schema.Component;\n\n  const componentData = await createComponents(uid, data);\n  const transform = pipe(\n    // Make sure we don't save the component with a pre-defined ID\n    omit('id'),\n    // Remove the component data from the original data object ...\n    (payload) => omitComponentData(model, payload),\n    // ... and assign the newly created component instead\n    assign(componentData)\n  );\n\n  return strapi.db.query(uid).create({ data: transform(data) });\n};\n\n// components can have nested compos so this must be recursive\nconst updateComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  const model = strapi.getModel(uid) as Schema.Component;\n\n  const componentData = await updateComponents(uid, componentToUpdate, data);\n\n  return strapi.db.query(uid).update({\n    where: {\n      id: componentToUpdate.id,\n    },\n    data: Object.assign(omitComponentData(model, data), componentData),\n  });\n};\n\nconst updateOrCreateComponent = <TUID extends UID.Component>(\n  componentUID: TUID,\n  value: Modules.EntityService.Params.Data.Input<TUID>\n) => {\n  if (value === null) {\n    return null;\n  }\n\n  // update\n  if ('id' in value && typeof value.id !== 'undefined') {\n    // TODO: verify the compo is associated with the entity\n    return updateComponent(componentUID, { id: value.id }, value);\n  }\n\n  // create\n  return createComponent(componentUID, value);\n};\n\nconst deleteComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToDelete: Data.Component<TUID>\n) => {\n  await deleteComponents(uid, componentToDelete);\n  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });\n};\n\n/**\n * Resolve the component UID of an entity's attribute based\n * on a given path (components & dynamic zones only)\n */\nconst resolveComponentUID = ({\n  paths,\n  strapi,\n  data,\n  contentType,\n}: {\n  paths: string[];\n  strapi: Core.Strapi;\n  data: any;\n  contentType: Schema.ContentType;\n}): UID.Schema | undefined => {\n  let value: unknown = data;\n  let cType:\n    | Schema.ContentType\n    | Schema.Component\n    | ((...opts: any[]) => Schema.ContentType | Schema.Component) = contentType;\n  for (const path of paths) {\n    value = get(path, value);\n\n    // Needed when the value of cType should be computed\n    // based on the next value (eg: dynamic zones)\n    if (typeof cType === 'function') {\n      cType = cType(value);\n    }\n\n    if (path in cType.attributes) {\n      const attribute: Schema.Attribute.AnyAttribute = cType.attributes[path];\n\n      if (attribute.type === 'component') {\n        cType = strapi.getModel(attribute.component);\n      }\n\n      if (attribute.type === 'dynamiczone') {\n        cType = ({ __component }: { __component: UID.Component }) => strapi.getModel(__component);\n      }\n    }\n  }\n\n  if ('uid' in cType) {\n    return cType.uid;\n  }\n\n  return undefined;\n};\n\nexport {\n  omitComponentData,\n  getComponents,\n  createComponents,\n  updateComponents,\n  deleteComponents,\n  deleteComponent,\n  resolveComponentUID,\n};\n","import { assign, isArray, isEmpty, isObject, map, omit, size } from 'lodash/fp';\n\nimport type { Core, UID, Data, Struct } from '@strapi/types';\nimport * as componentsService from '../../utils/components';\n\nconst sanitizeComponentLikeAttributes = <T extends Struct.Schema>(\n  model: T,\n  data: Data.Entity<T['uid']>\n) => {\n  const { attributes } = model;\n\n  const componentLikeAttributesKey = Object.entries(attributes)\n    .filter(([, attribute]) => attribute.type === 'component' || attribute.type === 'dynamiczone')\n    .map(([key]) => key);\n\n  return omit(componentLikeAttributesKey, data);\n};\n\nconst omitInvalidCreationAttributes = omit(['id']);\n\nconst createEntityQuery = (strapi: Core.Strapi): any => {\n  const components = {\n    async assignToEntity(uid: UID.Schema, data: any) {\n      const model = strapi.getModel(uid);\n\n      const entityComponents = await componentsService.createComponents(uid, data);\n      const dataWithoutComponents = sanitizeComponentLikeAttributes(model, data);\n\n      return assign(entityComponents, dataWithoutComponents);\n    },\n\n    async get<T extends object>(uid: string, entity: T) {\n      return componentsService.getComponents(uid as UID.Schema, entity as any);\n    },\n\n    delete<T extends object>(uid: string, componentsToDelete: T) {\n      return componentsService.deleteComponents(uid as UID.Schema, componentsToDelete as any, {\n        loadComponents: false,\n      });\n    },\n  };\n\n  const query = (uid: UID.Schema) => {\n    const create = async <T extends { data: U }, U extends object>(params: T) => {\n      const dataWithComponents = await components.assignToEntity(uid, params.data);\n      const sanitizedData = omitInvalidCreationAttributes(dataWithComponents);\n\n      return strapi.db.query(uid).create({ ...params, data: sanitizedData });\n    };\n\n    const createMany = async <T extends { data: U[] }, U extends object>(params: T) => {\n      return (\n        Promise.resolve(params.data)\n          // Create components for each entity\n          .then(map((data) => components.assignToEntity(uid, data)))\n          // Remove unwanted attributes\n          .then(map(omitInvalidCreationAttributes))\n          // Execute a strapi db createMany query with all the entities + their created components\n          .then((data) => strapi.db.query(uid).createMany({ ...params, data }))\n      );\n    };\n\n    const deleteMany = async <T extends object>(params?: T) => {\n      const entitiesToDelete = await strapi.db.query(uid).findMany(params ?? {});\n\n      if (!entitiesToDelete.length) {\n        return null;\n      }\n\n      const componentsToDelete = await Promise.all(\n        entitiesToDelete.map((entityToDelete) => components.get(uid, entityToDelete))\n      );\n\n      const deletedEntities = await strapi.db.query(uid).deleteMany(params);\n      await Promise.all(componentsToDelete.map((compos) => components.delete(uid, compos)));\n\n      return deletedEntities;\n    };\n\n    const getDeepPopulateComponentLikeQuery = (\n      contentType: Struct.Schema,\n      params = { select: '*' }\n    ) => {\n      const { attributes } = contentType;\n\n      const populate: any = {};\n\n      const entries: [string, any][] = Object.entries(attributes);\n\n      for (const [key, attribute] of entries) {\n        if (attribute.type === 'component') {\n          const component = strapi.getModel(attribute.component);\n          const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\n\n          if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\n            populate[key] = { ...params, populate: subPopulate };\n          }\n\n          if (isArray(subPopulate) && isEmpty(subPopulate)) {\n            populate[key] = { ...params };\n          }\n        }\n\n        if (attribute.type === 'dynamiczone') {\n          const { components: componentsUID } = attribute;\n\n          const on: any = {};\n\n          for (const componentUID of componentsUID) {\n            const component = strapi.getModel(componentUID);\n            const subPopulate = getDeepPopulateComponentLikeQuery(component, params);\n\n            if ((isArray(subPopulate) || isObject(subPopulate)) && size(subPopulate) > 0) {\n              on[componentUID] = { ...params, populate: subPopulate };\n            }\n\n            if (isArray(subPopulate) && isEmpty(subPopulate)) {\n              on[componentUID] = { ...params };\n            }\n          }\n\n          populate[key] = size(on) > 0 ? { on } : true;\n        }\n      }\n\n      const values = Object.values(populate);\n\n      if (values.every((value) => value === true)) {\n        return Object.keys(populate);\n      }\n\n      return populate;\n    };\n\n    return {\n      create,\n      createMany,\n      deleteMany,\n      getDeepPopulateComponentLikeQuery,\n\n      get deepPopulateComponentLikeQuery() {\n        const contentType = strapi.getModel(uid);\n\n        return getDeepPopulateComponentLikeQuery(contentType);\n      },\n    };\n  };\n\n  return query;\n};\n\nexport { createEntityQuery };\n","import type { Knex } from 'knex';\nimport { clone, isNil } from 'lodash/fp';\nimport type { Core } from '@strapi/types';\n\nimport { ILink } from '../../../types';\n\n// TODO: Remove any types when we'll have types for DB metadata\n\nexport const createLinkQuery = (strapi: Core.Strapi, trx?: Knex.Transaction) => {\n  const query = () => {\n    const { connection } = strapi.db;\n\n    // TODO: Export utils from database and use the addSchema that is already written\n    const addSchema = (tableName: string) => {\n      const schemaName = connection.client.connectionSettings.schema;\n      return schemaName ? `${schemaName}.${tableName}` : tableName;\n    };\n\n    async function* generateAllForAttribute(uid: string, fieldName: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      if (!(fieldName in attributes)) {\n        throw new Error(`${fieldName} is not a valid relational attribute name`);\n      }\n\n      const attribute = attributes[fieldName];\n\n      const kind = getLinkKind(attribute, uid);\n      const { relation, target } = attribute;\n\n      // The relation is stored in the same table\n      // TODO: handle manyToOne joinColumn\n      if (attribute.joinColumn) {\n        const joinColumnName: string = attribute.joinColumn.name;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', joinColumnName)\n          .from(addSchema(metadata.tableName));\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[joinColumnName];\n\n          if (ref !== null) {\n            yield {\n              kind,\n              relation,\n              left: { type: uid, ref: entry.id, field: fieldName },\n              right: { type: target, ref },\n            };\n          }\n        }\n      }\n\n      // The relation uses a join table\n      if (attribute.joinTable) {\n        const {\n          name,\n          joinColumn,\n          inverseJoinColumn,\n          orderColumnName,\n          morphColumn,\n          inverseOrderColumnName,\n        } = attribute.joinTable;\n\n        const qb = connection.queryBuilder().from(addSchema(name));\n\n        type Columns = {\n          left: { ref: string | null; order?: string };\n          right: { ref: string | null; order?: string; type?: string; field?: string };\n        };\n\n        const columns: Columns = {\n          left: { ref: null },\n          right: { ref: null },\n        };\n\n        const left: Partial<ILink['left']> = { type: uid, field: fieldName };\n        const right: Partial<ILink['right']> = {};\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          right.type = attribute.target;\n          right.field = attribute.inversedBy;\n\n          columns.left.ref = joinColumn.name;\n          columns.right.ref = inverseJoinColumn.name;\n\n          if (orderColumnName) {\n            columns.left.order = orderColumnName as string;\n          }\n\n          if (inverseOrderColumnName) {\n            columns.right.order = inverseOrderColumnName as string;\n          }\n        }\n\n        if (kind === 'relation.morph') {\n          columns.left.ref = joinColumn.name;\n\n          columns.right.ref = morphColumn.idColumn.name;\n          columns.right.type = morphColumn.typeColumn.name;\n          columns.right.field = 'field';\n          columns.right.order = 'order';\n        }\n\n        const validColumns = [\n          // Left\n          columns.left.ref,\n          columns.left.order,\n          // Right\n          columns.right.ref,\n          columns.right.type,\n          columns.right.field,\n          columns.right.order,\n        ].filter((column: string | null | undefined) => !isNil(column));\n\n        qb.select(validColumns);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          if (columns.left.ref) {\n            left.ref = entry[columns.left.ref];\n          }\n\n          if (columns.right.ref) {\n            right.ref = entry[columns.right.ref];\n          }\n\n          if (columns.left.order) {\n            left.pos = entry[columns.left.order as string];\n          }\n\n          if (columns.right.order) {\n            right.pos = entry[columns.right.order as string];\n          }\n\n          if (columns.right.type) {\n            right.type = entry[columns.right.type as string];\n          }\n\n          if (columns.right.field) {\n            right.field = entry[columns.right.field as string];\n          }\n\n          const link: ILink = {\n            kind,\n            relation,\n            left: clone(left as ILink['left']),\n            right: clone(right as ILink['right']),\n          };\n\n          yield link;\n        }\n      }\n\n      if (attribute.morphColumn) {\n        const { typeColumn, idColumn } = attribute.morphColumn;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', typeColumn.name, idColumn.name)\n          .from(addSchema(metadata.tableName))\n          .whereNotNull(typeColumn.name)\n          .whereNotNull(idColumn.name);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[idColumn.name];\n\n          yield {\n            kind,\n            relation,\n            left: { type: uid, ref: entry.id, field: fieldName },\n            right: { type: entry[typeColumn.name], ref },\n          };\n        }\n      }\n    }\n\n    async function* generateAll(uid: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      for (const fieldName of Object.keys(attributes)) {\n        for await (const link of generateAllForAttribute(uid, fieldName)) {\n          yield link;\n        }\n      }\n    }\n\n    const insert = async (link: ILink) => {\n      const { kind, left, right } = link;\n\n      const metadata = strapi.db.metadata.get(left.type);\n      const attribute = metadata.attributes[left.field];\n\n      const payload = {};\n\n      /**\n       * This _should_ only happen for attributes that are added dynamically e.g. review-workflow stages\n       * and a user is importing EE data into a CE project.\n       */\n      if (!attribute) {\n        return;\n      }\n\n      if (attribute.type !== 'relation') {\n        throw new Error(`Attribute ${left.field} is not a relation`);\n      }\n\n      if ('joinColumn' in attribute && attribute.joinColumn) {\n        const joinColumnName = attribute.joinColumn.name;\n\n        // Note: this addSchema may not be necessary, but is added for safety\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({ [joinColumnName]: right.ref });\n        if (trx) {\n          qb.transacting(trx);\n        }\n        await qb;\n      }\n\n      if ('joinTable' in attribute && attribute.joinTable) {\n        const { joinTable } = attribute;\n\n        if (joinTable.joinColumn) {\n          Object.assign(payload, { [joinTable.joinColumn.name]: left.ref });\n        }\n\n        const assignInverseColumn = () => {\n          if ('inverseJoinColumn' in joinTable && joinTable.inverseJoinColumn) {\n            Object.assign(payload, {\n              [joinTable.inverseJoinColumn.name]: right.ref,\n            });\n          }\n        };\n\n        const assignOrderColumns = () => {\n          if ('orderColumnName' in joinTable && joinTable.orderColumnName) {\n            Object.assign(payload, { [joinTable.orderColumnName]: left.pos ?? null });\n          }\n\n          if ('inverseOrderColumnName' in joinTable && joinTable.inverseOrderColumnName) {\n            Object.assign(payload, { [joinTable.inverseOrderColumnName]: right.pos ?? null });\n          }\n        };\n\n        const assignMorphColumns = () => {\n          if ('morphColumn' in joinTable && joinTable.morphColumn) {\n            const { idColumn, typeColumn } = joinTable.morphColumn ?? {};\n\n            if (idColumn) {\n              Object.assign(payload, { [idColumn.name]: right.ref });\n            }\n\n            if (typeColumn) {\n              Object.assign(payload, { [typeColumn.name]: right.type });\n            }\n\n            Object.assign(payload, { order: right.pos ?? null, field: right.field ?? null });\n          }\n        };\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          assignInverseColumn();\n        }\n\n        if (kind === 'relation.morph') {\n          assignMorphColumns();\n        }\n\n        assignOrderColumns();\n        const qb = connection.insert(payload).into(addSchema(joinTable.name));\n        if (trx) {\n          await trx.transaction(async (nestedTrx) => {\n            await qb.transacting(nestedTrx);\n          });\n        }\n      }\n\n      if ('morphColumn' in attribute && attribute.morphColumn) {\n        const { morphColumn } = attribute;\n\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({\n            [morphColumn.idColumn.name]: right.ref,\n            [morphColumn.typeColumn.name]: right.type,\n          });\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        await qb;\n      }\n    };\n\n    return { generateAll, generateAllForAttribute, insert };\n  };\n\n  return query;\n};\n\nexport const filterValidRelationalAttributes = (attributes: Record<string, any>) => {\n  const isOwner = (attribute: any) => {\n    return attribute.owner || (!attribute.mappedBy && !attribute.morphBy);\n  };\n\n  const isComponentLike = (attribute: any) => attribute.joinTable?.name.endsWith('_cmps');\n\n  return Object.entries(attributes)\n    .filter(([, attribute]) => {\n      return attribute.type === 'relation' && isOwner(attribute) && !isComponentLike(attribute);\n    })\n    .reduce<Record<string, any>>((acc, [key, attribute]) => ({ ...acc, [key]: attribute }), {});\n};\n\nconst getLinkKind = (attribute: any, uid: string): ILink['kind'] => {\n  if (attribute.relation.startsWith('morph')) {\n    return 'relation.morph';\n  }\n\n  if (attribute.target === uid) {\n    return 'relation.circular';\n  }\n\n  return 'relation.basic';\n};\n","import { Writable } from 'stream';\nimport type { Core, UID } from '@strapi/types';\n\nimport { last } from 'lodash/fp';\n\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport type { IEntity, Transaction } from '../../../../../../types';\nimport { json } from '../../../../../utils';\nimport * as queries from '../../../../queries';\nimport { resolveComponentUID } from '../../../../../utils/components';\n\ninterface IEntitiesRestoreStreamOptions {\n  strapi: Core.Strapi;\n  updateMappingTable<TSchemaUID extends UID.Schema>(\n    type: TSchemaUID,\n    oldID: number,\n    newID: number\n  ): void;\n  transaction?: Transaction;\n}\n\nexport const createEntitiesWriteStream = (options: IEntitiesRestoreStreamOptions) => {\n  const { strapi, updateMappingTable, transaction } = options;\n  const query = queries.entity.createEntityQuery(strapi);\n\n  return new Writable({\n    objectMode: true,\n\n    async write(entity: IEntity, _encoding, callback) {\n      await transaction?.attach(async () => {\n        const { type, id, data } = entity;\n        const { create, getDeepPopulateComponentLikeQuery } = query(type);\n        const contentType = strapi.getModel(type);\n\n        try {\n          const created = await create({\n            data,\n            populate: getDeepPopulateComponentLikeQuery(contentType, { select: 'id' }),\n            select: 'id',\n          });\n\n          // Compute differences between original & new entities\n          const diffs = json.diff(data, created);\n\n          updateMappingTable(type, id, created.id);\n\n          // For each difference found on an ID attribute,\n          // update the mapping the table accordingly\n          diffs.forEach((diff) => {\n            if (diff.kind === 'modified' && last(diff.path) === 'id' && 'kind' in contentType) {\n              const target = resolveComponentUID({ paths: diff.path, data, contentType, strapi });\n\n              // If no type is found for the given path, then ignore the diff\n              if (!target) {\n                return;\n              }\n\n              const [oldID, newID] = diff.values as [number, number];\n\n              updateMappingTable(target, oldID, newID);\n            }\n          });\n        } catch (e) {\n          if (e instanceof Error) {\n            return callback(e);\n          }\n\n          return callback(new ProviderTransferError(`Failed to create \"${type}\" (${id})`));\n        }\n\n        return callback(null);\n      });\n    },\n  });\n};\n","import { Writable } from 'stream';\nimport { omit } from 'lodash/fp';\nimport chalk from 'chalk';\nimport type { Core } from '@strapi/types';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport { IConfiguration, Transaction } from '../../../../../../types';\n\nconst omitInvalidCreationAttributes = omit(['id']);\n\nconst restoreCoreStore = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\n  const data = omitInvalidCreationAttributes(values);\n  return strapi.db.query('strapi::core-store').create({\n    data: {\n      ...data,\n      value: JSON.stringify(data.value),\n    },\n  });\n};\n\nconst restoreWebhooks = async <T extends { value: unknown }>(strapi: Core.Strapi, values: T) => {\n  const data = omitInvalidCreationAttributes(values);\n  return strapi.db.query('strapi::webhook').create({ data });\n};\n\nexport const restoreConfigs = async (strapi: Core.Strapi, config: IConfiguration) => {\n  if (config.type === 'core-store') {\n    return restoreCoreStore(strapi, config.value as { value: unknown });\n  }\n\n  if (config.type === 'webhook') {\n    return restoreWebhooks(strapi, config.value as { value: unknown });\n  }\n};\n\nexport const createConfigurationWriteStream = async (\n  strapi: Core.Strapi,\n  transaction?: Transaction\n) => {\n  return new Writable({\n    objectMode: true,\n    async write<T extends { id: number }>(\n      config: IConfiguration<T>,\n      _encoding: BufferEncoding,\n      callback: (error?: Error | null) => void\n    ) {\n      await transaction?.attach(async () => {\n        try {\n          await restoreConfigs(strapi, config);\n        } catch (error) {\n          return callback(\n            new ProviderTransferError(\n              `Failed to import ${chalk.yellowBright(config.type)} (${chalk.greenBright(\n                config.value.id\n              )}`\n            )\n          );\n        }\n        callback();\n      });\n    },\n  });\n};\n","import { Writable } from 'stream';\nimport type { Core } from '@strapi/types';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport { ILink, Transaction } from '../../../../../../types';\nimport { createLinkQuery } from '../../../../queries/link';\n\ninterface ErrorWithCode extends Error {\n  code: string;\n}\n\nconst isErrorWithCode = (error: any): error is ErrorWithCode => {\n  return error && typeof error.code === 'string';\n};\n\nconst isForeignKeyConstraintError = (e: Error) => {\n  const MYSQL_FK_ERROR_CODES = ['1452', '1557', '1216', '1217', '1451'];\n  const POSTGRES_FK_ERROR_CODE = '23503';\n  const SQLITE_FK_ERROR_CODE = 'SQLITE_CONSTRAINT_FOREIGNKEY';\n\n  if (isErrorWithCode(e) && e.code) {\n    return [SQLITE_FK_ERROR_CODE, POSTGRES_FK_ERROR_CODE, ...MYSQL_FK_ERROR_CODES].includes(e.code);\n  }\n\n  return e.message.toLowerCase().includes('foreign key constraint');\n};\n\nexport const createLinksWriteStream = (\n  mapID: (uid: string, id: number) => number | undefined,\n  strapi: Core.Strapi,\n  transaction?: Transaction,\n  onWarning?: (message: string) => void\n) => {\n  return new Writable({\n    objectMode: true,\n    async write(link: ILink, _encoding, callback) {\n      await transaction?.attach(async (trx) => {\n        const { left, right } = link;\n        const query = createLinkQuery(strapi, trx);\n\n        const originalLeftRef = left.ref;\n        const originalRightRef = right.ref;\n\n        // Map IDs if needed\n        left.ref = mapID(left.type, originalLeftRef) ?? originalLeftRef;\n        right.ref = mapID(right.type, originalRightRef) ?? originalRightRef;\n\n        try {\n          await query().insert(link);\n        } catch (e) {\n          if (e instanceof Error) {\n            if (isForeignKeyConstraintError(e)) {\n              onWarning?.(\n                `Skipping link ${left.type}:${originalLeftRef} -> ${right.type}:${originalRightRef} due to a foreign key constraint.`\n              );\n              return callback(null);\n            }\n            return callback(e);\n          }\n\n          return callback(\n            new ProviderTransferError(\n              `An error happened while trying to import a ${left.type} link.`\n            )\n          );\n        }\n\n        callback(null);\n      });\n    },\n  });\n};\n","import type { Core, UID, Struct } from '@strapi/types';\nimport type { Model } from '@strapi/database';\nimport { ProviderTransferError } from '../../../../../errors/providers';\nimport * as queries from '../../../../queries';\n\nexport interface IRestoreOptions {\n  assets?: boolean; // delete media library files before transfer\n  configuration?: {\n    webhook?: boolean; // delete webhooks before transfer\n    coreStore?: boolean; // delete core store before transfer\n  };\n  entities?: {\n    include?: string[]; // only delete these stage entities before transfer\n    exclude?: string[]; // exclude these stage entities from deletion\n    filters?: ((contentType: Struct.ContentTypeSchema) => boolean)[]; // custom filters to exclude a content type from deletion\n    params?: { [uid: string]: unknown }; // params object passed to deleteMany before transfer for custom deletions\n  };\n}\n\ninterface IDeleteResults {\n  count: number;\n  aggregate: { [uid: string]: { count: number } };\n}\n\nexport const deleteRecords = async (strapi: Core.Strapi, options: IRestoreOptions) => {\n  const entities = await deleteEntitiesRecords(strapi, options);\n  const configuration = await deleteConfigurationRecords(strapi, options);\n\n  return {\n    count: entities.count + configuration.count,\n    entities,\n    configuration,\n  };\n};\n\nconst deleteEntitiesRecords = async (\n  strapi: Core.Strapi,\n  options: IRestoreOptions = {}\n): Promise<IDeleteResults> => {\n  const { entities } = options;\n\n  const models = strapi.get('models').get() as Model[];\n  const contentTypes = Object.values(strapi.contentTypes) as Struct.ContentTypeSchema[];\n\n  const contentTypesToClear = contentTypes\n    .filter((contentType) => {\n      let removeThisContentType = true;\n\n      // include means \"only include these types\" so if it's not in here, it's not being included\n      if (entities?.include) {\n        removeThisContentType = entities.include.includes(contentType.uid);\n      }\n\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\n      if (entities?.exclude && entities.exclude.includes(contentType.uid)) {\n        removeThisContentType = false;\n      }\n\n      if (entities?.filters) {\n        removeThisContentType = entities.filters.every((filter) => filter(contentType));\n      }\n\n      return removeThisContentType;\n    })\n    .map((contentType) => contentType.uid);\n\n  const modelsToClear = models\n    .filter((model) => {\n      if (contentTypesToClear.includes(model.uid as UID.ContentType)) {\n        return false;\n      }\n\n      let removeThisModel = true;\n\n      // include means \"only include these types\" so if it's not in here, it's not being included\n      if (entities?.include) {\n        removeThisModel = entities.include.includes(model.uid);\n      }\n\n      // if something is excluded, remove it. But lack of being excluded doesn't mean it's kept\n      if (entities?.exclude && entities.exclude.includes(model.uid)) {\n        removeThisModel = false;\n      }\n\n      return removeThisModel;\n    })\n    .map((model) => model.uid);\n\n  const [results, updateResults] = useResults([...contentTypesToClear, ...modelsToClear]);\n\n  const contentTypeQuery = queries.entity.createEntityQuery(strapi);\n\n  const contentTypePromises = contentTypesToClear.map(async (uid) => {\n    const result = await contentTypeQuery(uid).deleteMany(entities?.params);\n\n    if (result) {\n      updateResults(result.count || 0, uid);\n    }\n  });\n\n  const modelsPromises = modelsToClear.map(async (uid) => {\n    const result = await strapi.db.query(uid).deleteMany({});\n\n    if (result) {\n      updateResults(result.count || 0, uid);\n    }\n  });\n\n  await Promise.all([...contentTypePromises, ...modelsPromises]);\n\n  return results;\n};\n\nconst deleteConfigurationRecords = async (\n  strapi: Core.Strapi,\n  options: IRestoreOptions = {}\n): Promise<IDeleteResults> => {\n  const { coreStore = true, webhook = true } = options?.configuration ?? {};\n\n  const models: string[] = [];\n\n  if (coreStore) {\n    models.push('strapi::core-store');\n  }\n\n  if (webhook) {\n    models.push('strapi::webhook');\n  }\n\n  const [results, updateResults] = useResults(models);\n\n  const deletePromises = models.map(async (uid) => {\n    const result = await strapi.db.query(uid).deleteMany({});\n\n    if (result) {\n      updateResults(result.count, uid);\n    }\n  });\n\n  await Promise.all(deletePromises);\n\n  return results;\n};\n\nconst useResults = (\n  keys: string[]\n): [IDeleteResults, (count: number, key?: string) => void | never] => {\n  const results: IDeleteResults = {\n    count: 0,\n    aggregate: keys.reduce((acc, key) => ({ ...acc, [key]: { count: 0 } }), {}),\n  };\n\n  const update = (count: number, key?: string) => {\n    if (key) {\n      if (!(key in results.aggregate)) {\n        throw new ProviderTransferError(`Unknown key \"${key}\" provided in results update`);\n      }\n\n      results.aggregate[key].count += count;\n    }\n\n    results.count += count;\n  };\n\n  return [results, update];\n};\n\nexport * from './entities';\nexport * from './configuration';\nexport * from './links';\n","import type { Core } from '@strapi/types';\n\nimport { ProviderInitializationError } from '../errors/providers';\n\nexport type ValidStrapiAssertion = (strapi: unknown, msg?: string) => asserts strapi is Core.Strapi;\n\nexport const assertValidStrapi: ValidStrapiAssertion = (strapi?: unknown, msg = '') => {\n  if (!strapi) {\n    throw new ProviderInitializationError(`${msg}. Strapi instance not found.`);\n  }\n};\n","import { Writable, Readable } from 'stream';\nimport path from 'path';\nimport * as fse from 'fs-extra';\nimport type { Knex } from 'knex';\nimport type { Core, Struct } from '@strapi/types';\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IFile,\n  IMetadata,\n  ProviderType,\n  Transaction,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\n\nimport { restore } from './strategies';\nimport * as utils from '../../../utils';\nimport {\n  ProviderInitializationError,\n  ProviderTransferError,\n  ProviderValidationError,\n} from '../../../errors/providers';\nimport { assertValidStrapi } from '../../../utils/providers';\n\nexport const VALID_CONFLICT_STRATEGIES = ['restore'];\nexport const DEFAULT_CONFLICT_STRATEGY = 'restore';\n\nexport interface ILocalStrapiDestinationProviderOptions {\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\n\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\n  restore?: restore.IRestoreOptions; // erase data in strapi database before transfer; required if strategy is 'restore'\n  strategy: 'restore'; // conflict management strategy; only the restore strategy is available at this time\n}\n\nclass LocalStrapiDestinationProvider implements IDestinationProvider {\n  name = 'destination::local-strapi';\n\n  type: ProviderType = 'destination';\n\n  options: ILocalStrapiDestinationProviderOptions;\n\n  strapi?: Core.Strapi;\n\n  transaction?: Transaction;\n\n  uploadsBackupDirectoryName: string;\n\n  onWarning?: ((message: string) => void) | undefined;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  /**\n   * The entities mapper is used to map old entities to their new IDs\n   */\n  #entitiesMapper: { [type: string]: { [id: number]: number } };\n\n  constructor(options: ILocalStrapiDestinationProviderOptions) {\n    this.options = options;\n    this.#entitiesMapper = {};\n    this.uploadsBackupDirectoryName = `uploads_backup_${Date.now()}`;\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    this.#validateOptions();\n    this.strapi = await this.options.getStrapi();\n    if (!this.strapi) {\n      throw new ProviderInitializationError('Could not access local strapi');\n    }\n    this.strapi.db.lifecycles.disable();\n    this.transaction = utils.transaction.createTransaction(this.strapi);\n  }\n\n  // TODO: either move this to restore strategy, or restore strategy should given access to these instead of repeating the logic possibly in a different way\n  #areAssetsIncluded = () => {\n    return this.options.restore?.assets;\n  };\n\n  #isContentTypeIncluded = (type: string) => {\n    const notIncluded =\n      this.options.restore?.entities?.include &&\n      !this.options.restore?.entities?.include?.includes(type);\n    const excluded =\n      this.options.restore?.entities?.exclude &&\n      this.options.restore?.entities.exclude.includes(type);\n\n    return !excluded && !notIncluded;\n  };\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'local-destination-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async close(): Promise<void> {\n    const { autoDestroy } = this.options;\n    assertValidStrapi(this.strapi);\n    this.transaction?.end();\n    this.strapi.db.lifecycles.enable();\n    // Basically `!== false` but more deterministic\n    if (autoDestroy === undefined || autoDestroy === true) {\n      await this.strapi?.destroy();\n    }\n  }\n\n  #validateOptions() {\n    this.#reportInfo('validating options');\n    if (!VALID_CONFLICT_STRATEGIES.includes(this.options.strategy)) {\n      throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\n        check: 'strategy',\n        strategy: this.options.strategy,\n        validStrategies: VALID_CONFLICT_STRATEGIES,\n      });\n    }\n\n    // require restore options when using restore\n    if (this.options.strategy === 'restore' && !this.options.restore) {\n      throw new ProviderValidationError('Missing restore options');\n    }\n  }\n\n  async #deleteFromRestoreOptions() {\n    assertValidStrapi(this.strapi);\n    if (!this.options.restore) {\n      throw new ProviderValidationError('Missing restore options');\n    }\n    this.#reportInfo('deleting record ');\n    return restore.deleteRecords(this.strapi, this.options.restore);\n  }\n\n  async #deleteAllAssets(trx?: Knex.Transaction) {\n    assertValidStrapi(this.strapi);\n    this.#reportInfo('deleting all assets');\n    // if we're not restoring files, don't touch the files\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n\n    const stream: Readable = this.strapi.db\n      // Create a query builder instance (default type is 'select')\n      .queryBuilder('plugin::upload.file')\n      // Fetch all columns\n      .select('*')\n      // Attach the transaction\n      .transacting(trx)\n      // Get a readable stream\n      .stream();\n\n    // TODO use bulk delete when exists in providers\n    for await (const file of stream) {\n      await this.strapi.plugin('upload').provider.delete(file);\n      if (file.formats) {\n        for (const fileFormat of Object.values(file.formats)) {\n          await this.strapi.plugin('upload').provider.delete(fileFormat);\n        }\n      }\n    }\n\n    this.#reportInfo('deleted all assets');\n  }\n\n  async rollback() {\n    this.#reportInfo('Rolling back transaction');\n    await this.transaction?.rollback();\n    this.#reportInfo('Rolled back transaction');\n  }\n\n  async beforeTransfer() {\n    if (!this.strapi) {\n      throw new Error('Strapi instance not found');\n    }\n\n    await this.transaction?.attach(async (trx) => {\n      try {\n        if (this.options.strategy === 'restore') {\n          await this.#handleAssetsBackup();\n          await this.#deleteAllAssets(trx);\n          await this.#deleteFromRestoreOptions();\n        }\n      } catch (error) {\n        throw new Error(`restore failed ${error}`);\n      }\n    });\n  }\n\n  getMetadata(): IMetadata {\n    this.#reportInfo('getting metadata');\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n    const strapiVersion = this.strapi.config.get<string>('info.strapi');\n    const createdAt = new Date().toISOString();\n\n    return {\n      createdAt,\n      strapi: {\n        version: strapiVersion,\n      },\n    };\n  }\n\n  getSchemas(): Record<string, Struct.Schema> {\n    this.#reportInfo('getting schema');\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n\n    const schemas = utils.schema.schemasToValidJSON({\n      ...this.strapi.contentTypes,\n      ...this.strapi.components,\n    });\n\n    return utils.schema.mapSchemasValues(schemas);\n  }\n\n  createEntitiesWriteStream(): Writable {\n    assertValidStrapi(this.strapi, 'Not able to import entities');\n    this.#reportInfo('creating entities stream');\n    const { strategy } = this.options;\n\n    const updateMappingTable = (type: string, oldID: number, newID: number) => {\n      if (!this.#entitiesMapper[type]) {\n        this.#entitiesMapper[type] = {};\n      }\n\n      Object.assign(this.#entitiesMapper[type], { [oldID]: newID });\n    };\n\n    if (strategy === 'restore') {\n      return restore.createEntitiesWriteStream({\n        strapi: this.strapi,\n        updateMappingTable,\n        transaction: this.transaction,\n      });\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${this.options.strategy}`, {\n      check: 'strategy',\n      strategy: this.options.strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n\n  async #handleAssetsBackup() {\n    assertValidStrapi(this.strapi, 'Not able to create the assets backup');\n\n    // if we're not restoring assets, don't back them up because they won't be touched\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\n      this.#reportInfo('creating assets backup directory');\n      const assetsDirectory = path.join(this.strapi.dirs.static.public, 'uploads');\n      const backupDirectory = path.join(\n        this.strapi.dirs.static.public,\n        this.uploadsBackupDirectoryName\n      );\n\n      try {\n        // Check access before attempting to do anything\n        await fse.access(\n          assetsDirectory,\n          // eslint-disable-next-line no-bitwise\n          fse.constants.W_OK | fse.constants.R_OK | fse.constants.F_OK\n        );\n        // eslint-disable-next-line no-bitwise\n        await fse.access(path.join(assetsDirectory, '..'), fse.constants.W_OK | fse.constants.R_OK);\n\n        await fse.move(assetsDirectory, backupDirectory);\n        await fse.mkdir(assetsDirectory);\n        // Create a .gitkeep file to ensure the directory is not empty\n        await fse.outputFile(path.join(assetsDirectory, '.gitkeep'), '');\n        this.#reportInfo(`created assets backup directory ${backupDirectory}`);\n      } catch (err) {\n        throw new ProviderTransferError(\n          'The backup folder for the assets could not be created inside the public folder. Please ensure Strapi has write permissions on the public directory',\n          {\n            code: 'ASSETS_DIRECTORY_ERR',\n          }\n        );\n      }\n      return backupDirectory;\n    }\n  }\n\n  async #removeAssetsBackup() {\n    assertValidStrapi(this.strapi, 'Not able to remove Assets');\n    // if we're not restoring assets, don't back them up because they won't be touched\n    if (!this.#areAssetsIncluded()) {\n      return;\n    }\n    // TODO: this should catch all thrown errors and bubble it up to engine so it can be reported as a non-fatal diagnostic message telling the user they may need to manually delete assets\n    if (this.strapi.config.get<{ provider: string }>('plugin::upload').provider === 'local') {\n      this.#reportInfo('removing assets backup');\n      assertValidStrapi(this.strapi);\n      const backupDirectory = path.join(\n        this.strapi.dirs.static.public,\n        this.uploadsBackupDirectoryName\n      );\n      await fse.rm(backupDirectory, { recursive: true, force: true });\n      this.#reportInfo('successfully removed assets backup');\n    }\n  }\n\n  // TODO: Move this logic to the restore strategy\n  async createAssetsWriteStream(): Promise<Writable> {\n    assertValidStrapi(this.strapi, 'Not able to stream Assets');\n    this.#reportInfo('creating assets write stream');\n    if (!this.#areAssetsIncluded()) {\n      throw new ProviderTransferError(\n        'Attempting to transfer assets when `assets` is not set in restore options'\n      );\n    }\n\n    const removeAssetsBackup = this.#removeAssetsBackup.bind(this);\n    const strapi = this.strapi;\n    const transaction = this.transaction;\n    const fileEntitiesMapper = this.#entitiesMapper['plugin::upload.file'];\n\n    const restoreMediaEntitiesContent = this.#isContentTypeIncluded('plugin::upload.file');\n\n    return new Writable({\n      objectMode: true,\n      async final(next) {\n        // Delete the backup folder\n        await removeAssetsBackup();\n        next();\n      },\n      async write(chunk: IAsset, _encoding, callback) {\n        await transaction?.attach(async () => {\n          const uploadData = {\n            ...chunk.metadata,\n            stream: Readable.from(chunk.stream),\n            buffer: chunk?.buffer,\n          };\n\n          const provider = strapi.config.get<{ provider: string }>('plugin::upload').provider;\n\n          const fileId = fileEntitiesMapper?.[uploadData.id];\n          if (!fileId) {\n            callback(new Error(`File ID not found for ID: ${uploadData.id}`));\n          }\n\n          try {\n            await strapi.plugin('upload').provider.uploadStream(uploadData);\n\n            // if we're not supposed to transfer the associated entities, stop here\n            if (!restoreMediaEntitiesContent) {\n              return callback();\n            }\n\n            // Files formats are stored within the parent file entity\n            if (uploadData?.type) {\n              const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\n                where: { id: fileId },\n              });\n              if (!entry) {\n                throw new Error('file not found');\n              }\n              const specificFormat = entry?.formats?.[uploadData.type];\n              if (specificFormat) {\n                specificFormat.url = uploadData.url;\n              }\n              await strapi.db.query('plugin::upload.file').update({\n                where: { id: entry.id },\n                data: {\n                  formats: entry.formats,\n                  provider,\n                },\n              });\n              return callback();\n            }\n\n            const entry: IFile = await strapi.db.query('plugin::upload.file').findOne({\n              where: { id: fileId },\n            });\n            if (!entry) {\n              throw new Error('file not found');\n            }\n            entry.url = uploadData.url;\n            await strapi.db.query('plugin::upload.file').update({\n              where: { id: entry.id },\n              data: {\n                url: entry.url,\n                provider,\n              },\n            });\n            callback();\n          } catch (error) {\n            callback(new Error(`Error while uploading asset ${chunk.filename} ${error}`));\n          }\n        });\n      },\n    });\n  }\n\n  async createConfigurationWriteStream(): Promise<Writable> {\n    assertValidStrapi(this.strapi, 'Not able to stream Configurations');\n    this.#reportInfo('creating configuration write stream');\n    const { strategy } = this.options;\n\n    if (strategy === 'restore') {\n      return restore.createConfigurationWriteStream(this.strapi, this.transaction);\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\n      check: 'strategy',\n      strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n\n  async createLinksWriteStream(): Promise<Writable> {\n    this.#reportInfo('creating links write stream');\n    if (!this.strapi) {\n      throw new Error('Not able to stream links. Strapi instance not found');\n    }\n\n    const { strategy } = this.options;\n    const mapID = (uid: string, id: number): number | undefined => this.#entitiesMapper[uid]?.[id];\n\n    if (strategy === 'restore') {\n      return restore.createLinksWriteStream(mapID, this.strapi, this.transaction, this.onWarning);\n    }\n\n    throw new ProviderValidationError(`Invalid strategy ${strategy}`, {\n      check: 'strategy',\n      strategy,\n      validStrategies: VALID_CONFLICT_STRATEGIES,\n    });\n  }\n}\n\nexport const createLocalStrapiDestinationProvider = (\n  options: ILocalStrapiDestinationProviderOptions\n) => {\n  return new LocalStrapiDestinationProvider(options);\n};\n","import { Readable, Transform } from 'stream';\nimport type { Core, Struct } from '@strapi/types';\n\nimport * as shared from '../../queries';\nimport { IEntity } from '../../../../types';\n\n/**\n * Generate and consume content-types streams in order to stream each entity individually\n */\nexport const createEntitiesStream = (strapi: Core.Strapi): Readable => {\n  const contentTypes: Struct.ContentTypeSchema[] = Object.values(strapi.contentTypes);\n\n  async function* contentTypeStreamGenerator() {\n    for (const contentType of contentTypes) {\n      const query = shared.entity.createEntityQuery(strapi).call(null, contentType.uid);\n\n      const stream: Readable = strapi.db\n        // Create a query builder instance (default type is 'select')\n        .queryBuilder(contentType.uid)\n        // Fetch all columns\n        .select('*')\n        // Apply the populate\n        .populate(query.deepPopulateComponentLikeQuery)\n        // Get a readable stream\n        .stream();\n\n      yield { contentType, stream };\n    }\n  }\n\n  return Readable.from(\n    (async function* entitiesGenerator(): AsyncGenerator<{\n      entity: IEntity;\n      contentType: Struct.ContentTypeSchema;\n    }> {\n      for await (const { stream, contentType } of contentTypeStreamGenerator()) {\n        try {\n          for await (const entity of stream) {\n            yield { entity, contentType };\n          }\n        } catch {\n          // ignore\n        } finally {\n          stream.destroy();\n        }\n      }\n    })()\n  );\n};\n\n/**\n * Create an entity transform stream which convert the output of\n * the multi-content-types stream to the transfer entity format\n */\nexport const createEntitiesTransformStream = (): Transform => {\n  return new Transform({\n    objectMode: true,\n    transform(data, _encoding, callback) {\n      const { entity, contentType } = data;\n      const { id, ...attributes } = entity;\n\n      callback(null, {\n        type: contentType.uid,\n        id,\n        data: attributes,\n      });\n    },\n  });\n};\n","import { Readable } from 'stream';\nimport type { Core } from '@strapi/types';\n\nimport type { ILink } from '../../../../types';\nimport { createLinkQuery } from '../../queries/link';\n\n/**\n * Create a Readable which will stream all the links from a Strapi instance\n */\nexport const createLinksStream = (strapi: Core.Strapi): Readable => {\n  const uids = [...Object.keys(strapi.contentTypes), ...Object.keys(strapi.components)] as string[];\n\n  // Async generator stream that returns every link from a Strapi instance\n  return Readable.from(\n    (async function* linkGenerator(): AsyncGenerator<ILink> {\n      const query = createLinkQuery(strapi);\n\n      for (const uid of uids) {\n        const generator = query().generateAll(uid);\n\n        for await (const link of generator) {\n          yield link;\n        }\n      }\n    })()\n  );\n};\n","import { Readable } from 'stream';\nimport { chain } from 'stream-chain';\nimport { set } from 'lodash/fp';\nimport type { Core } from '@strapi/types';\n\nimport type { IConfiguration } from '../../../../types';\n\n/**\n * Create a readable stream that export the Strapi app configuration\n */\nexport const createConfigurationStream = (strapi: Core.Strapi): Readable => {\n  return Readable.from(\n    (async function* configurationGenerator(): AsyncGenerator<IConfiguration> {\n      // Core Store\n      const coreStoreStream = chain([\n        strapi.db.queryBuilder('strapi::core-store').stream(),\n        (data) => set('value', JSON.parse(data.value), data),\n        wrapConfigurationItem('core-store'),\n      ]);\n\n      // Webhook\n      const webhooksStream = chain([\n        strapi.db.queryBuilder('strapi::webhook').stream(),\n        wrapConfigurationItem('webhook'),\n      ]);\n\n      const streams = [coreStoreStream, webhooksStream];\n\n      for (const stream of streams) {\n        for await (const item of stream) {\n          yield item;\n        }\n      }\n    })()\n  );\n};\n\nconst wrapConfigurationItem = (type: 'core-store' | 'webhook') => (value: unknown) => ({\n  type,\n  value,\n});\n","import { join } from 'path';\nimport { Duplex, PassThrough, Readable } from 'stream';\nimport * as webStream from 'stream/web';\nimport { stat, createReadStream, ReadStream } from 'fs-extra';\nimport type { Core } from '@strapi/types';\n\nimport type { IAsset, IFile } from '../../../../types';\n\nfunction getFileStream(\n  filepath: string,\n  strapi: Core.Strapi,\n  isLocal = false\n): PassThrough | ReadStream {\n  if (isLocal) {\n    // Todo: handle errors\n    return createReadStream(filepath);\n  }\n\n  const readableStream = new PassThrough();\n\n  // fetch the image from remote url and stream it\n  strapi\n    .fetch(filepath)\n    .then((res: Response) => {\n      if (res.status !== 200) {\n        readableStream.emit('error', new Error(`Request failed with status code ${res.status}`));\n        return;\n      }\n\n      if (res.body) {\n        // pipe the image data\n        Readable.fromWeb(new webStream.ReadableStream(res.body)).pipe(readableStream);\n      } else {\n        readableStream.emit('error', new Error('Empty data found for file'));\n      }\n    })\n    .catch((error: unknown) => {\n      readableStream.emit('error', error);\n    });\n\n  return readableStream;\n}\n\nfunction getFileStats(\n  filepath: string,\n  strapi: Core.Strapi,\n  isLocal = false\n): Promise<{ size: number }> {\n  if (isLocal) {\n    return stat(filepath);\n  }\n  return new Promise((resolve, reject) => {\n    strapi\n      .fetch(filepath)\n      .then((res: Response) => {\n        if (res.status !== 200) {\n          reject(new Error(`Request failed with status code ${res.status}`));\n          return;\n        }\n\n        const contentLength = res.headers.get('content-length');\n        const stats = {\n          size: contentLength ? parseInt(contentLength, 10) : 0,\n        };\n\n        resolve(stats);\n      })\n      .catch((error: unknown) => {\n        reject(error);\n      });\n  });\n}\n\nasync function signFile(file: IFile) {\n  const { provider } = strapi.plugins.upload;\n  const { provider: providerName } = strapi.config.get('plugin.upload') as { provider: string };\n  const isPrivate = await provider.isPrivate();\n  if (file?.provider === providerName && isPrivate) {\n    const signUrl = async (file: IFile) => {\n      const signedUrl = await provider.getSignedUrl(file);\n      file.url = signedUrl.url;\n    };\n\n    // Sign the original file\n    await signUrl(file);\n    // Sign each file format\n    if (file.formats) {\n      for (const format of Object.keys(file.formats)) {\n        await signUrl(file.formats[format]);\n      }\n    }\n  }\n}\n\n/**\n * Generate and consume assets streams in order to stream each file individually\n */\nexport const createAssetsStream = (strapi: Core.Strapi): Duplex => {\n  const generator: () => AsyncGenerator<IAsset, void> = async function* () {\n    const stream: Readable = strapi.db\n      .queryBuilder('plugin::upload.file')\n      // Create a query builder instance (default type is 'select')\n      // Fetch all columns\n      .select('*')\n      // Get a readable stream\n      .stream();\n\n    for await (const file of stream) {\n      const isLocalProvider = file.provider === 'local';\n      if (!isLocalProvider) {\n        await signFile(file);\n      }\n      const filepath = isLocalProvider ? join(strapi.dirs.static.public, file.url) : file.url;\n      const stats = await getFileStats(filepath, strapi, isLocalProvider);\n      const stream = getFileStream(filepath, strapi, isLocalProvider);\n\n      yield {\n        metadata: file,\n        filepath,\n        filename: file.hash + file.ext,\n        stream,\n        stats: { size: stats.size },\n      };\n\n      if (file.formats) {\n        for (const format of Object.keys(file.formats)) {\n          const fileFormat = file.formats[format];\n          const fileFormatFilepath = isLocalProvider\n            ? join(strapi.dirs.static.public, fileFormat.url)\n            : fileFormat.url;\n          const fileFormatStats = await getFileStats(fileFormatFilepath, strapi, isLocalProvider);\n          const fileFormatStream = getFileStream(fileFormatFilepath, strapi, isLocalProvider);\n          const metadata = { ...fileFormat, type: format, id: file.id, mainHash: file.hash };\n          yield {\n            metadata,\n            filepath: fileFormatFilepath,\n            filename: fileFormat.hash + fileFormat.ext,\n            stream: fileFormatStream,\n            stats: { size: fileFormatStats.size },\n          };\n        }\n      }\n    }\n  };\n\n  return Duplex.from(generator());\n};\n","import { Readable } from 'stream';\nimport { chain } from 'stream-chain';\nimport type { Core, Struct } from '@strapi/types';\n\nimport type { IMetadata, ISourceProvider, ProviderType } from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport { createEntitiesStream, createEntitiesTransformStream } from './entities';\nimport { createLinksStream } from './links';\nimport { createConfigurationStream } from './configuration';\nimport { createAssetsStream } from './assets';\nimport * as utils from '../../../utils';\nimport { assertValidStrapi } from '../../../utils/providers';\n\nexport interface ILocalStrapiSourceProviderOptions {\n  getStrapi(): Core.Strapi | Promise<Core.Strapi>; // return an initialized instance of Strapi\n\n  autoDestroy?: boolean; // shut down the instance returned by getStrapi() at the end of the transfer\n}\n\nexport const createLocalStrapiSourceProvider = (options: ILocalStrapiSourceProviderOptions) => {\n  return new LocalStrapiSourceProvider(options);\n};\n\nclass LocalStrapiSourceProvider implements ISourceProvider {\n  name = 'source::local-strapi';\n\n  type: ProviderType = 'source';\n\n  options: ILocalStrapiSourceProviderOptions;\n\n  strapi?: Core.Strapi;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: ILocalStrapiSourceProviderOptions) {\n    this.options = options;\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    this.strapi = await this.options.getStrapi();\n    this.strapi.db.lifecycles.disable();\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'local-source-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async close(): Promise<void> {\n    const { autoDestroy } = this.options;\n    assertValidStrapi(this.strapi);\n    this.strapi.db.lifecycles.enable();\n    // Basically `!== false` but more deterministic\n    if (autoDestroy === undefined || autoDestroy === true) {\n      await this.strapi?.destroy();\n    }\n  }\n\n  getMetadata(): IMetadata {\n    this.#reportInfo('getting metadata');\n    const strapiVersion = strapi.config.get<string>('info.strapi');\n    const createdAt = new Date().toISOString();\n\n    return {\n      createdAt,\n      strapi: {\n        version: strapiVersion,\n      },\n    };\n  }\n\n  async createEntitiesReadStream(): Promise<Readable> {\n    assertValidStrapi(this.strapi, 'Not able to stream entities');\n    this.#reportInfo('creating entities read stream');\n    return chain([\n      // Entities stream\n      createEntitiesStream(this.strapi),\n\n      // Transform stream\n      createEntitiesTransformStream(),\n    ]);\n  }\n\n  createLinksReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream links');\n    this.#reportInfo('creating links read stream');\n\n    return createLinksStream(this.strapi);\n  }\n\n  createConfigurationReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream configuration');\n    this.#reportInfo('creating configuration read stream');\n    return createConfigurationStream(this.strapi);\n  }\n\n  getSchemas(): Record<string, Struct.Schema> {\n    assertValidStrapi(this.strapi, 'Not able to get Schemas');\n    this.#reportInfo('getting schemas');\n    const schemas = utils.schema.schemasToValidJSON({\n      ...this.strapi.contentTypes,\n      ...this.strapi.components,\n    });\n\n    return utils.schema.mapSchemasValues(schemas);\n  }\n\n  createSchemasReadStream(): Readable {\n    return Readable.from(Object.values(this.getSchemas()));\n  }\n\n  createAssetsReadStream(): Readable {\n    assertValidStrapi(this.strapi, 'Not able to stream assets');\n    this.#reportInfo('creating assets read stream');\n    return createAssetsStream(this.strapi);\n  }\n}\n\nexport type ILocalStrapiSourceProvider = InstanceType<typeof LocalStrapiSourceProvider>;\n","import { randomUUID } from 'crypto';\nimport { RawData, WebSocket } from 'ws';\n\nimport type { Client, Server } from '../../../types/remote/protocol';\n\nimport {\n  ProviderError,\n  ProviderTransferError,\n  ProviderInitializationError,\n  ProviderValidationError,\n  ProviderErrorDetails,\n} from '../../errors/providers';\nimport { IDiagnosticReporter } from '../../utils/diagnostic';\n\ninterface IDispatcherState {\n  transfer?: { kind: Client.TransferKind; id: string };\n}\n\ninterface IDispatchOptions {\n  attachTransfer?: boolean;\n}\n\ntype Dispatch<T> = Omit<T, 'transferID' | 'uuid'>;\n\nexport const createDispatcher = (\n  ws: WebSocket,\n  retryMessageOptions = {\n    retryMessageMaxRetries: 5,\n    retryMessageTimeout: 30000,\n  },\n  reportInfo?: (message: string) => void\n) => {\n  const state: IDispatcherState = {};\n\n  type DispatchMessage = Dispatch<Client.Message>;\n\n  const dispatch = async <U = null>(\n    message: DispatchMessage,\n    options: IDispatchOptions = {}\n  ): Promise<U | null> => {\n    if (!ws) {\n      throw new Error('No websocket connection found');\n    }\n\n    return new Promise<U | null>((resolve, reject) => {\n      const uuid = randomUUID();\n      const payload = { ...message, uuid };\n      let numberOfTimesMessageWasSent = 0;\n\n      if (options.attachTransfer) {\n        Object.assign(payload, { transferID: state.transfer?.id });\n      }\n\n      if (message.type === 'command') {\n        reportInfo?.(\n          `dispatching message command:${(message as Client.CommandMessage).command} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\n        );\n      } else if (message.type === 'transfer') {\n        const messageToSend = message as Client.TransferMessage;\n        reportInfo?.(\n          `dispatching message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\n        );\n      }\n      const stringifiedPayload = JSON.stringify(payload);\n      ws.send(stringifiedPayload, (error) => {\n        if (error) {\n          reject(error);\n        }\n      });\n      const { retryMessageMaxRetries, retryMessageTimeout } = retryMessageOptions;\n      const sendPeriodically = () => {\n        if (numberOfTimesMessageWasSent <= retryMessageMaxRetries) {\n          numberOfTimesMessageWasSent += 1;\n          ws.send(stringifiedPayload, (error) => {\n            if (error) {\n              reject(error);\n            }\n          });\n        } else {\n          reject(new ProviderError('error', 'Request timed out'));\n        }\n      };\n      const interval = setInterval(sendPeriodically, retryMessageTimeout);\n\n      const onResponse = (raw: RawData) => {\n        const response: Server.Message<U> = JSON.parse(raw.toString());\n        if (message.type === 'command') {\n          reportInfo?.(\n            `received response to message command: ${(message as Client.CommandMessage).command} uuid: ${uuid} sent: ${numberOfTimesMessageWasSent}`\n          );\n        } else if (message.type === 'transfer') {\n          const messageToSend = message as Client.TransferMessage;\n          reportInfo?.(\n            `received response to message action:${messageToSend.action} ${messageToSend.kind === 'step' ? `step:${messageToSend.step}` : ''} uuid:${uuid} sent:${numberOfTimesMessageWasSent}`\n          );\n        }\n        if (response.uuid === uuid) {\n          clearInterval(interval);\n          if (response.error) {\n            const message = response.error.message;\n            const details = response.error.details?.details as ProviderErrorDetails;\n            const step = response.error.details?.step;\n            let error = new ProviderError('error', message, details);\n            if (step === 'transfer') {\n              error = new ProviderTransferError(message, details);\n            } else if (step === 'validation') {\n              error = new ProviderValidationError(message, details);\n            } else if (step === 'initialization') {\n              error = new ProviderInitializationError(message);\n            }\n            return reject(error);\n          }\n          resolve(response.data ?? null);\n        } else {\n          ws.once('message', onResponse);\n        }\n      };\n\n      ws.once('message', onResponse);\n    });\n  };\n\n  const dispatchCommand = <U extends Client.Command>(\n    payload: {\n      command: U;\n    } & ([Client.GetCommandParams<U>] extends [never]\n      ? unknown\n      : { params?: Client.GetCommandParams<U> })\n  ) => {\n    return dispatch({ type: 'command', ...payload } as Client.CommandMessage);\n  };\n\n  const dispatchTransferAction = async <T>(action: Client.Action['action']) => {\n    const payload: Dispatch<Client.Action> = { type: 'transfer', kind: 'action', action };\n\n    return dispatch<T>(payload, { attachTransfer: true }) ?? Promise.resolve(null);\n  };\n\n  const dispatchTransferStep = async <\n    T,\n    A extends Client.TransferPushMessage['action'] = Client.TransferPushMessage['action'],\n    S extends Client.TransferPushStep = Client.TransferPushStep,\n  >(\n    payload: {\n      step: S;\n      action: A;\n    } & (A extends 'stream' ? { data: Client.GetTransferPushStreamData<S> } : unknown)\n  ) => {\n    const message: Dispatch<Client.TransferPushMessage> = {\n      type: 'transfer',\n      kind: 'step',\n      ...payload,\n    };\n\n    return dispatch<T>(message, { attachTransfer: true }) ?? Promise.resolve(null);\n  };\n\n  const setTransferProperties = (\n    properties: Exclude<IDispatcherState['transfer'], undefined>\n  ): void => {\n    state.transfer = { ...properties };\n  };\n\n  return {\n    get transferID() {\n      return state.transfer?.id;\n    },\n\n    get transferKind() {\n      return state.transfer?.kind;\n    },\n\n    setTransferProperties,\n\n    dispatch,\n    dispatchCommand,\n    dispatchTransferAction,\n    dispatchTransferStep,\n  };\n};\n\ntype WebsocketParams = ConstructorParameters<typeof WebSocket>;\ntype Address = WebsocketParams[0];\ntype Options = WebsocketParams[2];\n\nexport const connectToWebsocket = (\n  address: Address,\n  options?: Options,\n  diagnostics?: IDiagnosticReporter\n): Promise<WebSocket> => {\n  return new Promise((resolve, reject) => {\n    const server = new WebSocket(address, options);\n    server.once('open', () => {\n      resolve(server);\n    });\n\n    server.on('unexpected-response', (_req, res) => {\n      if (res.statusCode === 401) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Authentication Error'\n          )\n        );\n      }\n\n      if (res.statusCode === 403) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Authorization Error'\n          )\n        );\n      }\n\n      if (res.statusCode === 404) {\n        return reject(\n          new ProviderInitializationError(\n            'Failed to initialize the connection: Data transfer is not enabled on the remote host'\n          )\n        );\n      }\n\n      return reject(\n        new ProviderInitializationError(\n          `Failed to initialize the connection: Unexpected server response ${res.statusCode}`\n        )\n      );\n    });\n\n    server.on('message', (raw: RawData) => {\n      const response: Server.Message = JSON.parse(raw.toString());\n      if (response.diagnostic) {\n        diagnostics?.report({\n          ...response.diagnostic,\n        });\n      }\n    });\n\n    server.once('error', (err) => {\n      reject(\n        new ProviderTransferError(err.message, {\n          details: {\n            error: err.message,\n          },\n        })\n      );\n    });\n  });\n};\n\nexport const trimTrailingSlash = (input: string): string => {\n  return input.replace(/\\/$/, '');\n};\n\nexport const wait = (ms: number) => {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n\nexport const waitUntil = async (test: () => boolean, interval: number): Promise<void> => {\n  while (!test()) {\n    await wait(interval);\n  }\n\n  return Promise.resolve();\n};\n","export const TRANSFER_PATH = '/transfer/runner' as const;\nexport const TRANSFER_METHODS = ['push', 'pull'] as const;\n\nexport type TransferPath = typeof TRANSFER_PATH;\nexport type TransferMethod = (typeof TRANSFER_METHODS)[number];\n","import { randomUUID } from 'crypto';\nimport { Writable } from 'stream';\nimport { WebSocket } from 'ws';\nimport { once } from 'lodash/fp';\nimport type { Struct, Utils } from '@strapi/types';\n\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash } from '../utils';\n\nimport type {\n  IDestinationProvider,\n  IMetadata,\n  ProviderType,\n  IAsset,\n  TransferStage,\n  Protocol,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport type { Client, Server, Auth } from '../../../../types/remote/protocol';\nimport type { ILocalStrapiDestinationProviderOptions } from '../local-destination';\nimport { TRANSFER_PATH } from '../../remote/constants';\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\n\nexport interface IRemoteStrapiDestinationProviderOptions\n  extends Pick<ILocalStrapiDestinationProviderOptions, 'restore' | 'strategy'> {\n  url: URL; // the url of the remote Strapi admin\n  auth?: Auth.ITransferTokenAuth;\n  retryMessageOptions?: {\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\n  };\n}\n\nconst jsonLength = (obj: object) => Buffer.byteLength(JSON.stringify(obj));\n\nclass RemoteStrapiDestinationProvider implements IDestinationProvider {\n  name = 'destination::remote-strapi';\n\n  type: ProviderType = 'destination';\n\n  options: IRemoteStrapiDestinationProviderOptions;\n\n  ws: WebSocket | null;\n\n  dispatcher: ReturnType<typeof createDispatcher> | null;\n\n  transferID: string | null;\n\n  stats!: { [TStage in Exclude<TransferStage, 'schemas'>]: { count: number } };\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: IRemoteStrapiDestinationProviderOptions) {\n    this.options = options;\n    this.ws = null;\n    this.dispatcher = null;\n    this.transferID = null;\n\n    this.resetStats();\n  }\n\n  private resetStats() {\n    this.stats = {\n      assets: { count: 0 },\n      entities: { count: 0 },\n      links: { count: 0 },\n      configuration: { count: 0 },\n    };\n  }\n\n  async initTransfer(): Promise<string> {\n    const { strategy, restore } = this.options;\n\n    const query = this.dispatcher?.dispatchCommand({\n      command: 'init',\n      params: { options: { strategy, restore }, transfer: 'push' },\n    });\n\n    const res = (await query) as Server.Payload<Server.InitMessage>;\n    if (!res?.transferID) {\n      throw new ProviderTransferError('Init failed, invalid response from the server');\n    }\n\n    this.resetStats();\n\n    return res.transferID;\n  }\n\n  #startStepOnce(stage: Client.TransferPushStep) {\n    return once(() => this.#startStep(stage));\n  }\n\n  async #startStep<T extends Client.TransferPushStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    this.stats[step] = { count: 0 };\n\n    return null;\n  }\n\n  async #endStep<T extends Client.TransferPushStep>(step: T) {\n    try {\n      const res = await this.dispatcher?.dispatchTransferStep<{\n        ok: boolean;\n        stats: Protocol.Client.Stats;\n      }>({\n        action: 'end',\n        step,\n      });\n\n      return { stats: res?.stats ?? null, error: null };\n    } catch (e) {\n      if (e instanceof Error) {\n        return { stats: null, error: e };\n      }\n\n      if (typeof e === 'string') {\n        return { stats: null, error: new ProviderTransferError(e) };\n      }\n\n      return { stats: null, error: new ProviderTransferError('Unexpected error') };\n    }\n  }\n\n  async #streamStep<T extends Client.TransferPushStep>(\n    step: T,\n    message: Client.GetTransferPushStreamData<T>\n  ) {\n    try {\n      if (step === 'assets') {\n        const assetMessage = message as Protocol.Client.TransferAssetFlow[];\n        this.stats[step].count += assetMessage.filter((data) => data.action === 'start').length;\n      } else {\n        this.stats[step].count += message.length;\n      }\n\n      await this.dispatcher?.dispatchTransferStep({ action: 'stream', step, data: message });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n\n  #writeStream(step: Exclude<Client.TransferPushStep, 'assets'>): Writable {\n    type Step = typeof step;\n\n    const batchSize = 1024 * 1024; // 1MB;\n    const startTransferOnce = this.#startStepOnce(step);\n\n    let batch = [] as Client.GetTransferPushStreamData<Step>;\n\n    const batchLength = () => jsonLength(batch);\n\n    return new Writable({\n      objectMode: true,\n\n      final: async (callback) => {\n        if (batch.length > 0) {\n          const streamError = await this.#streamStep(step, batch);\n\n          batch = [];\n\n          if (streamError) {\n            return callback(streamError);\n          }\n        }\n        const { error, stats } = await this.#endStep(step);\n\n        const { count } = this.stats[step];\n\n        if (stats && (stats.started !== count || stats.finished !== count)) {\n          callback(\n            new Error(\n              `Data missing: sent ${this.stats[step].count} ${step}, recieved ${stats.started} and saved ${stats.finished} ${step}`\n            )\n          );\n        }\n\n        callback(error);\n      },\n\n      write: async (chunk, _encoding, callback) => {\n        const startError = await startTransferOnce();\n        if (startError) {\n          return callback(startError);\n        }\n\n        batch.push(chunk);\n\n        if (batchLength() >= batchSize) {\n          const streamError = await this.#streamStep(step, batch);\n\n          batch = [];\n\n          if (streamError) {\n            return callback(streamError);\n          }\n        }\n\n        callback();\n      },\n    });\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'remote-destination-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    const { url, auth } = this.options;\n    const validProtocols = ['https:', 'http:'];\n\n    let ws: WebSocket;\n\n    if (!validProtocols.includes(url.protocol)) {\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\n        check: 'url',\n        details: {\n          protocol: url.protocol,\n          validProtocols,\n        },\n      });\n    }\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\n      url.pathname\n    )}${TRANSFER_PATH}/push`;\n\n    this.#reportInfo('establishing websocket connection');\n    // No auth defined, trying public access for transfer\n    if (!auth) {\n      ws = await connectToWebsocket(wsUrl, undefined, this.#diagnostics);\n    }\n\n    // Common token auth, this should be the main auth method\n    else if (auth.type === 'token') {\n      const headers = { Authorization: `Bearer ${auth.token}` };\n      ws = await connectToWebsocket(wsUrl, { headers }, this.#diagnostics);\n    }\n\n    // Invalid auth method provided\n    else {\n      throw new ProviderValidationError('Auth method not available', {\n        check: 'auth.type',\n        details: {\n          auth: auth.type,\n        },\n      });\n    }\n\n    this.#reportInfo('established websocket connection');\n\n    this.ws = ws;\n    const { retryMessageOptions } = this.options;\n\n    this.#reportInfo('creating dispatcher');\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message: string) =>\n      this.#reportInfo(message)\n    );\n    this.#reportInfo('created dispatcher');\n\n    this.#reportInfo('initialize transfer');\n    this.transferID = await this.initTransfer();\n    this.#reportInfo(`initialized transfer ${this.transferID}`);\n\n    this.dispatcher.setTransferProperties({ id: this.transferID, kind: 'push' });\n\n    await this.dispatcher.dispatchTransferAction('bootstrap');\n  }\n\n  async close() {\n    // Gracefully close the remote transfer process\n    if (this.transferID && this.dispatcher) {\n      await this.dispatcher.dispatchTransferAction('close');\n\n      await this.dispatcher.dispatchCommand({\n        command: 'end',\n        params: { transferID: this.transferID },\n      });\n    }\n\n    await new Promise<void>((resolve) => {\n      const { ws } = this;\n\n      if (!ws || ws.CLOSED) {\n        resolve();\n        return;\n      }\n\n      ws.on('close', () => resolve()).close();\n    });\n  }\n\n  getMetadata() {\n    return this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata') ?? null;\n  }\n\n  async beforeTransfer() {\n    await this.dispatcher?.dispatchTransferAction('beforeTransfer');\n  }\n\n  async rollback() {\n    await this.dispatcher?.dispatchTransferAction('rollback');\n  }\n\n  getSchemas() {\n    if (!this.dispatcher) {\n      return Promise.resolve(null);\n    }\n\n    return this.dispatcher.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\n  }\n\n  createEntitiesWriteStream(): Writable {\n    return this.#writeStream('entities');\n  }\n\n  createLinksWriteStream(): Writable {\n    return this.#writeStream('links');\n  }\n\n  createConfigurationWriteStream(): Writable {\n    return this.#writeStream('configuration');\n  }\n\n  createAssetsWriteStream(): Writable | Promise<Writable> {\n    let batch: Client.TransferAssetFlow[] = [];\n    let hasStarted = false;\n\n    const batchSize = 1024 * 1024; // 1MB;\n    const batchLength = () => {\n      return batch.reduce(\n        (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\n        0\n      );\n    };\n    const startAssetsTransferOnce = this.#startStepOnce('assets');\n\n    const flush = async () => {\n      const streamError = await this.#streamStep('assets', batch);\n      batch = [];\n      return streamError;\n    };\n\n    const safePush = async (chunk: Client.TransferAssetFlow) => {\n      batch.push(chunk);\n\n      if (batchLength() >= batchSize) {\n        const streamError = await flush();\n        if (streamError) {\n          throw streamError;\n        }\n      }\n    };\n\n    return new Writable({\n      objectMode: true,\n      final: async (callback) => {\n        if (batch.length > 0) {\n          await flush();\n        }\n\n        if (hasStarted) {\n          const { error: endStepError } = await this.#endStep('assets');\n\n          if (endStepError) {\n            return callback(endStepError);\n          }\n        }\n\n        return callback(null);\n      },\n\n      async write(asset: IAsset, _encoding, callback) {\n        const startError = await startAssetsTransferOnce();\n        if (startError) {\n          return callback(startError);\n        }\n\n        hasStarted = true;\n\n        const assetID = randomUUID();\n        const { filename, filepath, stats, stream, metadata } = asset;\n\n        try {\n          await safePush({\n            action: 'start',\n            assetID,\n            data: { filename, filepath, stats, metadata },\n          });\n\n          for await (const chunk of stream) {\n            await safePush({ action: 'stream', assetID, data: chunk });\n          }\n\n          await safePush({ action: 'end', assetID });\n\n          callback();\n        } catch (error) {\n          if (error instanceof Error) {\n            callback(error);\n          }\n        }\n      },\n    });\n  }\n}\n\nexport const createRemoteStrapiDestinationProvider = (\n  options: IRemoteStrapiDestinationProviderOptions\n) => {\n  return new RemoteStrapiDestinationProvider(options);\n};\n","import { PassThrough, Readable, Writable } from 'stream';\nimport type { Struct, Utils } from '@strapi/types';\nimport { WebSocket } from 'ws';\nimport { castArray } from 'lodash/fp';\n\nimport type {\n  IAsset,\n  IMetadata,\n  ISourceProvider,\n  ISourceProviderTransferResults,\n  MaybePromise,\n  Protocol,\n  ProviderType,\n  TransferStage,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport { Client, Server, Auth } from '../../../../types/remote/protocol';\nimport { ProviderTransferError, ProviderValidationError } from '../../../errors/providers';\nimport { TRANSFER_PATH } from '../../remote/constants';\nimport { ILocalStrapiSourceProviderOptions } from '../local-source';\nimport { createDispatcher, connectToWebsocket, trimTrailingSlash, wait, waitUntil } from '../utils';\n\nexport interface IRemoteStrapiSourceProviderOptions extends ILocalStrapiSourceProviderOptions {\n  url: URL; // the url of the remote Strapi admin\n  auth?: Auth.ITransferTokenAuth;\n  retryMessageOptions?: {\n    retryMessageTimeout: number; // milliseconds to wait for a response from a message\n    retryMessageMaxRetries: number; // max number of retries for a message before aborting transfer\n  };\n}\n\nclass RemoteStrapiSourceProvider implements ISourceProvider {\n  name = 'source::remote-strapi';\n\n  type: ProviderType = 'source';\n\n  options: IRemoteStrapiSourceProviderOptions;\n\n  ws: WebSocket | null;\n\n  dispatcher: ReturnType<typeof createDispatcher> | null;\n\n  constructor(options: IRemoteStrapiSourceProviderOptions) {\n    this.options = options;\n    this.ws = null;\n    this.dispatcher = null;\n  }\n\n  results?: ISourceProviderTransferResults | undefined;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  async #createStageReadStream(stage: Exclude<TransferStage, 'schemas'>) {\n    const startResult = await this.#startStep(stage);\n\n    if (startResult instanceof Error) {\n      throw startResult;\n    }\n\n    const { id: processID } = startResult as { id: string };\n\n    const stream = new PassThrough({ objectMode: true });\n\n    const listener = async (raw: Buffer) => {\n      const parsed = JSON.parse(raw.toString());\n      // If not a message related to our transfer process, ignore it\n      if (!parsed.uuid || parsed?.data?.type !== 'transfer' || parsed?.data?.id !== processID) {\n        this.ws?.once('message', listener);\n        return;\n      }\n\n      const { uuid, data: message } = parsed;\n      const { ended, error, data } = message;\n\n      if (error) {\n        await this.#respond(uuid);\n        stream.destroy(error);\n        return;\n      }\n\n      if (ended) {\n        await this.#respond(uuid);\n        await this.#endStep(stage);\n\n        stream.end();\n        return;\n      }\n\n      // if we get a single items instead of a batch\n      for (const item of castArray(data)) {\n        stream.push(item);\n      }\n\n      this.ws?.once('message', listener);\n\n      await this.#respond(uuid);\n    };\n\n    this.ws?.once('message', listener);\n\n    return stream;\n  }\n\n  createEntitiesReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('entities');\n  }\n\n  createLinksReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('links');\n  }\n\n  writeAsync = <T>(stream: Writable, data: T) => {\n    return new Promise<void>((resolve, reject) => {\n      stream.write(data, (error) => {\n        if (error) {\n          reject(error);\n        }\n\n        resolve();\n      });\n    });\n  };\n\n  async createAssetsReadStream(): Promise<Readable> {\n    // Create the streams used to transfer the assets\n    const stream = await this.#createStageReadStream('assets');\n    const pass = new PassThrough({ objectMode: true });\n\n    // Init the asset map\n    const assets: {\n      [filename: string]: IAsset & {\n        stream: PassThrough;\n        queue: Array<Protocol.Client.TransferAssetFlow & { action: 'stream' }>;\n        status: 'idle' | 'busy' | 'closed' | 'errored';\n      };\n    } = {};\n\n    stream\n      /**\n       * Process a payload of many transfer assets and performs the following tasks:\n       * - Start: creates a stream for new assets.\n       * - Stream: writes asset chunks to the asset's stream.\n       * - End: closes the stream after the asset s transferred and cleanup related resources.\n       */\n      .on('data', async (payload: Protocol.Client.TransferAssetFlow[]) => {\n        for (const item of payload) {\n          const { action, assetID } = item;\n\n          // Creates the stream to send the incoming asset through\n          if (action === 'start') {\n            // Ignore the item if a transfer has already been started for the same asset ID\n            if (assets[assetID]) {\n              continue;\n            }\n\n            // Register the asset\n            assets[assetID] = {\n              ...item.data,\n              stream: new PassThrough(),\n              status: 'idle',\n              queue: [],\n            };\n\n            // Connect the individual asset stream to the main asset stage stream\n            // Note: nothing is transferred until data chunks are fed to the asset stream\n            await this.writeAsync(pass, assets[assetID]);\n          }\n\n          // Writes the asset's data chunks to their corresponding stream\n          else if (action === 'stream') {\n            // If the asset hasn't been registered, or if it's been closed already, then ignore the message\n            if (!assets[assetID]) {\n              continue;\n            }\n\n            switch (assets[assetID].status) {\n              // The asset is ready to accept a new chunk, write it now\n              case 'idle':\n                await writeAssetChunk(assetID, item.data);\n                break;\n              // The resource is busy, queue the current chunk so that it gets transferred as soon as possible\n              case 'busy':\n                assets[assetID].queue.push(item);\n                break;\n              // Ignore asset chunks for assets with a closed/errored status\n              case 'closed':\n              case 'errored':\n              default:\n                break;\n            }\n          }\n\n          // All the asset chunks have been transferred\n          else if (action === 'end') {\n            // If the asset has already been closed, or if it was never registered, ignore the command\n            if (!assets[assetID]) {\n              continue;\n            }\n\n            switch (assets[assetID].status) {\n              // There's no ongoing activity, the asset is ready to be closed\n              case 'idle':\n              case 'errored':\n                await closeAssetStream(assetID);\n                break;\n              // The resource is busy, wait for a different state and close the stream.\n              case 'busy':\n                await Promise.race([\n                  // Either: wait for the asset to be ready to be closed\n                  waitUntil(() => assets[assetID].status !== 'busy', 100),\n                  // Or: if the last chunks are still not processed after ten seconds\n                  wait(10000),\n                ]);\n\n                await closeAssetStream(assetID);\n                break;\n              // Ignore commands for assets being currently closed\n              case 'closed':\n              default:\n                break;\n            }\n          }\n        }\n      })\n      .on('close', () => {\n        pass.end();\n      });\n\n    /**\n     * Writes a chunk of data for the specified asset with the given id.\n     */\n    const writeAssetChunk = async (id: string, data: unknown) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const { status: currentStatus } = assets[id];\n\n      if (currentStatus !== 'idle') {\n        throw new Error(\n          `Failed to write asset chunk for \"${id}\". The asset is currently \"${currentStatus}\"`\n        );\n      }\n\n      const nextItemInQueue = () => assets[id].queue.shift();\n\n      try {\n        // Lock the asset\n        assets[id].status = 'busy';\n\n        // Save the current chunk\n        await unsafe_writeAssetChunk(id, data);\n\n        // Empty the queue if needed\n        let item = nextItemInQueue();\n\n        while (item) {\n          await unsafe_writeAssetChunk(id, item.data);\n          item = nextItemInQueue();\n        }\n\n        // Unlock the asset\n        assets[id].status = 'idle';\n      } catch {\n        assets[id].status = 'errored';\n      }\n    };\n\n    /**\n     * Writes a chunk of data to the asset's stream.\n     *\n     * Only check if the targeted asset exists, no other validation is done.\n     */\n    const unsafe_writeAssetChunk = async (id: string, data: unknown) => {\n      const asset = assets[id];\n\n      if (!asset) {\n        throw new Error(`Failed to write asset chunk for \"${id}\". Asset not found.`);\n      }\n\n      const rawBuffer = data as { type: 'Buffer'; data: Uint8Array };\n      const chunk = Buffer.from(rawBuffer.data);\n\n      await this.writeAsync(asset.stream, chunk);\n    };\n\n    /**\n     * Closes the asset stream associated with the given ID.\n     *\n     * It deletes the stream for the asset upon successful closure.\n     */\n    const closeAssetStream = async (id: string) => {\n      if (!assets[id]) {\n        throw new Error(`Failed to close asset \"${id}\". Asset not found.`);\n      }\n\n      assets[id].status = 'closed';\n\n      await new Promise<void>((resolve, reject) => {\n        const { stream } = assets[id];\n\n        stream\n          .on('close', () => {\n            delete assets[id];\n\n            resolve();\n          })\n          .on('error', reject)\n          .end();\n      });\n    };\n\n    return pass;\n  }\n\n  createConfigurationReadStream(): MaybePromise<Readable> {\n    return this.#createStageReadStream('configuration');\n  }\n\n  async getMetadata(): Promise<IMetadata | null> {\n    const metadata = await this.dispatcher?.dispatchTransferAction<IMetadata>('getMetadata');\n\n    return metadata ?? null;\n  }\n\n  assertValidProtocol(url: URL) {\n    const validProtocols = ['https:', 'http:'];\n\n    if (!validProtocols.includes(url.protocol)) {\n      throw new ProviderValidationError(`Invalid protocol \"${url.protocol}\"`, {\n        check: 'url',\n        details: {\n          protocol: url.protocol,\n          validProtocols,\n        },\n      });\n    }\n  }\n\n  async initTransfer(): Promise<string> {\n    const query = this.dispatcher?.dispatchCommand({\n      command: 'init',\n    });\n\n    const res = (await query) as Server.Payload<Server.InitMessage>;\n\n    if (!res?.transferID) {\n      throw new ProviderTransferError('Init failed, invalid response from the server');\n    }\n\n    return res.transferID;\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'remote-source-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  async bootstrap(diagnostics?: IDiagnosticReporter): Promise<void> {\n    this.#diagnostics = diagnostics;\n    const { url, auth } = this.options;\n    let ws: WebSocket;\n    this.assertValidProtocol(url);\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    const wsUrl = `${wsProtocol}//${url.host}${trimTrailingSlash(\n      url.pathname\n    )}${TRANSFER_PATH}/pull`;\n\n    this.#reportInfo('establishing websocket connection');\n    // No auth defined, trying public access for transfer\n    if (!auth) {\n      ws = await connectToWebsocket(wsUrl, undefined, this.#diagnostics);\n    }\n\n    // Common token auth, this should be the main auth method\n    else if (auth.type === 'token') {\n      const headers = { Authorization: `Bearer ${auth.token}` };\n      ws = await connectToWebsocket(wsUrl, { headers }, this.#diagnostics);\n    }\n\n    // Invalid auth method provided\n    else {\n      throw new ProviderValidationError('Auth method not available', {\n        check: 'auth.type',\n        details: {\n          auth: auth.type,\n        },\n      });\n    }\n\n    this.#reportInfo('established websocket connection');\n    this.ws = ws;\n    const { retryMessageOptions } = this.options;\n\n    this.#reportInfo('creating dispatcher');\n    this.dispatcher = createDispatcher(this.ws, retryMessageOptions, (message: string) =>\n      this.#reportInfo(message)\n    );\n    this.#reportInfo('creating dispatcher');\n\n    this.#reportInfo('initialize transfer');\n    const transferID = await this.initTransfer();\n    this.#reportInfo(`initialized transfer ${transferID}`);\n\n    this.dispatcher.setTransferProperties({ id: transferID, kind: 'pull' });\n    await this.dispatcher.dispatchTransferAction('bootstrap');\n  }\n\n  async close() {\n    await this.dispatcher?.dispatchTransferAction('close');\n\n    await new Promise<void>((resolve) => {\n      const { ws } = this;\n\n      if (!ws || ws.CLOSED) {\n        resolve();\n        return;\n      }\n\n      ws.on('close', () => resolve()).close();\n    });\n  }\n\n  async getSchemas() {\n    const schemas =\n      await this.dispatcher?.dispatchTransferAction<Utils.String.Dict<Struct.Schema>>('getSchemas');\n\n    return schemas ?? null;\n  }\n\n  async #startStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      return await this.dispatcher?.dispatchTransferStep({ action: 'start', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n  }\n\n  async #respond(uuid: string) {\n    return new Promise((resolve, reject) => {\n      this.ws?.send(JSON.stringify({ uuid }), (e) => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve(e);\n        }\n      });\n    });\n  }\n\n  async #endStep<T extends Client.TransferPullStep>(step: T) {\n    try {\n      await this.dispatcher?.dispatchTransferStep({ action: 'end', step });\n    } catch (e) {\n      if (e instanceof Error) {\n        return e;\n      }\n\n      if (typeof e === 'string') {\n        return new ProviderTransferError(e);\n      }\n\n      return new ProviderTransferError('Unexpected error');\n    }\n\n    return null;\n  }\n}\n\nexport const createRemoteStrapiSourceProvider = (options: IRemoteStrapiSourceProviderOptions) => {\n  return new RemoteStrapiSourceProvider(options);\n};\n","// Local\nexport * from './local-destination';\nexport * from './local-source';\n\n// Remote\nexport * from './remote-destination';\nexport * from './remote-source';\n","import type { Step } from '.';\n\nexport default [\n  {\n    kind: 'action',\n    action: 'bootstrap',\n  },\n  {\n    kind: 'action',\n    action: 'init',\n  },\n  {\n    kind: 'action',\n    action: 'beforeTransfer',\n  },\n  {\n    kind: 'transfer',\n    stage: 'schemas',\n  },\n  {\n    kind: 'transfer',\n    stage: 'entities',\n  },\n  {\n    kind: 'transfer',\n    stage: 'assets',\n  },\n  {\n    kind: 'transfer',\n    stage: 'links',\n  },\n  {\n    kind: 'transfer',\n    stage: 'configuration',\n  },\n  {\n    kind: 'action',\n    action: 'close',\n  },\n] as readonly Step[];\n","import type { TransferStage } from '../../../../types';\n\nexport type Step =\n  | { kind: 'action'; action: string }\n  | { kind: 'transfer'; stage: TransferStage; locked?: boolean };\n\nexport { default as DEFAULT_TRANSFER_FLOW } from './default';\n\ninterface IState {\n  step: Step | null;\n}\n\nexport interface TransferFlow {\n  has(step: Step): boolean;\n  can(step: Step): boolean;\n  cannot(step: Step): boolean;\n  set(step: Step): this;\n  get(): Step | null;\n}\n\nexport const createFlow = (flow: readonly Step[]): TransferFlow => {\n  const state: IState = { step: null };\n\n  /**\n   * Equality check between two steps\n   */\n  const stepEqual = (stepA: Step, stepB: Step): boolean => {\n    if (stepA.kind === 'action' && stepB.kind === 'action') {\n      return stepA.action === stepB.action;\n    }\n\n    if (stepA.kind === 'transfer' && stepB.kind === 'transfer') {\n      return stepA.stage === stepB.stage;\n    }\n\n    return false;\n  };\n\n  /**\n   * Find the index for a given step\n   */\n  const findStepIndex = (step: Step) => flow.findIndex((flowStep) => stepEqual(step, flowStep));\n\n  return {\n    has(step: Step) {\n      return findStepIndex(step) !== -1;\n    },\n\n    can(step: Step) {\n      if (state.step === null) {\n        return true;\n      }\n\n      const indexesDifference = findStepIndex(step) - findStepIndex(state.step);\n\n      // It's possible to send multiple time the same transfer step in a row\n      if (indexesDifference === 0 && step.kind === 'transfer') {\n        return true;\n      }\n\n      return indexesDifference > 0;\n    },\n\n    cannot(step: Step) {\n      return !this.can(step);\n    },\n\n    set(step: Step) {\n      const canSwitch = this.can(step);\n\n      if (!canSwitch) {\n        throw new Error('Impossible to proceed to the given step');\n      }\n\n      state.step = step;\n\n      return this;\n    },\n\n    get() {\n      return state.step;\n    },\n  };\n};\n","export const VALID_TRANSFER_COMMANDS = ['init', 'end', 'status'] as const;\nexport type ValidTransferCommand = (typeof VALID_TRANSFER_COMMANDS)[number];\n","import type { IncomingMessage } from 'node:http';\nimport { randomUUID } from 'crypto';\nimport type { Context } from 'koa';\nimport type { RawData, ServerOptions } from 'ws';\nimport { WebSocket, WebSocketServer } from 'ws';\n\nimport type { Handler, TransferState } from './abstract';\nimport type { Protocol } from '../../../../types';\nimport { ProviderError, ProviderTransferError } from '../../../errors/providers';\nimport { VALID_TRANSFER_COMMANDS, ValidTransferCommand } from './constants';\nimport { TransferMethod } from '../constants';\nimport { createDiagnosticReporter } from '../../../utils/diagnostic';\n\ntype WSCallback = (client: WebSocket, request: IncomingMessage) => void;\n\nexport interface HandlerOptions {\n  verify: (ctx: Context, scope?: TransferMethod) => Promise<void>;\n  server?: ServerOptions;\n}\n\nexport const transformUpgradeHeader = (header = '') => {\n  return header.split(',').map((s) => s.trim().toLowerCase());\n};\n\nlet timeouts: Record<string, number> | undefined;\n\nconst hasHttpServer = () => {\n  // during server restarts, strapi may not have ever been defined at all, so we have to check it first\n  return typeof strapi !== 'undefined' && !!strapi?.server?.httpServer;\n};\n\n// temporarily disable server timeouts while transfer is running\nconst disableTimeouts = () => {\n  if (!hasHttpServer()) {\n    return;\n  }\n\n  const { httpServer } = strapi.server;\n\n  // save the original timeouts to restore after\n  if (!timeouts) {\n    timeouts = {\n      headersTimeout: httpServer.headersTimeout,\n      requestTimeout: httpServer.requestTimeout,\n    };\n  }\n\n  httpServer.headersTimeout = 0;\n  httpServer.requestTimeout = 0;\n\n  strapi.log.info('[Data transfer] Disabling http timeouts');\n};\nconst resetTimeouts = () => {\n  if (!hasHttpServer() || !timeouts) {\n    return;\n  }\n\n  const { httpServer } = strapi.server;\n\n  strapi.log.info('[Data transfer] Restoring http timeouts');\n  httpServer.headersTimeout = timeouts.headersTimeout;\n  httpServer.requestTimeout = timeouts.requestTimeout;\n};\n/**\n * Make sure that the upgrade header is a valid websocket one\n */\nexport const assertValidHeader = (ctx: Context) => {\n  // if it's exactly what we expect, it's fine\n  if (ctx.headers.upgrade === 'websocket') {\n    return;\n  }\n\n  // check if it could be an array that still includes websocket\n  const upgradeHeader = transformUpgradeHeader(ctx.headers.upgrade);\n\n  // Sanitize user input before writing it to our logs\n  const logSafeUpgradeHeader = JSON.stringify(ctx.headers.upgrade)\n    ?.replace(/[^a-z0-9\\s.,|]/gi, '')\n    .substring(0, 50);\n\n  if (!upgradeHeader.includes('websocket')) {\n    throw new Error(\n      `Transfer Upgrade header expected 'websocket', found '${logSafeUpgradeHeader}'. Please ensure that your server or proxy is not modifying the Upgrade header.`\n    );\n  }\n\n  /**\n   * If there's more than expected but it still includes websocket, in theory it could still work\n   * and could be necessary for their certain configurations, so we'll allow it to proceed but\n   * log the unexpected behaviour in case it helps debug an issue\n   * */\n  strapi.log.info(\n    `Transfer Upgrade header expected only 'websocket', found unexpected values: ${logSafeUpgradeHeader}`\n  );\n};\n\nexport const isDataTransferMessage = (message: unknown): message is Protocol.Client.Message => {\n  if (!message || typeof message !== 'object') {\n    return false;\n  }\n\n  const { uuid, type } = message as Record<string, unknown>;\n\n  if (typeof uuid !== 'string' || typeof type !== 'string') {\n    return false;\n  }\n\n  if (!['command', 'transfer'].includes(type)) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Handle the upgrade to ws connection\n */\nexport const handleWSUpgrade = (wss: WebSocketServer, ctx: Context, callback: WSCallback) => {\n  assertValidHeader(ctx);\n\n  wss.handleUpgrade(ctx.req, ctx.request.socket, Buffer.alloc(0), (client, request) => {\n    if (!client) {\n      // If the WebSocket upgrade failed, destroy the socket to avoid hanging\n      ctx.request.socket.destroy();\n      return;\n    }\n\n    disableTimeouts();\n    strapi.db.lifecycles.disable();\n    strapi.log.info('[Data transfer] Disabling lifecycle hooks');\n\n    // Create a connection between the client & the server\n    wss.emit('connection', client, ctx.req);\n\n    // Invoke the ws callback\n    callback(client, request);\n  });\n\n  ctx.respond = false;\n};\n\n// Protocol related functions\n\nexport const handlerControllerFactory =\n  <T extends Partial<Handler>>(implementation: (proto: Handler) => T) =>\n  (options: HandlerOptions) => {\n    const { verify, server: serverOptions } = options ?? {};\n\n    const wss = new WebSocket.Server({ ...serverOptions, noServer: true });\n\n    return async (ctx: Context) => {\n      const cb: WSCallback = (ws) => {\n        const state: TransferState = { id: undefined };\n        const messageUUIDs = new Set<string>();\n        const diagnostics = createDiagnosticReporter();\n\n        const cannotRespondHandler = (err: unknown) => {\n          strapi?.log?.error(\n            '[Data transfer] Cannot send error response to client, closing connection'\n          );\n          strapi?.log?.error(err);\n          try {\n            ws.terminate();\n            ctx.req.socket.destroy();\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Failed to close socket on error');\n          }\n        };\n\n        const prototype: Handler = {\n          // Transfer ID\n          get transferID() {\n            return state.id;\n          },\n\n          set transferID(id) {\n            state.id = id;\n          },\n\n          // Started at\n          get startedAt() {\n            return state.startedAt;\n          },\n\n          set startedAt(timestamp) {\n            state.startedAt = timestamp;\n          },\n\n          get response() {\n            return state.response;\n          },\n\n          set response(response) {\n            state.response = response;\n          },\n\n          get diagnostics() {\n            return diagnostics;\n          },\n\n          addUUID(uuid) {\n            messageUUIDs.add(uuid);\n          },\n\n          hasUUID(uuid) {\n            return messageUUIDs.has(uuid);\n          },\n\n          isTransferStarted() {\n            return this.transferID !== undefined && this.startedAt !== undefined;\n          },\n\n          assertValidTransfer() {\n            const isStarted = this.isTransferStarted();\n\n            if (!isStarted) {\n              throw new Error('Invalid Transfer Process');\n            }\n          },\n\n          assertValidTransferCommand(command: ValidTransferCommand) {\n            const isDefined = typeof this[command] === 'function';\n            const isValidTransferCommand = VALID_TRANSFER_COMMANDS.includes(command);\n\n            if (!isDefined || !isValidTransferCommand) {\n              throw new Error('Invalid transfer command');\n            }\n          },\n\n          async respond(uuid, e, data) {\n            let details = {};\n            return new Promise<void>((resolve, reject) => {\n              if (!uuid && !e) {\n                reject(new Error('Missing uuid for this message'));\n                return;\n              }\n\n              this.response = {\n                uuid,\n                data,\n                e,\n              };\n\n              if (e instanceof ProviderError) {\n                details = e.details;\n              }\n\n              const payload = JSON.stringify({\n                uuid,\n                data: data ?? null,\n                error: e\n                  ? {\n                      code: e?.name ?? 'ERR',\n                      message: e?.message,\n                      details,\n                    }\n                  : null,\n              });\n\n              this.send(payload, (error) => (error ? reject(error) : resolve()));\n            });\n          },\n\n          send(message, cb) {\n            ws.send(message, cb);\n          },\n          confirm(message) {\n            return new Promise((resolve, reject) => {\n              const uuid = randomUUID();\n\n              const payload = JSON.stringify({ uuid, data: message });\n\n              this.send(payload, (error) => {\n                if (error) {\n                  reject(error);\n                }\n              });\n\n              const onResponse = (raw: RawData) => {\n                const response = JSON.parse(raw.toString());\n\n                if (response.uuid === uuid) {\n                  resolve(response.data ?? null);\n                } else {\n                  ws.once('message', onResponse);\n                }\n              };\n\n              ws.once('message', onResponse);\n            });\n          },\n\n          async executeAndRespond(uuid, fn) {\n            try {\n              const response = await fn();\n              await this.respond(uuid, null, response);\n            } catch (e) {\n              if (e instanceof Error) {\n                await this.respond(uuid, e).catch(cannotRespondHandler);\n              } else if (typeof e === 'string') {\n                await this.respond(uuid, new ProviderTransferError(e)).catch(cannotRespondHandler);\n              } else {\n                await this.respond(\n                  uuid,\n                  new ProviderTransferError('Unexpected error', {\n                    error: e,\n                  })\n                ).catch(cannotRespondHandler);\n              }\n            }\n          },\n\n          cleanup() {\n            this.transferID = undefined;\n            this.startedAt = undefined;\n            this.response = undefined;\n          },\n\n          teardown() {\n            this.cleanup();\n          },\n\n          verifyAuth(scope?: TransferMethod) {\n            return verify(ctx, scope);\n          },\n\n          // Transfer commands\n          init() {},\n          end() {},\n          status() {},\n\n          // Default prototype implementation for events\n          onMessage() {},\n          onError() {},\n          onClose() {},\n          onInfo() {},\n          onWarning() {},\n        };\n\n        const handler: Handler = Object.assign(Object.create(prototype), implementation(prototype));\n\n        // Bind ws events to handler methods\n        ws.on('close', async (...args) => {\n          try {\n            await handler.onClose(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error closing connection');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          } finally {\n            resetTimeouts();\n            strapi.db.lifecycles.enable();\n            strapi.log.info('[Data transfer] Restoring lifecycle hooks');\n          }\n        });\n        ws.on('error', async (...args) => {\n          try {\n            await handler.onError(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error in error handling');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          }\n        });\n        ws.on('message', async (...args) => {\n          try {\n            await handler.onMessage(...args);\n          } catch (err) {\n            strapi?.log?.error('[Data transfer] Uncaught error in message handling');\n            strapi?.log?.error(err);\n            cannotRespondHandler(err);\n          }\n        });\n\n        diagnostics.onDiagnostic((diagnostic) => {\n          const uuid = randomUUID();\n          const payload = JSON.stringify({\n            diagnostic,\n            uuid,\n          });\n\n          handler.send(payload);\n        });\n      };\n\n      try {\n        handleWSUpgrade(wss, ctx, cb);\n      } catch (err) {\n        strapi?.log?.error('[Data transfer] Error in websocket upgrade request');\n        strapi?.log?.error(err);\n      }\n    };\n  };\n","import { randomUUID } from 'crypto';\nimport { Writable, PassThrough } from 'stream';\nimport type { Core } from '@strapi/types';\n\nimport type { TransferFlow, Step } from '../flows';\nimport type { TransferStage, IAsset, Protocol } from '../../../../types';\n\nimport { ProviderTransferError } from '../../../errors/providers';\nimport { createLocalStrapiDestinationProvider } from '../../providers';\nimport { createFlow, DEFAULT_TRANSFER_FLOW } from '../flows';\nimport { Handler } from './abstract';\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\n\nconst VALID_TRANSFER_ACTIONS = [\n  'bootstrap',\n  'close',\n  'rollback',\n  'beforeTransfer',\n  'getMetadata',\n  'getSchemas',\n] as const;\n\ntype PushTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\n\nconst TRANSFER_KIND = 'push';\n\nexport interface PushHandler extends Handler {\n  /**\n   * Local Strapi Destination Provider used to write data to the current Strapi instance\n   */\n  provider?: ReturnType<typeof createLocalStrapiDestinationProvider>;\n\n  /**\n   * Holds all the stages' stream for the current transfer handler (one registry per connection)\n   */\n  streams?: { [stage in TransferStage]?: Writable };\n\n  stats: {\n    [stage in Exclude<TransferStage, 'schemas'>]: Protocol.Client.Stats;\n  };\n\n  /**\n   * Holds all the transferred assets for the current transfer handler (one registry per connection)\n   */\n  assets: { [filepath: string]: IAsset & { stream: PassThrough } };\n\n  /**\n   * Ochestrate and manage the transfer messages' ordering\n   */\n  flow?: TransferFlow;\n\n  /**\n   * Checks that the given action is a valid push transfer action\n   */\n  assertValidTransferAction(action: string): asserts action is PushTransferAction;\n\n  /**\n   * Create a new writable stream for the given step in the handler's stream registry\n   */\n  createWritableStreamForStep(step: TransferStage): Promise<void>;\n\n  /**\n   * Simple override of the auth verification\n   */\n  verifyAuth(): Promise<void>;\n\n  /**\n   * Callback when receiving a regular transfer message\n   */\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\n\n  /**\n   * Callback when receiving a transfer action message\n   */\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\n\n  /**\n   * Callback when receiving a transfer step message\n   */\n  onTransferStep(msg: Protocol.Client.TransferPushMessage): Promise<unknown> | unknown;\n\n  /**\n   * Start streaming an asset\n   */\n  streamAsset(\n    this: PushHandler,\n    payload: Protocol.Client.GetTransferPushStreamData<'assets'>\n  ): Promise<void>;\n\n  // Transfer Flow\n\n  /**\n   * Try to move to a specific transfer stage & lock the step\n   */\n  lockTransferStep(stage: TransferStage): void;\n\n  /**\n   * Try to move to unlock the current step\n   */\n  unlockTransferStep(stage: TransferStage): void;\n\n  /**\n   * Checks whether it's possible to stream a chunk for the given stage\n   */\n  assertValidStreamTransferStep(stage: TransferStage): void;\n}\n\nconst writeAsync = <T>(stream: Writable, data: T) => {\n  return new Promise<void>((resolve, reject) => {\n    stream.write(data, (error) => {\n      if (error) {\n        reject(error);\n      }\n\n      resolve();\n    });\n  });\n};\n\nexport const createPushController = handlerControllerFactory<Partial<PushHandler>>((proto) => ({\n  isTransferStarted(this: PushHandler) {\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\n  },\n\n  verifyAuth(this: PushHandler) {\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\n  },\n  onInfo(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        origin: 'push-handler',\n        createdAt: new Date(),\n      },\n      kind: 'info',\n    });\n  },\n  onWarning(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        createdAt: new Date(),\n        origin: 'push-handler',\n      },\n      kind: 'warning',\n    });\n  },\n  cleanup(this: PushHandler) {\n    proto.cleanup.call(this);\n\n    this.streams = {};\n    this.assets = {};\n\n    delete this.flow;\n    delete this.provider;\n  },\n\n  teardown(this: PushHandler) {\n    if (this.provider) {\n      this.provider.rollback();\n    }\n\n    proto.teardown.call(this);\n  },\n\n  assertValidTransfer(this: PushHandler) {\n    proto.assertValidTransfer.call(this);\n\n    if (this.provider === undefined) {\n      throw new Error('Invalid Transfer Process');\n    }\n  },\n\n  assertValidTransferAction(this: PushHandler, action: PushTransferAction) {\n    if (VALID_TRANSFER_ACTIONS.includes(action)) {\n      return;\n    }\n\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\n      action,\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\n    });\n  },\n\n  assertValidStreamTransferStep(this: PushHandler, stage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\n      throw new ProviderTransferError(\n        `You need to initialize the transfer stage (${nextStep}) before starting to stream data`\n      );\n    }\n\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${nextStep}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n  },\n\n  async createWritableStreamForStep(this: PushHandler, step: Exclude<TransferStage, 'schemas'>) {\n    const mapper = {\n      entities: () => this.provider?.createEntitiesWriteStream(),\n      links: () => this.provider?.createLinksWriteStream(),\n      configuration: () => this.provider?.createConfigurationWriteStream(),\n      assets: () => this.provider?.createAssetsWriteStream(),\n    };\n\n    if (!(step in mapper)) {\n      throw new Error('Invalid transfer step, impossible to create a stream');\n    }\n\n    if (!this.streams) {\n      throw new Error('Invalid transfer state');\n    }\n\n    this.streams[step] = await mapper[step]();\n  },\n\n  async onMessage(this: PushHandler, raw) {\n    const msg = JSON.parse(raw.toString());\n\n    if (!isDataTransferMessage(msg)) {\n      return;\n    }\n\n    if (!msg.uuid) {\n      await this.respond(undefined, new Error('Missing uuid in message'));\n    }\n\n    if (proto.hasUUID(msg.uuid)) {\n      const previousResponse = proto.response;\n      if (previousResponse?.uuid === msg.uuid) {\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\n      }\n      return;\n    }\n\n    const { uuid, type } = msg;\n    proto.addUUID(uuid);\n    // Regular command message (init, end, status)\n    if (type === 'command') {\n      const { command } = msg;\n      this.onInfo(`received command:${command} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, () => {\n        this.assertValidTransferCommand(command);\n\n        // The status command don't have params\n        if (command === 'status') {\n          return this.status();\n        }\n        return this[command](msg.params);\n      });\n    }\n\n    // Transfer message (the transfer must be init first)\n    else if (type === 'transfer') {\n      this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, async () => {\n        await this.verifyAuth();\n\n        this.assertValidTransfer();\n\n        return this.onTransferMessage(msg);\n      });\n    }\n\n    // Invalid messages\n    else {\n      await this.respond(uuid, new Error('Bad Request'));\n    }\n  },\n\n  async onTransferMessage(this: PushHandler, msg) {\n    const { kind } = msg;\n\n    if (kind === 'action') {\n      return this.onTransferAction(msg);\n    }\n\n    if (kind === 'step') {\n      return this.onTransferStep(msg as Protocol.Client.TransferPushMessage);\n    }\n  },\n\n  lockTransferStep(stage: TransferStage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    if (currentStep?.kind === 'transfer' && currentStep.locked) {\n      throw new ProviderTransferError(\n        `It's not possible to start a new transfer stage (${stage}) while another one is in progress (${currentStep.stage})`\n      );\n    }\n\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n\n    this.flow?.set({ ...nextStep, locked: true });\n  },\n\n  unlockTransferStep(stage: TransferStage) {\n    const currentStep = this.flow?.get();\n    const nextStep: Step = { kind: 'transfer', stage };\n\n    // Cannot unlock if not locked (aka: started)\n    if (currentStep?.kind === 'transfer' && !currentStep.locked) {\n      throw new ProviderTransferError(\n        `You need to initialize the transfer stage (${stage}) before ending it`\n      );\n    }\n\n    // Cannot unlock if invalid step provided\n    if (this.flow?.cannot(nextStep)) {\n      throw new ProviderTransferError(`Invalid stage (${stage}) provided for the current flow`, {\n        step: nextStep,\n      });\n    }\n\n    this.flow?.set({ ...nextStep, locked: false });\n  },\n\n  async onTransferStep(this: PushHandler, msg) {\n    const { step: stage } = msg;\n\n    if (msg.action === 'start') {\n      this.lockTransferStep(stage);\n\n      if (this.streams?.[stage] instanceof Writable) {\n        throw new Error('Stream already created, something went wrong');\n      }\n\n      await this.createWritableStreamForStep(stage);\n\n      this.stats[stage] = { started: 0, finished: 0 };\n\n      return { ok: true };\n    }\n\n    if (msg.action === 'stream') {\n      this.assertValidStreamTransferStep(stage);\n\n      // Stream operation on the current transfer stage\n      const stream = this.streams?.[stage];\n\n      if (!stream) {\n        throw new Error('You need to init first');\n      }\n\n      // Assets are nested streams\n      if (stage === 'assets') {\n        return this.streamAsset(msg.data);\n      }\n\n      // For all other steps\n      await Promise.all(\n        msg.data.map(async (item) => {\n          this.stats[stage].started += 1;\n          await writeAsync(stream, item);\n          this.stats[stage].finished += 1;\n        })\n      );\n    }\n\n    if (msg.action === 'end') {\n      this.unlockTransferStep(stage);\n      const stream = this.streams?.[stage];\n\n      if (stream && !stream.closed) {\n        await new Promise((resolve, reject) => {\n          stream.on('close', resolve).on('error', reject).end();\n        });\n      }\n\n      delete this.streams?.[stage];\n\n      return { ok: true, stats: this.stats[stage] };\n    }\n  },\n\n  async onTransferAction(this: PushHandler, msg) {\n    const { action } = msg;\n\n    this.assertValidTransferAction(action);\n\n    const step: Step = { kind: 'action', action };\n    const isStepRegistered = this.flow?.has(step);\n\n    if (isStepRegistered) {\n      if (this.flow?.cannot(step)) {\n        throw new ProviderTransferError(`Invalid action \"${action}\" found for the current flow `, {\n          action,\n        });\n      }\n\n      this.flow?.set(step);\n    }\n    if (action === 'bootstrap') {\n      return this.provider?.[action](this.diagnostics);\n    }\n    return this.provider?.[action]();\n  },\n\n  async streamAsset(this: PushHandler, payload) {\n    const assetsStream = this.streams?.assets;\n\n    // TODO: close the stream upon receiving an 'end' event instead\n    if (payload === null) {\n      this.streams?.assets?.end();\n      return;\n    }\n\n    for (const item of payload) {\n      const { action, assetID } = item;\n\n      if (!assetsStream) {\n        throw new Error('Stream not defined');\n      }\n\n      if (action === 'start') {\n        this.stats.assets.started += 1;\n        this.assets[assetID] = { ...item.data, stream: new PassThrough() };\n        writeAsync(assetsStream, this.assets[assetID]);\n      }\n\n      if (action === 'stream') {\n        // The buffer has gone through JSON operations and is now of shape { type: \"Buffer\"; data: UInt8Array }\n        // We need to transform it back into a Buffer instance\n        const rawBuffer = item.data as unknown as { type: 'Buffer'; data: Uint8Array };\n        const chunk = Buffer.from(rawBuffer.data);\n        await writeAsync(this.assets[assetID].stream, chunk);\n      }\n\n      if (action === 'end') {\n        await new Promise<void>((resolve, reject) => {\n          const { stream: assetStream } = this.assets[assetID];\n          assetStream\n            .on('close', () => {\n              this.stats.assets.finished += 1;\n              delete this.assets[assetID];\n              resolve();\n            })\n            .on('error', reject)\n            .end();\n        });\n      }\n    }\n  },\n\n  onClose(this: Handler) {\n    this.teardown();\n  },\n\n  onError(this: Handler, err) {\n    this.teardown();\n    strapi.log.error(err);\n  },\n\n  // Commands\n\n  async init(\n    this: PushHandler,\n    params: Protocol.Client.GetCommandParams<'init'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.InitMessage>> {\n    if (this.transferID || this.provider) {\n      throw new Error('Transfer already in progress');\n    }\n\n    await this.verifyAuth();\n\n    this.transferID = randomUUID();\n    this.startedAt = Date.now();\n\n    this.assets = {};\n    this.streams = {};\n    this.stats = {\n      assets: { started: 0, finished: 0 },\n      configuration: { started: 0, finished: 0 },\n      entities: { started: 0, finished: 0 },\n      links: { started: 0, finished: 0 },\n    };\n\n    this.flow = createFlow(DEFAULT_TRANSFER_FLOW);\n\n    this.provider = createLocalStrapiDestinationProvider({\n      ...params.options,\n      autoDestroy: false,\n      getStrapi: () => strapi as Core.Strapi,\n    });\n\n    this.provider.onWarning = (message) => {\n      this.onWarning(message);\n      strapi.log.warn(message);\n    };\n\n    return { transferID: this.transferID };\n  },\n\n  async status(this: PushHandler) {\n    const isStarted = this.isTransferStarted();\n\n    if (isStarted) {\n      const startedAt = this.startedAt as number;\n\n      return {\n        active: true,\n        kind: TRANSFER_KIND,\n        startedAt,\n        elapsed: Date.now() - startedAt,\n      };\n    }\n\n    return { active: false, kind: null, elapsed: null, startedAt: null };\n  },\n\n  async end(\n    this: PushHandler,\n    params: Protocol.Client.GetCommandParams<'end'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\n    await this.verifyAuth();\n\n    if (this.transferID !== params?.transferID) {\n      throw new ProviderTransferError('Bad transfer ID provided');\n    }\n\n    this.cleanup();\n\n    return { ok: true };\n  },\n}));\n","import { Readable } from 'stream';\nimport { randomUUID } from 'crypto';\nimport type { Core } from '@strapi/types';\n\nimport { Handler } from './abstract';\nimport { handlerControllerFactory, isDataTransferMessage } from './utils';\nimport { createLocalStrapiSourceProvider, ILocalStrapiSourceProvider } from '../../providers';\nimport { ProviderTransferError } from '../../../errors/providers';\nimport type { IAsset, TransferStage, Protocol } from '../../../../types';\nimport { Client } from '../../../../types/remote/protocol';\n\nconst TRANSFER_KIND = 'pull';\nconst VALID_TRANSFER_ACTIONS = ['bootstrap', 'close', 'getMetadata', 'getSchemas'] as const;\n\ntype PullTransferAction = (typeof VALID_TRANSFER_ACTIONS)[number];\n\nexport interface PullHandler extends Handler {\n  provider?: ILocalStrapiSourceProvider;\n\n  streams?: { [stage in TransferStage]?: Readable };\n\n  assertValidTransferAction(action: string): asserts action is PullTransferAction;\n\n  onTransferMessage(msg: Protocol.Client.TransferMessage): Promise<unknown> | unknown;\n  onTransferAction(msg: Protocol.Client.Action): Promise<unknown> | unknown;\n  onTransferStep(msg: Protocol.Client.TransferPullMessage): Promise<unknown> | unknown;\n\n  createReadableStreamForStep(step: TransferStage): Promise<void>;\n\n  flush(stage: TransferStage, id: string): Promise<void> | void;\n}\n\nexport const createPullController = handlerControllerFactory<Partial<PullHandler>>((proto) => ({\n  isTransferStarted(this: PullHandler) {\n    return proto.isTransferStarted.call(this) && this.provider !== undefined;\n  },\n\n  verifyAuth(this: PullHandler) {\n    return proto.verifyAuth.call(this, TRANSFER_KIND);\n  },\n\n  cleanup(this: PullHandler) {\n    proto.cleanup.call(this);\n\n    this.streams = {};\n\n    delete this.provider;\n  },\n\n  onInfo(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        origin: 'pull-handler',\n        createdAt: new Date(),\n      },\n      kind: 'info',\n    });\n  },\n  onWarning(message) {\n    this.diagnostics?.report({\n      details: {\n        message,\n        createdAt: new Date(),\n        origin: 'pull-handler',\n      },\n      kind: 'warning',\n    });\n  },\n\n  assertValidTransferAction(this: PullHandler, action) {\n    // Abstract the constant to string[] to allow looser check on the given action\n    const validActions = VALID_TRANSFER_ACTIONS as unknown as string[];\n\n    if (validActions.includes(action)) {\n      return;\n    }\n\n    throw new ProviderTransferError(`Invalid action provided: \"${action}\"`, {\n      action,\n      validActions: Object.keys(VALID_TRANSFER_ACTIONS),\n    });\n  },\n\n  async onMessage(this: PullHandler, raw) {\n    const msg = JSON.parse(raw.toString());\n\n    if (!isDataTransferMessage(msg)) {\n      return;\n    }\n\n    if (!msg.uuid) {\n      await this.respond(undefined, new Error('Missing uuid in message'));\n    }\n\n    if (proto.hasUUID(msg.uuid)) {\n      const previousResponse = proto.response;\n      if (previousResponse?.uuid === msg.uuid) {\n        await this.respond(previousResponse?.uuid, previousResponse.e, previousResponse.data);\n      }\n      return;\n    }\n\n    const { uuid, type } = msg;\n    proto.addUUID(uuid);\n    // Regular command message (init, end, status)\n    if (type === 'command') {\n      const { command } = msg;\n      this.onInfo(`received command:${command} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, () => {\n        this.assertValidTransferCommand(command);\n\n        // The status command don't have params\n        if (command === 'status') {\n          return this.status();\n        }\n\n        return this[command](msg.params);\n      });\n    }\n\n    // Transfer message (the transfer must be init first)\n    else if (type === 'transfer') {\n      this.onInfo(`received transfer action:${msg.action} step:${msg.kind} uuid:${uuid}`);\n      await this.executeAndRespond(uuid, async () => {\n        await this.verifyAuth();\n\n        this.assertValidTransfer();\n\n        return this.onTransferMessage(msg);\n      });\n    }\n\n    // Invalid messages\n    else {\n      await this.respond(uuid, new Error('Bad Request'));\n    }\n  },\n\n  async onTransferMessage(this: PullHandler, msg) {\n    const { kind } = msg;\n\n    if (kind === 'action') {\n      return this.onTransferAction(msg);\n    }\n\n    if (kind === 'step') {\n      return this.onTransferStep(msg as Protocol.Client.TransferPullMessage);\n    }\n  },\n\n  async onTransferAction(this: PullHandler, msg) {\n    const { action } = msg;\n\n    this.assertValidTransferAction(action);\n\n    if (action === 'bootstrap') {\n      return this.provider?.[action](this.diagnostics);\n    }\n    return this.provider?.[action]();\n  },\n\n  async flush(this: PullHandler, stage: Client.TransferPullStep, id) {\n    type Stage = typeof stage;\n    const batchSize = 1024 * 1024;\n    let batch = [] as Client.GetTransferPullStreamData<Stage>;\n    const stream = this.streams?.[stage];\n\n    const batchLength = () => Buffer.byteLength(JSON.stringify(batch));\n    const sendBatch = async () => {\n      await this.confirm({\n        type: 'transfer',\n        data: batch,\n        ended: false,\n        error: null,\n        id,\n      });\n    };\n\n    if (!stream) {\n      throw new ProviderTransferError(`No available stream found for ${stage}`);\n    }\n\n    try {\n      for await (const chunk of stream) {\n        if (stage !== 'assets') {\n          batch.push(chunk);\n          if (batchLength() >= batchSize) {\n            await sendBatch();\n            batch = [];\n          }\n        } else {\n          await this.confirm({\n            type: 'transfer',\n            data: [chunk],\n            ended: false,\n            error: null,\n            id,\n          });\n        }\n      }\n\n      if (batch.length > 0 && stage !== 'assets') {\n        await sendBatch();\n        batch = [];\n      }\n      await this.confirm({ type: 'transfer', data: null, ended: true, error: null, id });\n    } catch (e) {\n      await this.confirm({ type: 'transfer', data: null, ended: true, error: e, id });\n    }\n  },\n\n  async onTransferStep(this: PullHandler, msg) {\n    const { step, action } = msg;\n\n    if (action === 'start') {\n      if (this.streams?.[step] instanceof Readable) {\n        throw new Error('Stream already created, something went wrong');\n      }\n\n      const flushUUID = randomUUID();\n\n      await this.createReadableStreamForStep(step);\n      this.flush(step, flushUUID);\n\n      return { ok: true, id: flushUUID };\n    }\n\n    if (action === 'end') {\n      const stream = this.streams?.[step];\n\n      if (stream?.readableEnded === false) {\n        await new Promise((resolve) => {\n          stream?.on('close', resolve).destroy();\n        });\n      }\n\n      delete this.streams?.[step];\n\n      return { ok: true };\n    }\n  },\n\n  async createReadableStreamForStep(this: PullHandler, step: Exclude<TransferStage, 'schemas'>) {\n    const mapper = {\n      entities: () => this.provider?.createEntitiesReadStream(),\n      links: () => this.provider?.createLinksReadStream(),\n      configuration: () => this.provider?.createConfigurationReadStream(),\n      assets: () => {\n        const assets = this.provider?.createAssetsReadStream();\n        let batch: Protocol.Client.TransferAssetFlow[] = [];\n\n        const batchLength = () => {\n          return batch.reduce(\n            (acc, chunk) => (chunk.action === 'stream' ? acc + chunk.data.byteLength : acc),\n            0\n          );\n        };\n\n        const BATCH_MAX_SIZE = 1024 * 1024; // 1MB\n\n        if (!assets) {\n          throw new Error('bad');\n        }\n        /**\n         * Generates batches of 1MB of data from the assets stream to avoid\n         * sending too many small chunks\n         *\n         * @param stream Assets stream from the local source provider\n         */\n        async function* generator(stream: Readable) {\n          let hasStarted = false;\n          let assetID = '';\n\n          for await (const chunk of stream) {\n            const { stream: assetStream, ...assetData } = chunk as IAsset;\n            if (!hasStarted) {\n              assetID = randomUUID();\n              // Start the transfer of a new asset\n              batch.push({ action: 'start', assetID, data: assetData });\n              hasStarted = true;\n            }\n\n            for await (const assetChunk of assetStream) {\n              // Add the asset data to the batch\n              batch.push({ action: 'stream', assetID, data: assetChunk });\n\n              // if the batch size is bigger than BATCH_MAX_SIZE stream the batch\n              if (batchLength() >= BATCH_MAX_SIZE) {\n                yield batch;\n                batch = [];\n              }\n            }\n\n            // All the asset data has been streamed and gets ready for the next one\n            hasStarted = false;\n            batch.push({ action: 'end', assetID });\n            yield batch;\n            batch = [];\n          }\n        }\n\n        return Readable.from(generator(assets));\n      },\n    };\n\n    if (!(step in mapper)) {\n      throw new Error('Invalid transfer step, impossible to create a stream');\n    }\n\n    if (!this.streams) {\n      throw new Error('Invalid transfer state');\n    }\n\n    this.streams[step] = await mapper[step]();\n  },\n\n  // Commands\n  async init(this: PullHandler) {\n    if (this.transferID || this.provider) {\n      throw new Error('Transfer already in progress');\n    }\n    await this.verifyAuth();\n\n    this.transferID = randomUUID();\n    this.startedAt = Date.now();\n\n    this.streams = {};\n\n    this.provider = createLocalStrapiSourceProvider({\n      autoDestroy: false,\n      getStrapi: () => strapi as Core.Strapi,\n    });\n\n    return { transferID: this.transferID };\n  },\n\n  async end(\n    this: PullHandler,\n    params: Protocol.Client.GetCommandParams<'end'>\n  ): Promise<Protocol.Server.Payload<Protocol.Server.EndMessage>> {\n    await this.verifyAuth();\n\n    if (this.transferID !== params?.transferID) {\n      throw new ProviderTransferError('Bad transfer ID provided');\n    }\n\n    this.cleanup();\n\n    return { ok: true };\n  },\n\n  async status(this: PullHandler) {\n    const isStarted = this.isTransferStarted();\n\n    if (!isStarted) {\n      const startedAt = this.startedAt as number;\n      return {\n        active: true,\n        kind: TRANSFER_KIND,\n        startedAt,\n        elapsed: Date.now() - startedAt,\n      };\n    }\n    return { active: false, kind: null, elapsed: null, startedAt: null };\n  },\n}));\n","import path from 'path';\n\n/**\n * Note: in versions of the transfer engine <=4.9.0, exports were generated with windows paths\n * on Windows systems, and posix paths on posix systems.\n *\n * We now store all paths as posix, but need to leave a separator conversion for legacy purposes, and to\n * support manually-created tar files coming from Windows systems (ie, if a user creates a\n * backup file with a windows tar tool rather than using the `export` command)\n *\n * Because of this, export/import files may never contain files with a forward slash in the name, even escaped\n *\n * */\n\n/**\n * Check if the directory of a given filePath (which can be either posix or win32) resolves to the same as the given posix-format path posixDirName\n * We must be able to assume the first argument is a path to a directory and the second is a path to a file, otherwise path.dirname will interpret a path without any slashes as the filename\n *\n * @param {string} posixDirName A posix path pointing to a directory\n * @param {string} filePath an unknown filesystem path pointing to a file\n * @returns {boolean} is the file located in the given directory\n */\nexport const isFilePathInDirname = (posixDirName: string, filePath: string) => {\n  const normalizedDir = path.posix.dirname(unknownPathToPosix(filePath));\n  return isPathEquivalent(posixDirName, normalizedDir);\n};\n\n/**\n *  Check if two paths that can be either in posix or win32 format resolves to the same file\n *\n * @param {string} pathA a path that may be either win32 or posix\n * @param {string} pathB a path that may be either win32 or posix\n *\n * @returns {boolean} do paths point to the same place\n */\nexport const isPathEquivalent = (pathA: string, pathB: string) => {\n  // Check if paths appear to be win32 or posix, and if win32 convert to posix\n  const normalizedPathA = path.posix.normalize(unknownPathToPosix(pathA));\n  const normalizedPathB = path.posix.normalize(unknownPathToPosix(pathB));\n\n  return !path.posix.relative(normalizedPathB, normalizedPathA).length;\n};\n\n/**\n *  Convert an unknown format path (win32 or posix) to a posix path\n *\n * @param {string} filePath a path that may be either win32 or posix\n *\n * @returns {string} a posix path\n */\nexport const unknownPathToPosix = (filePath: string) => {\n  // if it includes a forward slash, it must be posix already -- we will not support win32 with mixed path separators\n  if (filePath.includes(path.posix.sep)) {\n    return filePath;\n  }\n\n  return path.normalize(filePath).split(path.win32.sep).join(path.posix.sep);\n};\n","import type { Readable } from 'stream';\n\nimport zip from 'zlib';\nimport path from 'path';\nimport { pipeline, PassThrough } from 'stream';\nimport fs from 'fs-extra';\nimport tar from 'tar';\nimport { isEmpty, keyBy } from 'lodash/fp';\nimport { chain } from 'stream-chain';\nimport { parser } from 'stream-json/jsonl/Parser';\nimport type { Struct } from '@strapi/types';\n\nimport type { IAsset, IMetadata, ISourceProvider, ProviderType, IFile } from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\n\nimport * as utils from '../../../utils';\nimport { ProviderInitializationError, ProviderTransferError } from '../../../errors/providers';\nimport { isFilePathInDirname, isPathEquivalent, unknownPathToPosix } from './utils';\n\ntype StreamItemArray = Parameters<typeof chain>[0];\n\n/**\n * Constant for the metadata file path\n */\nconst METADATA_FILE_PATH = 'metadata.json';\n\n/**\n * Provider options\n */\nexport interface ILocalFileSourceProviderOptions {\n  file: {\n    path: string; // the file to load\n  };\n\n  encryption: {\n    enabled: boolean; // if the file is encrypted (and should be decrypted)\n    key?: string; // the key to decrypt the file\n  };\n\n  compression: {\n    enabled: boolean; // if the file is compressed (and should be decompressed)\n  };\n}\n\nexport const createLocalFileSourceProvider = (options: ILocalFileSourceProviderOptions) => {\n  return new LocalFileSourceProvider(options);\n};\n\nclass LocalFileSourceProvider implements ISourceProvider {\n  type: ProviderType = 'source';\n\n  name = 'source::local-file';\n\n  options: ILocalFileSourceProviderOptions;\n\n  #metadata?: IMetadata;\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: ILocalFileSourceProviderOptions) {\n    this.options = options;\n\n    const { encryption } = this.options;\n\n    if (encryption.enabled && encryption.key === undefined) {\n      throw new Error('Missing encryption key');\n    }\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'file-source-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  /**\n   * Pre flight checks regarding the provided options, making sure that the file can be opened (decrypted, decompressed), etc.\n   */\n  async bootstrap(diagnostics: IDiagnosticReporter) {\n    this.#diagnostics = diagnostics;\n    const { path: filePath } = this.options.file;\n\n    try {\n      // Read the metadata to ensure the file can be parsed\n      await this.#loadMetadata();\n      // TODO: we might also need to read the schema.jsonl files & implements a custom stream-check\n    } catch (e) {\n      if (this.options?.encryption?.enabled) {\n        throw new ProviderInitializationError(\n          `Key is incorrect or the file '${filePath}' is not a valid Strapi data file.`\n        );\n      }\n      throw new ProviderInitializationError(`File '${filePath}' is not a valid Strapi data file.`);\n    }\n\n    if (!this.#metadata) {\n      throw new ProviderInitializationError('Could not load metadata from Strapi data file.');\n    }\n  }\n\n  async #loadMetadata() {\n    const backupStream = this.#getBackupStream();\n    this.#metadata = await this.#parseJSONFile<IMetadata>(backupStream, METADATA_FILE_PATH);\n  }\n\n  async #loadAssetMetadata(path: string) {\n    const backupStream = this.#getBackupStream();\n    return this.#parseJSONFile<IFile>(backupStream, path);\n  }\n\n  async getMetadata() {\n    this.#reportInfo('getting metadata');\n    if (!this.#metadata) {\n      await this.#loadMetadata();\n    }\n\n    return this.#metadata ?? null;\n  }\n\n  async getSchemas() {\n    this.#reportInfo('getting schemas');\n    const schemaCollection = await utils.stream.collect<Struct.Schema>(\n      this.createSchemasReadStream()\n    );\n\n    if (isEmpty(schemaCollection)) {\n      throw new ProviderInitializationError('Could not load schemas from Strapi data file.');\n    }\n\n    // Group schema by UID\n    const schemas = keyBy('uid', schemaCollection);\n\n    // Transform to valid JSON\n    return utils.schema.schemasToValidJSON(schemas);\n  }\n\n  createEntitiesReadStream(): Readable {\n    this.#reportInfo('creating entities read stream');\n    return this.#streamJsonlDirectory('entities');\n  }\n\n  createSchemasReadStream(): Readable {\n    this.#reportInfo('creating schemas read stream');\n    return this.#streamJsonlDirectory('schemas');\n  }\n\n  createLinksReadStream(): Readable {\n    this.#reportInfo('creating links read stream');\n    return this.#streamJsonlDirectory('links');\n  }\n\n  createConfigurationReadStream(): Readable {\n    this.#reportInfo('creating configuration read stream');\n    // NOTE: TBD\n    return this.#streamJsonlDirectory('configuration');\n  }\n\n  createAssetsReadStream(): Readable | Promise<Readable> {\n    const inStream = this.#getBackupStream();\n    const outStream = new PassThrough({ objectMode: true });\n    const loadAssetMetadata = this.#loadAssetMetadata.bind(this);\n    this.#reportInfo('creating assets read stream');\n\n    pipeline(\n      [\n        inStream,\n        new tar.Parse({\n          // find only files in the assets/uploads folder\n          filter(filePath, entry) {\n            if (entry.type !== 'File') {\n              return false;\n            }\n            return isFilePathInDirname('assets/uploads', filePath);\n          },\n          async onentry(entry) {\n            const { path: filePath, size = 0 } = entry;\n            const normalizedPath = unknownPathToPosix(filePath);\n            const file = path.basename(normalizedPath);\n            let metadata;\n            try {\n              metadata = await loadAssetMetadata(`assets/metadata/${file}.json`);\n            } catch (error) {\n              throw new Error(`Failed to read metadata for ${file}`);\n            }\n            const asset: IAsset = {\n              metadata,\n              filename: file,\n              filepath: normalizedPath,\n              stats: { size },\n              stream: entry as unknown as Readable,\n            };\n            outStream.write(asset);\n          },\n        }),\n      ],\n      () => outStream.end()\n    );\n\n    return outStream;\n  }\n\n  #getBackupStream() {\n    const { file, encryption, compression } = this.options;\n\n    const streams: StreamItemArray = [];\n\n    try {\n      streams.push(fs.createReadStream(file.path));\n    } catch (e) {\n      throw new Error(`Could not read backup file path provided at \"${this.options.file.path}\"`);\n    }\n\n    if (encryption.enabled && encryption.key) {\n      streams.push(utils.encryption.createDecryptionCipher(encryption.key));\n    }\n\n    if (compression.enabled) {\n      streams.push(zip.createGunzip());\n    }\n\n    return chain(streams);\n  }\n\n  // `directory` must be posix formatted path\n  #streamJsonlDirectory(directory: string) {\n    const inStream = this.#getBackupStream();\n\n    const outStream = new PassThrough({ objectMode: true });\n\n    pipeline(\n      [\n        inStream,\n        new tar.Parse({\n          filter(filePath, entry) {\n            if (entry.type !== 'File') {\n              return false;\n            }\n\n            return isFilePathInDirname(directory, filePath);\n          },\n\n          async onentry(entry) {\n            const transforms = [\n              // JSONL parser to read the data chunks one by one (line by line)\n              parser({\n                checkErrors: true,\n              }),\n              // The JSONL parser returns each line as key/value\n              (line: { key: string; value: object }) => line.value,\n            ];\n\n            const stream = entry.pipe(chain(transforms));\n\n            try {\n              for await (const chunk of stream) {\n                outStream.write(chunk);\n              }\n            } catch (e: unknown) {\n              outStream.destroy(\n                new ProviderTransferError(\n                  `Error parsing backup files from backup file ${entry.path}: ${\n                    (e as Error).message\n                  }`,\n                  {\n                    details: {\n                      error: e,\n                    },\n                  }\n                )\n              );\n            }\n          },\n        }),\n      ],\n      async () => {\n        // Manually send the 'end' event to the out stream\n        // once every entry has finished streaming its content\n        outStream.end();\n      }\n    );\n\n    return outStream;\n  }\n\n  // For collecting an entire JSON file then parsing it, not for streaming JSONL\n  async #parseJSONFile<T extends object>(fileStream: Readable, filePath: string): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      pipeline(\n        [\n          fileStream,\n          // Custom backup archive parsing\n          new tar.Parse({\n            /**\n             * Filter the parsed entries to only keep the one that matches the given filepath\n             */\n            filter(entryPath, entry) {\n              if (entry.type !== 'File') {\n                return false;\n              }\n\n              return isPathEquivalent(entryPath, filePath);\n            },\n\n            async onentry(entry) {\n              // Collect all the content of the entry file\n              const content = await entry.collect();\n\n              try {\n                // Parse from buffer array to string to JSON\n                const parsedContent = JSON.parse(Buffer.concat(content).toString());\n\n                // Resolve the Promise with the parsed content\n                resolve(parsedContent);\n              } catch (e) {\n                reject(e);\n              } finally {\n                // Cleanup (close the stream associated to the entry)\n                entry.destroy();\n              }\n            },\n          }),\n        ],\n        () => {\n          // If the promise hasn't been resolved and we've parsed all\n          // the archive entries, then the file doesn't exist\n          reject(new Error(`File \"${filePath}\" not found`));\n        }\n      );\n    });\n  }\n}\n","import { Writable } from 'stream';\nimport { posix } from 'path';\nimport tar from 'tar-stream';\n\n/**\n * Create a file path factory for a given path & prefix.\n * Upon being called, the factory will return a file path for a given index\n */\nexport const createFilePathFactory =\n  (type: string) =>\n  (fileIndex = 0): string => {\n    // always write tar files with posix paths so we have a standard format for paths regardless of system\n    return posix.join(\n      // \"{type}\" directory\n      type,\n      // \"${type}_XXXXX.jsonl\" file\n      `${type}_${String(fileIndex).padStart(5, '0')}.jsonl`\n    );\n  };\n\nexport const createTarEntryStream = (\n  archive: tar.Pack,\n  pathFactory: (index?: number) => string,\n  maxSize = 2.56e8\n) => {\n  let fileIndex = 0;\n  let buffer = '';\n\n  const flush = async () => {\n    if (!buffer) {\n      return;\n    }\n\n    fileIndex += 1;\n    const name = pathFactory(fileIndex);\n    const size = buffer.length;\n\n    await new Promise<void>((resolve, reject) => {\n      archive.entry({ name, size }, buffer, (err) => {\n        if (err) {\n          reject(err);\n        }\n\n        resolve();\n      });\n    });\n\n    buffer = '';\n  };\n\n  const push = (chunk: string | Buffer) => {\n    buffer += chunk;\n  };\n\n  return new Writable({\n    async destroy(err, callback) {\n      await flush();\n      callback(err);\n    },\n\n    async write(chunk, _encoding, callback) {\n      const size = chunk.length;\n\n      if (chunk.length > maxSize) {\n        callback(new Error(`payload too large: ${chunk.length}>${maxSize}`));\n        return;\n      }\n\n      if (buffer.length + size > maxSize) {\n        await flush();\n      }\n\n      push(chunk);\n\n      callback(null);\n    },\n  });\n};\n","import path from 'path';\nimport zlib from 'zlib';\nimport { Readable, Writable } from 'stream';\nimport { rm, createWriteStream } from 'fs-extra';\nimport tar from 'tar-stream';\nimport { stringer } from 'stream-json/jsonl/Stringer';\nimport { chain } from 'stream-chain';\n\nimport { createEncryptionCipher } from '../../../utils/encryption';\nimport type {\n  IAsset,\n  IDestinationProvider,\n  IDestinationProviderTransferResults,\n  IMetadata,\n  ProviderType,\n  Stream,\n} from '../../../../types';\nimport type { IDiagnosticReporter } from '../../../utils/diagnostic';\nimport { createFilePathFactory, createTarEntryStream } from './utils';\nimport { ProviderTransferError } from '../../../errors/providers';\n\nexport interface ILocalFileDestinationProviderOptions {\n  encryption: {\n    enabled: boolean; // if the file should be encrypted\n    key?: string; // the key to use when encryption.enabled is true\n  };\n\n  compression: {\n    enabled: boolean; // if the file should be compressed with gzip\n  };\n\n  file: {\n    path: string; // the filename to create\n    maxSize?: number; // the max size of a single backup file\n    maxSizeJsonl?: number; // the max lines of each jsonl file before creating the next file\n  };\n}\n\nexport interface ILocalFileDestinationProviderTransferResults\n  extends IDestinationProviderTransferResults {\n  file?: {\n    path?: string;\n  };\n}\n\nexport const createLocalFileDestinationProvider = (\n  options: ILocalFileDestinationProviderOptions\n) => {\n  return new LocalFileDestinationProvider(options);\n};\n\nclass LocalFileDestinationProvider implements IDestinationProvider {\n  name = 'destination::local-file';\n\n  type: ProviderType = 'destination';\n\n  options: ILocalFileDestinationProviderOptions;\n\n  results: ILocalFileDestinationProviderTransferResults = {};\n\n  #providersMetadata: { source?: IMetadata; destination?: IMetadata } = {};\n\n  #archive: { stream?: tar.Pack; pipeline?: Stream } = {};\n\n  #diagnostics?: IDiagnosticReporter;\n\n  constructor(options: ILocalFileDestinationProviderOptions) {\n    this.options = options;\n  }\n\n  #reportInfo(message: string) {\n    this.#diagnostics?.report({\n      details: {\n        createdAt: new Date(),\n        message,\n        origin: 'file-destination-provider',\n      },\n      kind: 'info',\n    });\n  }\n\n  get #archivePath() {\n    const { encryption, compression, file } = this.options;\n\n    let filePath = `${file.path}.tar`;\n\n    if (compression.enabled) {\n      filePath += '.gz';\n    }\n\n    if (encryption.enabled) {\n      filePath += '.enc';\n    }\n\n    return filePath;\n  }\n\n  setMetadata(target: ProviderType, metadata: IMetadata): IDestinationProvider {\n    this.#providersMetadata[target] = metadata;\n\n    return this;\n  }\n\n  createGzip(): zlib.Gzip {\n    this.#reportInfo('creating gzip');\n    return zlib.createGzip();\n  }\n\n  bootstrap(diagnostics: IDiagnosticReporter): void | Promise<void> {\n    this.#diagnostics = diagnostics;\n    const { compression, encryption } = this.options;\n\n    if (encryption.enabled && !encryption.key) {\n      throw new Error(\"Can't encrypt without a key\");\n    }\n\n    this.#archive.stream = tar.pack();\n\n    const outStream = createWriteStream(this.#archivePath);\n\n    outStream.on('error', (err: NodeJS.ErrnoException) => {\n      if (err.code === 'ENOSPC') {\n        throw new ProviderTransferError(\n          \"Your server doesn't have space to proceed with the import.\"\n        );\n      }\n      throw err;\n    });\n\n    const archiveTransforms: Stream[] = [];\n\n    if (compression.enabled) {\n      archiveTransforms.push(this.createGzip());\n    }\n\n    if (encryption.enabled && encryption.key) {\n      archiveTransforms.push(createEncryptionCipher(encryption.key));\n    }\n\n    this.#archive.pipeline = chain([this.#archive.stream, ...archiveTransforms, outStream]);\n\n    this.results.file = { path: this.#archivePath };\n  }\n\n  async close() {\n    const { stream, pipeline } = this.#archive;\n\n    if (!stream) {\n      return;\n    }\n\n    await this.#writeMetadata();\n    stream.finalize();\n\n    if (pipeline && !pipeline.closed) {\n      await new Promise<void>((resolve, reject) => {\n        pipeline.on('close', resolve).on('error', reject);\n      });\n    }\n  }\n\n  async rollback(): Promise<void> {\n    this.#reportInfo('rolling back');\n    await this.close();\n    await rm(this.#archivePath, { force: true });\n  }\n\n  getMetadata() {\n    return null;\n  }\n\n  async #writeMetadata(): Promise<void> {\n    this.#reportInfo('writing metadata');\n    const metadata = this.#providersMetadata.source;\n\n    if (metadata) {\n      await new Promise((resolve) => {\n        const outStream = this.#getMetadataStream();\n        const data = JSON.stringify(metadata, null, 2);\n\n        Readable.from(data).pipe(outStream).on('close', resolve);\n      });\n    }\n  }\n\n  #getMetadataStream() {\n    const { stream } = this.#archive;\n\n    if (!stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    return createTarEntryStream(stream, () => 'metadata.json');\n  }\n\n  createSchemasWriteStream() {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating schemas write stream');\n    const filePathFactory = createFilePathFactory('schemas');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createEntitiesWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating entities write stream');\n    const filePathFactory = createFilePathFactory('entities');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createLinksWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating links write stream');\n    const filePathFactory = createFilePathFactory('links');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createConfigurationWriteStream(): Writable {\n    if (!this.#archive.stream) {\n      throw new Error('Archive stream is unavailable');\n    }\n    this.#reportInfo('creating configuration write stream');\n    const filePathFactory = createFilePathFactory('configuration');\n\n    const entryStream = createTarEntryStream(\n      this.#archive.stream,\n      filePathFactory,\n      this.options.file.maxSizeJsonl\n    );\n\n    return chain([stringer(), entryStream]);\n  }\n\n  createAssetsWriteStream(): Writable {\n    const { stream: archiveStream } = this.#archive;\n\n    if (!archiveStream) {\n      throw new Error('Archive stream is unavailable');\n    }\n\n    this.#reportInfo('creating assets write stream');\n    return new Writable({\n      objectMode: true,\n      write(data: IAsset, _encoding, callback) {\n        // always write tar files with posix paths so we have a standard format for paths regardless of system\n        const entryPath = path.posix.join('assets', 'uploads', data.filename);\n\n        const entryMetadataPath = path.posix.join('assets', 'metadata', `${data.filename}.json`);\n        const stringifiedMetadata = JSON.stringify(data.metadata);\n        archiveStream.entry(\n          {\n            name: entryMetadataPath,\n            size: stringifiedMetadata.length,\n          },\n          stringifiedMetadata\n        );\n\n        const entry = archiveStream.entry({\n          name: entryPath,\n          size: data.stats.size,\n        });\n\n        if (!entry) {\n          callback(new Error(`Failed to created an asset tar entry for ${entryPath}`));\n          return;\n        }\n\n        data.stream.pipe(entry);\n\n        entry\n          .on('finish', () => {\n            callback(null);\n          })\n          .on('error', (error) => {\n            callback(error);\n          });\n      },\n    });\n  }\n}\n"],"names":["getEncryptionStrategy","algorithm","strategies","key","hashedKey","scryptSync","initVector","securityKey","createCipheriv","aes128","slice","aes192","aes256","createEncryptionCipher","getDecryptionStrategy","createDecipheriv","createDecryptionCipher","filter","predicate","options","objectMode","Transform","transform","chunk","_encoding","callback","keep","undefined","map","mappedValue","collect","stream","destroy","chunks","Promise","resolve","reject","on","push","createContext","path","diff","a","b","ctx","diffs","aType","bType","added","kind","type","value","deleted","modified","types","values","isArray","k","aItem","bItem","zip","kCtx","toString","kDiffs","isObject","keys","uniq","Object","concat","aValue","bValue","nestedDiffs","isEqual","VALID_SCHEMA_PROPERTIES","mapSchemasValues","schemas","mapValues","pick","schemasToValidJSON","JSON","parse","stringify","createTransaction","strapi","fns","done","resume","e","EventEmitter","uuid","cb","fn","removeAllListeners","db","transaction","trx","rollback","once","emit","length","item","shift","res","data","error","attach","randomUUID","end","runMiddleware","context","middlewares","newContext","createDiagnosticReporter","stackSize","emitter","stack","addListener","event","listener","isDiagnosticValid","diagnostic","details","message","size","items","report","onDiagnostic","OPTIONAL_CONTENT_TYPES","isAttributeIgnorable","includes","isOptionalAdminType","name","info","singularName","isIgnorableStrict","exact","strict","compareSchemas","strategy","utils","SeverityKind","FATAL","ERROR","SILLY","DataTransferError","Error","constructor","origin","severity","TransferEngineError","TransferEngineInitializationError","step","TransferEngineValidationError","TransferEngineTransferError","reason","validateProvider","provider","capitalize","ProviderError","ProviderInitializationError","ProviderValidationError","ProviderTransferError","TRANSFER_STAGES","freeze","TransferGroupPresets","content","links","entities","files","assets","config","configuration","DEFAULT_VERSION_STRATEGY","DEFAULT_SCHEMA_STRATEGY","_metadata","_class_private_field_loose_key","TransferEngine","onSchemaDiff","handler","_class_private_field_loose_base","handlers","schemaDiff","addErrorHandler","handlerName","errors","attemptResolveError","code","errorCode","ignore","panic","reportError","diagnostics","createdAt","Date","reportWarning","reportInfo","params","shouldSkipStage","stage","exclude","only","included","isEmpty","some","transferGroup","abortTransfer","err","currentStream","init","resolveProviderResource","source","sourceMetadata","metadata","destinationProvider","setMetadata","bootstrap","results","allSettled","sourceProvider","forEach","result","status","close","integrityCheck","getMetadata","destinationMetadata","assertStrapiVersionIntegrity","version","sourceSchemas","destinationSchemas","getSchemas","assertSchemasMatching","schemaDiffs","ignoredDiffs","destination","unresolvedDiffs","check","transfer","progress","emitTransferUpdate","beforeTransfer","transferSchemas","transferEntities","transferAssets","transferLinks","transferConfiguration","lastDiagnostic","last","engine","runWithDiagnostic","resolved","createSchemasReadStream","createSchemasWriteStream","createStageTransformStream","tracker","progressTracker","modelType","transferStage","createEntitiesReadStream","createEntitiesWriteStream","chain","entity","availableContentTypes","entries","schema","uid","attributes","attributesToKeep","updatedEntity","set","createLinksReadStream","createLinksWriteStream","link","isValidType","left","right","createAssetsReadStream","createAssetsWriteStream","stats","extname","filename","createConfigurationReadStream","createConfigurationWriteStream","PassThrough","includeGlobal","throttle","global","globalTransforms","stageTransforms","transforms","applyTransforms","chainTransforms","pipe","isNumber","setTimeout","aggregate","count","bytes","startTime","now","stageProgress","aggregates","updateTransferProgress","emitStageUpdate","payload","sourceVersion","destinationVersion","versionStrategy","versions","semverDiff","validPatch","validMinor","validMajor","schemaStrategy","sourceSchema","destinationSchema","formattedDiffs","ctDiffs","msg","EOL","sort","join","line","updateEndTime","stageData","endTime","destroyed","state","createTransferEngine","isDialectMySQL","dialect","client","omitComponentData","contentType","componentAttributes","attributeName","contentTypesUtils","isComponentAttribute","omit","createComponents","getModel","componentBody","attributeNames","attribute","has","component","componentUID","repeatable","componentValue","Array","components","async","createComponent","concurrency","inTransaction","Infinity","id","__pivot","field","component_type","dynamiczoneValues","createDynamicZoneComponents","__component","getComponents","getComponentAttributes","_","query","load","deleteComponents","entityToDelete","loadComponents","castArray","subValue","deleteComponent","model","componentData","assign","create","componentToDelete","delete","where","resolveComponentUID","paths","cType","get","sanitizeComponentLikeAttributes","componentLikeAttributesKey","omitInvalidCreationAttributes","createEntityQuery","assignToEntity","entityComponents","componentsService","dataWithoutComponents","componentsToDelete","dataWithComponents","sanitizedData","createMany","then","deleteMany","entitiesToDelete","findMany","all","deletedEntities","compos","getDeepPopulateComponentLikeQuery","select","populate","subPopulate","componentsUID","every","deepPopulateComponentLikeQuery","createLinkQuery","connection","addSchema","tableName","schemaName","connectionSettings","generateAllForAttribute","fieldName","filterValidRelationalAttributes","getLinkKind","relation","target","joinColumn","joinColumnName","qb","queryBuilder","from","transacting","entry","ref","joinTable","inverseJoinColumn","orderColumnName","morphColumn","inverseOrderColumnName","columns","inversedBy","order","idColumn","typeColumn","validColumns","column","isNil","pos","clone","whereNotNull","generateAll","insert","update","assignInverseColumn","assignOrderColumns","assignMorphColumns","into","nestedTrx","isOwner","owner","mappedBy","morphBy","isComponentLike","endsWith","reduce","acc","startsWith","updateMappingTable","queries","Writable","write","created","json","oldID","newID","restoreCoreStore","restoreWebhooks","restoreConfigs","chalk","yellowBright","greenBright","isErrorWithCode","isForeignKeyConstraintError","MYSQL_FK_ERROR_CODES","POSTGRES_FK_ERROR_CODE","SQLITE_FK_ERROR_CODE","toLowerCase","mapID","onWarning","originalLeftRef","originalRightRef","deleteRecords","deleteEntitiesRecords","deleteConfigurationRecords","models","contentTypes","contentTypesToClear","removeThisContentType","include","filters","modelsToClear","removeThisModel","updateResults","useResults","contentTypeQuery","contentTypePromises","modelsPromises","coreStore","webhook","deletePromises","assertValidStrapi","VALID_CONFLICT_STRATEGIES","DEFAULT_CONFLICT_STRATEGY","_diagnostics","_reportInfo","LocalStrapiDestinationProvider","validateOptions","getStrapi","lifecycles","disable","autoDestroy","enable","handleAssetsBackup","deleteAllAssets","deleteFromRestoreOptions","strapiVersion","toISOString","entitiesMapper","restore","validStrategies","areAssetsIncluded","removeAssetsBackup","bind","fileEntitiesMapper","restoreMediaEntitiesContent","isContentTypeIncluded","final","next","uploadData","Readable","buffer","fileId","plugin","uploadStream","findOne","specificFormat","formats","url","notIncluded","excluded","uploadsBackupDirectoryName","file","fileFormat","assetsDirectory","dirs","static","public","backupDirectory","fse","access","constants","W_OK","R_OK","F_OK","move","mkdir","outputFile","rm","recursive","force","createLocalStrapiDestinationProvider","createEntitiesStream","contentTypeStreamGenerator","shared","call","entitiesGenerator","createEntitiesTransformStream","createLinksStream","uids","linkGenerator","generator","createConfigurationStream","configurationGenerator","coreStoreStream","wrapConfigurationItem","webhooksStream","streams","getFileStream","filepath","isLocal","createReadStream","readableStream","fetch","body","fromWeb","webStream","ReadableStream","catch","getFileStats","stat","contentLength","headers","parseInt","signFile","plugins","upload","providerName","isPrivate","signUrl","signedUrl","getSignedUrl","format","createAssetsStream","isLocalProvider","hash","ext","fileFormatFilepath","fileFormatStats","fileFormatStream","mainHash","Duplex","createLocalStrapiSourceProvider","LocalStrapiSourceProvider","createDispatcher","ws","retryMessageOptions","retryMessageMaxRetries","retryMessageTimeout","dispatch","numberOfTimesMessageWasSent","attachTransfer","transferID","command","messageToSend","action","stringifiedPayload","send","sendPeriodically","interval","setInterval","onResponse","raw","response","clearInterval","dispatchCommand","dispatchTransferAction","dispatchTransferStep","setTransferProperties","properties","transferKind","connectToWebsocket","address","server","WebSocket","_req","statusCode","trimTrailingSlash","input","replace","wait","ms","waitUntil","test","TRANSFER_PATH","TRANSFER_METHODS","jsonLength","obj","Buffer","byteLength","_startStep","_endStep","RemoteStrapiDestinationProvider","resetStats","initTransfer","dispatcher","auth","validProtocols","protocol","wsProtocol","wsUrl","host","pathname","Authorization","token","CLOSED","writeStream","batch","hasStarted","batchSize","batchLength","startAssetsTransferOnce","startStepOnce","flush","streamError","streamStep","safePush","endStepError","endStep","asset","startError","assetID","startStep","assetMessage","startTransferOnce","started","finished","createRemoteStrapiDestinationProvider","RemoteStrapiSourceProvider","createStageReadStream","pass","queue","writeAsync","writeAssetChunk","closeAssetStream","race","currentStatus","nextItemInQueue","unsafe_writeAssetChunk","rawBuffer","assertValidProtocol","startResult","processID","parsed","ended","respond","createRemoteStrapiSourceProvider","createFlow","flow","stepEqual","stepA","stepB","findStepIndex","findIndex","flowStep","can","indexesDifference","cannot","canSwitch","VALID_TRANSFER_COMMANDS","transformUpgradeHeader","header","split","s","trim","timeouts","hasHttpServer","httpServer","disableTimeouts","headersTimeout","requestTimeout","log","resetTimeouts","assertValidHeader","upgrade","upgradeHeader","logSafeUpgradeHeader","substring","isDataTransferMessage","handleWSUpgrade","wss","handleUpgrade","req","request","socket","alloc","handlerControllerFactory","implementation","verify","serverOptions","Server","noServer","messageUUIDs","Set","cannotRespondHandler","terminate","prototype","startedAt","timestamp","addUUID","add","hasUUID","isTransferStarted","assertValidTransfer","isStarted","assertValidTransferCommand","isDefined","isValidTransferCommand","confirm","executeAndRespond","cleanup","teardown","verifyAuth","scope","onMessage","onError","onClose","onInfo","args","VALID_TRANSFER_ACTIONS","TRANSFER_KIND","createPushController","proto","assertValidTransferAction","validActions","assertValidStreamTransferStep","currentStep","nextStep","locked","createWritableStreamForStep","mapper","previousResponse","onTransferMessage","onTransferAction","onTransferStep","lockTransferStep","unlockTransferStep","ok","streamAsset","closed","isStepRegistered","assetsStream","assetStream","DEFAULT_TRANSFER_FLOW","warn","active","elapsed","createPullController","sendBatch","flushUUID","createReadableStreamForStep","readableEnded","BATCH_MAX_SIZE","assetData","assetChunk","isFilePathInDirname","posixDirName","filePath","normalizedDir","posix","dirname","unknownPathToPosix","isPathEquivalent","pathA","pathB","normalizedPathA","normalize","normalizedPathB","relative","sep","win32","METADATA_FILE_PATH","createLocalFileSourceProvider","LocalFileSourceProvider","loadMetadata","encryption","enabled","schemaCollection","keyBy","streamJsonlDirectory","inStream","getBackupStream","outStream","loadAssetMetadata","pipeline","tar","Parse","onentry","normalizedPath","basename","backupStream","parseJSONFile","compression","fs","createGunzip","directory","parser","checkErrors","fileStream","entryPath","parsedContent","createFilePathFactory","fileIndex","String","padStart","createTarEntryStream","archive","pathFactory","maxSize","createLocalFileDestinationProvider","LocalFileDestinationProvider","providersMetadata","createGzip","zlib","pack","createWriteStream","archivePath","archiveTransforms","writeMetadata","finalize","filePathFactory","entryStream","maxSizeJsonl","stringer","archiveStream","entryMetadataPath","stringifiedMetadata","getMetadataStream"],"mappings":"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"}